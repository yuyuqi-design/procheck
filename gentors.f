C**************************************************************************
C
C  GENTORS.FOR  -  Program to generate the torsion angle distributions
C                  used by the tplot.f program in the PROCHECK suite.
C                  Torsion angles generated are:
C                     1. Phi-psi distributions (2D distrib)
C                     2. Chi1-chi2 distributions (2D distrib)
C                     3. Chi1 only, for use by tplot.f on residues
C                        not having a chi2
C                     4. Chi3
C                     5. Chi4
C                     6. Omega torsion angle
C                  on a residue-by-residue basis
C
C                  The input file gentors.lst holds the proteins making
C                  up the data set to be used. The list holds the names
C                  of .rin files generated by running the shell script
C                  gorin.scr.
C
C  Written by Roman Laskowski, University College, London, Nov 1993.
C
C--------------------------------------------------------------------------
C
C Files
C -----
C
C  1 gentors.lst    -  Input file holding a list of all the .rin files that
C                      comprise the data set. The .rin files are generated by
C                      the shell script gorin.scr which runs programs clean.f
C                      and secstr.f in the PROCHECK suite
C  2 carrays.dat    -  Input file holding all the CA-angles vs CA torsion
C                      angles data calculated by cafold.c
C  3 <filename>.rin -  Individual .rin files
C  7 procheck.dat   -  Output file holding the distributions in compressed
C                      form
C  8 gentorsN.dat   -  Output arrays of the distributions used for checking
C                      and debugging purposes, where N is the number of the
C                      distribution
C
C--------------------------------------------------------------------------
C
C Subroutine calling tree
C -----------------------
C
C MAIN    --> OPNLST
C
C         Loop through the different distributions to be generated
C         --> INITS
C         --> OPNFIL
C
C         Loop through the structures in the gentors.lst file
C
C         --> REALST  --> GETCHN
C                     --> GETNAM
C
C         Read in the appropriate values and obtain frequency
C         distributions or energy differences
C
C         --> READIN
C         --> COMPRS
C         --> ARROUT
C
C         Plot the distributions
C
C         --> PLOT3D  --> PSNAME
C                     --> PSOPEN
C                     --> PLTGRD  --> PLTDIS --> PSLWID
C                                            --> PSHADE
C                                            --> PSUBOX
C                                            --> PSLWID
C                                            --> PSLINE
C                                 --> AXES   --> PSLWID
C                                            --> PSLINE
C                                            --> PSCTXT
C                                 --> PSCTXT
C                                 --> PSRTXT
C                     --> PLTSUM  --> PSTEXT
C                                 --> PSCTXT
C                     --> PSCLOS
C
C         --> MDCOMP
C
C----------------------------------------------------------------------+---


      PROGRAM GENTORS

      INCLUDE 'gentors.inc'

      INTEGER       IARRAY(MXCELL), NCELL1, NCELL2

      REAL          ARRAY(MXCELL * (NAMINO + 1)), TARRAY(MXCELL)

CDEBUG
C      INTEGER       IAMINO, ICELL, JCELL
C      REAL          TPROB
CDEBUG


C---- Initialise paths
      PDBDIR = '/data/pdb_release/all/'
      PDBPRE = 'pdb'
      PDBEXT = '.ent'
      RINEXT = '.rin'

C---- Open gentors.lst file containing list of .rin files making up the data
C     data set. Open compressed output file
      CALL OPNLST
      IF (IFAIL) GO TO 999

C---- Loop through all the options
      DO 800, DISTRB = 1, NDISTR

C----     Initialise variables
          CALL INITS(ARRAY,MXCELL * (NAMINO + 1),TARRAY,MXCELL,NCELL1,
     -        NCELL2)
          IF (IFAIL) GO TO 999

C----     Open output files specific to this distribution
          CALL OPNFIL
          IF (IFAIL) GO TO 999

C----     If this is the CA-angles CA-torsion angles distribution, read in
C         the data from the carrays.dat file
          IF (DISTRB.EQ.7) THEN

C----         Get the distribution data generated by program cafold
              CALL GETCAR(ARRAY,NCELL1,NCELL2)

C----     Otherwise, get the data from the list of .rin files
          ELSE

C----         Loop through the structures in gentors.lst file
100           CONTINUE

C----             Read in the next record from gentors.lst and open
C                 corresponding Brookhaven and non-bonded contacts files
                  CALL REALST
                  IF (.NOT.ENDLST .AND. .NOT.IFAIL) THEN

C----                 Read in the data from the .rin file
                      CALL READIN(ARRAY,TARRAY,NCELL1,NCELL2)
                  ENDIF

C----         Loop back for next Brookhaven filename
              IF (.NOT.ENDLST) GO TO 100
          ENDIF

C----     Check whether any values have been read in at all
          IF (TRESID.EQ.0) THEN
              PRINT*, '*** ERROR. No residue values found in dataset'
              IFAIL = .TRUE.
              GO TO 999
          ENDIF

C----     Write out a compressed version of the distribution
          CALL COMPRS(ARRAY,NCELL1,NCELL2)

C----     Write out log odds array
          CALL ARROUT(ARRAY,IARRAY,NCELL1,NCELL2)
          IF (IFAIL) GO TO 999

C----     Plot the distribution
          IF (TWODEE) CALL PLOT3D(ARRAY,NCELL1,NCELL2)
800   CONTINUE

 999  CONTINUE
      IF (IFAIL) THEN
          PRINT*
          PRINT*, '*** Program terminated with error'
      ELSE
          PRINT*
          PRINT*, 'Program complete'
          PRINT*
          PRINT*, 'Number of protein files processed:', NFILES
          PRINT*
          PRINT*, 'Total number of residues:         ', TRESID
          PRINT*
      ENDIF

      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C     SUBROUTINE OPNLST  -   Open input file gentors.lst containing list
C                            of .rin files comprising the data set. Open
C                            main output file procheck.dat which will
C                            contain the distributions in compressed form
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNLST

      INCLUDE 'gentors.inc'

C---- Initialise variables
      IFAIL = .FALSE.

C---- Open gentors.lst file
      OPEN(UNIT=1,FILE='gentors.lst',STATUS='OLD',ERR=900,
CVAX     -    READONLY,
     -    FORM='FORMATTED',ACCESS='SEQUENTIAL')

C---- Open output file, procheck.dat
      OPEN(UNIT=7,FILE='procheck.dat',STATUS='UNKNOWN',ERR=902,
CVAX     -     CARRIAGECONTROL='LIST',
     -    FORM='FORMATTED',ACCESS='SEQUENTIAL')

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Error opening gentors.lst file. Program aborted.'
      GO TO 990

 902  CONTINUE
      PRINT*, '*** Error opening procheck.dat file. Program aborted.'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE INITS  -  Initialise variables for this distribution
C
C----------------------------------------------------------------------+---

      SUBROUTINE INITS(ARRAY,TCELLS,TARRAY,NCELLS,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELLS, TCELLS

      INTEGER       IAMINO, ICELL, NCELL1, NCELL2
      REAL          ARRAY(TCELLS), TARRAY(NCELLS)

C---- Initialise variables
      ENDLST = .FALSE.
      IFAIL = .FALSE.
      NFILES = 0
      PERMAX = -99999.99
      PERMIN = 99999.99
      TWODEE = .FALSE.
      DO 100, ICELL = 1, TCELLS
          ARRAY(ICELL) = 0.0
 100  CONTINUE
      DO 200, ICELL = 1, NCELLS
          TARRAY(ICELL) = 0.0
 200  CONTINUE
      DO 400, IAMINO = 1, NAMINO + 1
         NCOUNT(IAMINO) = 0
 400  CONTINUE
      TRESID = 0
      PRINT*
      PRINT*, 'Processing distribution ', DISTRB
      PRINT*, '---------------------------'
      PRINT*

C---- Determine range details for the given distribution
      IF (DISTRB.EQ.1) THEN
          VALBEG(1) = -180.0
          VALBEG(2) = -180.0
          VALEND(1) =  180.0
          VALEND(2) =  180.0
          TWODEE = .TRUE.
      ELSE IF (DISTRB.EQ.2) THEN
          VALBEG(1) =    0.0
          VALBEG(2) =    0.0
          VALEND(1) =  360.0
          VALEND(2) =  360.0
          TWODEE = .TRUE.
      ELSE IF (DISTRB.EQ.3) THEN
          VALBEG(1) =    0.0
          VALEND(1) =  360.0
      ELSE IF (DISTRB.EQ.4) THEN
          VALBEG(1) =    0.0
          VALEND(1) =  360.0
      ELSE IF (DISTRB.EQ.5) THEN
          VALBEG(1) =    0.0
          VALEND(1) =  360.0
      ELSE IF (DISTRB.EQ.6) THEN
          VALBEG(1) =    0.0
          VALEND(1) =  360.0
      ELSE IF (DISTRB.EQ.7) THEN
          VALBEG(1) =    0.0
          VALBEG(2) = -180.0
          VALEND(1) =  180.0
          VALEND(2) =  180.0
          TWODEE = .TRUE.
      ELSE
          IFAIL = .TRUE.
          GO TO 999
      ENDIF

C---- Define the number of cells in the distribution
      IF (TWODEE) THEN
          IF (DISTRB.EQ.7) THEN
              NCELL1 = 60
              NCELL2 = 120
          ELSE
              NCELL1 = 45
              NCELL2 = 45
          ENDIF
      ELSE
          NCELL1 = 45 * 45
          NCELL2 = 1
      ENDIF

C---- Size of this distribution
      IF ((NCELL1 * NCELL2).GT.MXCELL) GO TO 900

C---- Determine cell-size in each direction
      IF (TWODEE) THEN
          STEP(1) = (VALEND(1) - VALBEG(1)) / NCELL1
          STEP(2) = (VALEND(2) - VALBEG(2)) / NCELL2
      ELSE
          STEP(1) = (VALEND(1) - VALBEG(1)) / NCELL1
      ENDIF

      GO TO 999


C---- Errors reading parameter file
 900  CONTINUE
      PRINT*, '*** ERROR. Program error. Distribution too large for ',
     -    'array:', MXCELL
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C     SUBROUTINE OPNFIL  -   Open output file gentorsN,dat for this
C                            distribution
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNFIL

      INCLUDE 'gentors.inc'

      CHARACTER*1   COPT, QUOTE
      CHARACTER*20  FNAME

      DATA QUOTE / '''' /

C---- Rewind the file containing the list of PDB files making up the
C     dataset
      REWIND(1)

C---- Open output file, gentorsN.dat, where N is the distribution number
      WRITE(COPT,120) DISTRB
 120  FORMAT(I1)
      FNAME = 'gentors' // COPT // '.dat'
      OPEN(UNIT=8,FILE=FNAME,STATUS='UNKNOWN',ERR=900,
CVAX     -    CARRIAGECONTROL='LIST',
     -    FORM='FORMATTED',ACCESS='SEQUENTIAL')

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Error opening ', FNAME(1:12),' file.',
     -   ' Program aborted.'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C     SUBROUTINE GETCAR  -   Read in the distribution data generated by
C                            program cafold giving the CA-angle vs CA
C                            torsion angle distributions, carrays.dat
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCAR(ARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      CHARACTER*3   AMNAME(NAMINO), RESNAM
      CHARACTER*120 IREC
      INTEGER       IAMINO, ICELL, JCELL, LENSTR, LINE
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1)

      DATA AMNAME /'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -             'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -             'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

C---- Initialise variables
      IFAIL = .FALSE.
      LINE = 0

C---- Open carrays.dat file
      OPEN(UNIT=2,FILE='carrays.dat',STATUS='OLD',ERR=900,
CVAX     -    READONLY,
     -    FORM='FORMATTED',ACCESS='SEQUENTIAL')

C---- Read in the first line giving the array size
      LINE = LINE + 1
      READ(2,*,ERR=902,END=904) ICELL, JCELL, NFILES
      IF (ICELL.NE.NCELL1 .OR. JCELL.NE.NCELL2) GO TO 906

C---- Loop while reading through the carrays.dat file
 100  CONTINUE

C----     Read in the next residue type
          LINE = LINE + 1
          READ(2,120,ERR=902,END=800) IREC
 120      FORMAT(A)

C----     Check that correct record type read in
          IF (IREC(1:7).NE.'RESTYPE') GO TO 908

C----     Get the residue type
          READ(IREC,140,ERR=910) IAMINO, RESNAM
 140      FORMAT(8X,I2,1X,A3)

C----     Check that residue number matches residue type
          IF (IAMINO.LT.1 .OR. IAMINO.GT.NAMINO) GO TO 910
          IF (RESNAM.NE.AMNAME(IAMINO)) GO TO 910

C----     Read in this residue's distribution
          LINE = LINE + 1
          READ(2,*,ERR=912,END=904) ((ARRAY(ICELL,JCELL,IAMINO),
     -        JCELL = 1, NCELL2), ICELL = 1, NCELL1)

C----     Loop through the values just read in to accumulate overall count
          DO 300, JCELL = 1, NCELL2
              DO 200, ICELL = 1, NCELL1
                  TRESID = TRESID + ARRAY(ICELL,JCELL,IAMINO)
                  NCOUNT(IAMINO) = NCOUNT(IAMINO)
     -                + ARRAY(ICELL,JCELL,IAMINO)
 200          CONTINUE
 300      CONTINUE

C----     Loop back for next record
          GO TO 100

C---- End of file reached
 800  CONTINUE

C---- Close the carrays.dat file
      CLOSE(2)

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Error opening carrays.dat file. Program aborted.'
      GO TO 990

 902  CONTINUE
      PRINT*, '*** Data error reading carrays.dat file at line', LINE
      GO TO 990

 904  CONTINUE
      PRINT*, '*** ERROR. Premature EOF in carrays.dat file at line',
     -    LINE
      GO TO 990

 906  CONTINUE
      PRINT 907, '*** ERROR. Array size in carrays.dat file (',
     -    ICELL, JCELL, ') disagrees with', 'size set in program (',
     -    NCELL1, NCELL2, ')'
 907  FORMAT(A,I3,I3,A,/,A,I3,I3,A)
      GO TO 990

 908  CONTINUE
      PRINT*, '*** ERROR. Expected RESTYPE record in carrays.dat file',
     -    ' but got [', IREC(1:LENSTR(IREC)), ']'
      GO TO 990

 910  CONTINUE
      PRINT*, '*** Error in RESTYPE record [', IREC(1:LENSTR(IREC)), ']'
      GO TO 990

 912  CONTINUE
      PRINT 913, '*** Error reading array data for IAMINO, ICELL,',
     -    ' JCELL ', IAMINO, ICELL, JCELL
 913  FORMAT(2A,3I5)
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C     SUBROUTINE REALST  -  Read in the next file name from gentors.lst file
C                           and open corresponding .rin file
C
C----------------------------------------------------------------------+---

      SUBROUTINE REALST

      INCLUDE 'gentors.inc'

      CHARACTER*80  FNAME
      INTEGER       IEND, LENSTR

C---- Initialise variables
      BCODE = ' '
      IFAIL = .FALSE.

C---- Read in next record from gentors.lst file
 100  CONTINUE
          READ(1,150,END=800,ERR=902) FNAME
 150      FORMAT(A)
      IF (FNAME(1:1).EQ.' ') GO TO 100
      NFILES = NFILES + 1

C---- Search the line for a chain identifier
      CALL GETCHN(FNAME,CHAIN,IEND)
      BCODE = FNAME(1:4)

C---- Form name of PDB file
      FNAME = PDBPRE(1:LENSTR(PDBPRE)) // BCODE // RINEXT

C---- Print name of file
      PRINT 180, NFILES, FNAME
 180  FORMAT(1X,'File ',I3,'. ',A68)

C---- Open corresponding .rin file
      OPEN(UNIT=3,FILE=FNAME,STATUS='OLD',ACCESS='SEQUENTIAL',
CVAX     -     READONLY,
     -    FORM='FORMATTED',ERR=902)

C---- Peel off directory path and extension
C      CALL GETNAM(FNAME,ISTART,IEND,IFAIL)
      IF (IFAIL) GO TO 990

      GO TO 999

C---- End of gentors.lst file reached - no more .rin files to be read in
 800  CONTINUE
      ENDLST = .TRUE.
      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Data error reading gentors.lst file at line',
     -    NFILES + 1
      ENDLST = .TRUE.
      GO TO 990

 902  CONTINUE
      PRINT*, '*** Error opening .rin file.'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C     SUBROUTINE GETCHN  -  Search for a chain identifier after the filename.
C                           (Will be a single character enclosed in quotes)
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCHN(INLINE,CHAIN,IEND)

      SAVE

      CHARACTER*1   CHAIN, CQUOTE, DQUOTE, INCHAR, QUOTE
      CHARACTER*80  INLINE
      INTEGER       IEND, IFROM, IPOS, ISTATE, ITO

      DATA DQUOTE, QUOTE / '"', '''' /

C---- Initialise variables
      CHAIN = ' '
      IEND = 80
      ITO = IEND
      IPOS = 0

C---- Find where the file-name ends
 100  CONTINUE
      IPOS = IPOS + 1
      IF (INLINE(IPOS:IPOS).EQ.' ') THEN
          IEND = IPOS - 1
          GO TO 200
      ENDIF
      IF (IPOS.LT.IEND) GO TO 100

C---- No end to filename found, so no other details located
      GO TO 999

C---- End of filename located
 200  CONTINUE
      IFROM = IEND + 1

C---- Initialise variables
      ISTATE = 1
      IPOS = IFROM - 1

C---- Loop through remaining positions in the line for any chain identifier
 300  CONTINUE
          IPOS = IPOS + 1
          INCHAR = INLINE(IPOS:IPOS)

C----     State 1 - Searching for opening quote
          IF (ISTATE.EQ.1) THEN

C----         Check whether this is a quote
              IF (INCHAR.EQ.QUOTE .OR. INCHAR.EQ.DQUOTE) THEN
                  ISTATE = 2
                  CQUOTE = INCHAR

C----         Check whether this is the chain-id
              ELSE IF (INCHAR.NE.' ') THEN
                  CHAIN = INCHAR
                  ISTATE = 3
              ENDIF

C----     State 2 - Storing chain
          ELSE IF (ISTATE.EQ.2) THEN

C----         Check for closing quote
              IF (INCHAR.EQ.CQUOTE) THEN
                  ISTATE = 1

C----         Otherwise, store the character for the chain
              ELSE
                  CHAIN = INCHAR
              ENDIF
          ENDIF
      IF (IPOS.LT.ITO .AND. CHAIN.EQ.' ') GO TO 300

 999  CONTINUE
      RETURN
      END

C----------------------------------------------------------------------+---
C*****************************************************************************
C
C     SUBROUTINE GETNAM  -  Peel off the directory path and extension
C                           from the full name of the .pdb file
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETNAM(PDBFIL,ISTART,IEND,IERROR)

      CHARACTER*1   BSLASH, CLOSEB, OPENB, PCHAR, SLASH
      CHARACTER*80  PDBFIL
      INTEGER       IEND, IPOS, ISTART, ISTATE
      LOGICAL       FINISH, GOTDOT, IERROR

      OPENB = '['
      CLOSEB = ']'
      BSLASH = '\\'
      SLASH = '/'

C---- Initialise variables
      FINISH = .FALSE.
      IEND = 0
      IERROR = .FALSE.
      ISTART = 1
      ISTATE = 1
      IPOS = 78
      GOTDOT = .FALSE.

C---- Check through the filename from right to left
 100  CONTINUE

C----     Pick off next character
          PCHAR = PDBFIL(IPOS:IPOS)

C----     State 1: Searching for first non-blank character
          IF (ISTATE.EQ.1) THEN
              IF (PCHAR.EQ.SLASH .OR. PCHAR.EQ.BSLASH .OR.
     -            PCHAR.EQ.CLOSEB) THEN
                  GO TO 900
              ENDIF
              IF (PCHAR.NE.' ' .AND. PCHAR.NE.'.') THEN
                  IEND = IPOS
                  ISTATE = 2
              ENDIF

C----     State 2: Searching for end of extension, or end of directory path
          ELSE IF (ISTATE.EQ.2) THEN

C----         If character is a dot, and is the first dot, then note position
              IF (PCHAR.EQ.'.' .AND. .NOT.GOTDOT) THEN
                  IEND = IPOS - 1
                  GOTDOT = .TRUE.

C----         If character signifies the end of a directory path, note pstn
              ELSE IF (PCHAR.EQ.SLASH .OR. PCHAR.EQ.BSLASH
     -            .OR. PCHAR.EQ.CLOSEB) THEN
                  ISTART = IPOS + 1
                  FINISH = .TRUE.
              ENDIF
          ENDIF

C----     Step back a character
          IPOS = IPOS - 1

C---- Loop back for next character
      IF (.NOT.FINISH .AND. IPOS.GT.0) GO TO 100

C---- Check whether file name is sensible
      IF (ISTART.GT.IEND) GO TO 900

      GO TO 999

C---- Error in file name
 900  CONTINUE
      IEND = 40
      IF (PDBFIL(41:78).NE.' ') IEND = 78
      PRINT*,' *** ERROR in supplied name of file: [', PDBFIL(1:IEND),
     -    ']'
      IERROR = .TRUE.

 999  CONTINUE
      RETURN
      END

C----------------------------------------------------------------------+---
C**************************************************************************
C
C  SUBROUTINE READIN  -  Read in the data
C
C----------------------------------------------------------------------+---

      SUBROUTINE READIN(ARRAY,TARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      CHARACTER*1   INCHN, SECSTR
      CHARACTER*3   AMNAME(NAMINO), RESDUE
      CHARACTER*5   SEQNO
      INTEGER       IAMINO, ICELL, JCELL, NCELLS, IRESID, SERNO
      LOGICAL       FOUND, VALID
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1), CGAMB, CHI1, CHI2,
     -              CHI3, CHI4, ZETA, DISULF, ENHB, MCBVAL, OMEGA, PHI,
     -              PSI, SCBVAL, TARRAY(NCELL1,NCELL2), VALUE(2)

      DATA AMNAME /'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -             'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -             'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

C---- Initialise variables
      DO 50, IAMINO = 1, NAMINO
          AMINO(IAMINO) = AMNAME(IAMINO)
 50   CONTINUE
      IRESID = 0
      NCELLS = NCELL1 * NCELL2
      NRESID = 0

C---- Read through the residues file
 100  CONTINUE
          READ(3,110,END=500,ERR=902) SERNO, RESDUE, INCHN, SEQNO,
     -        SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4, ENHB,
     -        DISULF, ZETA, CGAMB, MCBVAL, SCBVAL
 110      FORMAT(I4,A3,1X,A1,A5,A1,11F7.2,2F7.3)
          IRESID = IRESID + 1

C----     Only process this residue if it belongs to the required chain
          IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN

C----         Chi-1 torsion angle
              IF (RESDUE.EQ.'PRO') CHI1 = 999.9
              IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
              IF (CHI1.EQ.360.0) CHI1 = 0.0

C----         Chi-2 torsion angle
              IF (CHI2.LE.0.0) CHI2 = CHI2 + 360.0
              IF (CHI2.EQ.360.0) CHI2 = 0.0

C----         Chi-3 torsion angle
              IF (CHI3.LE.0.0) CHI3 = CHI3 + 360.0
              IF (CHI3.EQ.360.0) CHI3 = 0.0

C----         Chi-4 torsion angle
              IF (CHI4.LE.0.0) CHI4 = CHI4 + 360.0
              IF (CHI4.EQ.360.0) CHI4 = 0.0

C----         Omega torsion angle
              IF (OMEGA.LE.0.0) OMEGA = OMEGA + 360.0
              IF (OMEGA.EQ.360.0) OMEGA = 0.0

C----         Zeta torsion angle
              IF (ZETA.LE.0.0) ZETA = ZETA + 360.0
              IF (ZETA.EQ.360.0) ZETA = 0.0

C----         Store required value(s)
              IF (DISTRB.EQ.1) THEN
                  VALUE(1) = PHI
                  VALUE(2) = PSI
              ELSE IF (DISTRB.EQ.2) THEN
                  VALUE(1) = CHI1
                  VALUE(2) = CHI2
              ELSE IF (DISTRB.EQ.3) THEN
                  VALUE(1) = CHI1
              ELSE IF (DISTRB.EQ.4) THEN
                  VALUE(1) = CHI3
              ELSE IF (DISTRB.EQ.5) THEN
                  VALUE(1) = CHI4
              ELSE IF (DISTRB.EQ.6) THEN
                  VALUE(1) = OMEGA
              ENDIF

C----         Determine in which cell the current pair of values falls
              ICELL = (VALUE(1) - VALBEG(1)) / STEP(1) + 1
              IF (TWODEE) THEN
                  JCELL = (VALUE(2) - VALBEG(2)) / STEP(2) + 1
              ELSE
                  IF (ICELL.LT.1 .OR. ICELL.GT.NCELLS) THEN
                      ICELL = 0
                      JCELL = 0
                  ELSE
                      JCELL = 1 + (ICELL - 1) / NCELL1
                      ICELL = ICELL - (JCELL - 1) * NCELL1
                  ENDIF
              ENDIF
              IF (ICELL.LT.1 .OR. ICELL.GT.NCELL1 .OR. JCELL.LT.1 .OR.
     -            JCELL.GT.NCELL2) THEN
                  VALID = .FALSE.
              ELSE
                  VALID = .TRUE.
              ENDIF

C----         If the value pair falls within the area of the plot, find
C             the amino acid type of this residue
              IF (VALID) THEN
                  IAMINO = 0
                  FOUND = .FALSE.
200               CONTINUE
                      IAMINO = IAMINO + 1
                      IF (RESDUE.EQ.AMINO(IAMINO)) THEN
                          FOUND = .TRUE.
                      ENDIF
                  IF (.NOT.FOUND .AND. IAMINO.LT.NAMINO) GO TO 200

C----             If have found a valid amino acid type, then increment
C                 counts for this cell
                  IF (FOUND) THEN

C----                 Increment count for this amino acid type
                      ARRAY(ICELL,JCELL,IAMINO)
     -                    = ARRAY(ICELL,JCELL,IAMINO) + 1.0
                      NCOUNT(IAMINO) = NCOUNT(IAMINO) + 1

C----                 Increment counts for all amino acid types
                      ARRAY(ICELL,JCELL,NAMINO+1)
     -                    = ARRAY(ICELL,JCELL,NAMINO+1) + 1.0
                      NCOUNT(NAMINO+1) = NCOUNT(NAMINO+1) + 1
                      TARRAY(ICELL,JCELL) = TARRAY(ICELL,JCELL) + 1.0
                      NRESID = NRESID + 1
                  ELSE
                      PRINT*, '  *** Invalid residue type', RESDUE
                  ENDIF
              ENDIF
          ENDIF

C---- Loop back for next record in file
      GO TO 100

C---- End of file reached
 500  CONTINUE
      TRESID = TRESID + NRESID

C---- Check that file wasn't empty
      IF (NRESID.EQ.0) GO TO 908

C---- Close the .rin file
      CLOSE(3)

      GO TO 999

C---- Fatal errors
900   CONTINUE
      PRINT*, '*** ERROR. Unable to open data file'
      GO TO 990

902   CONTINUE
      PRINT*, '*** ERROR. Data error in .rin file at line:', IRESID + 1
      GO TO 990

 908  CONTINUE
      PRINT*, '*** Warning. No data points point in .rin file.'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE COMPRS  -  Write out a compressed version of the distribution
C
C----------------------------------------------------------------------+---

      SUBROUTINE COMPRS(ARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      CHARACTER*1   CVALUE
      CHARACTER*10  CNUMB
      CHARACTER*20  NXTSEG
      CHARACTER*52  LETTER
      CHARACTER*80  IREC
      INTEGER       CLEFT, IAMINO, ICELL, IPOS, IPSTN, IVALUE, JCELL,
     -              LENSEG, N, NSPACE, NZERO
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1)

      DATA LETTER( 1:26) / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LETTER(27:52) / 'abcdefghijklmnopqrstuvwxyz'/

C---- Initialise values
      N = NCELL1 * NCELL2
      WRITE(7,10) DISTRB
 10   FORMAT('Distribution ',I1)

C---- Loop through the amino acids
      DO 500, IAMINO = 1, NAMINO

C----     If no observations for this amino acid, then skip
          IF (NCOUNT(IAMINO).NE.0) THEN

C----         Write out amino acid number
              WRITE(7,20) DISTRB, IAMINO, '   ', AMINO(IAMINO)
 20           FORMAT(I3,2X,I2,2A)

C----         Initialise output record
              IPOS = 0
              IPSTN = 0
              IREC = ' '
              IVALUE = NINT(ARRAY(1,1,IAMINO))
              NZERO = 0

C----         Loop through all the cells in the distribution
              DO 400, JCELL = 1, NCELL2
                  DO 300, ICELL = 1, NCELL1

C----                 Initialise values
                      IPSTN = IPSTN + 1
                      IVALUE = NINT(ARRAY(ICELL,JCELL,IAMINO))

C----                 If this value is a zero, increment count
                      IF (IVALUE.EQ.0) NZERO = NZERO + 1

C----                 If the value is non-zero, or this is the last
C                     cell in the array, then write out last value to
C                     compressed file
                      IF (IVALUE.NE.0 .OR. IPSTN.EQ.N) THEN

C----                     Initialise next segment to be written out
                          LENSEG = 0
                          NXTSEG = ' '

C----                     If any zeros to be written out, write their
C                         number out in digits
                          IF (NZERO.GT.0) THEN

C----                         Write out the number of occurrences
                              WRITE(CNUMB,30) NZERO
 30                           FORMAT(I10)

C----                         Count the number of blank spaces up to
C                             the first digit
                              NSPACE = 0
 80                           CONTINUE
                                  NSPACE = NSPACE + 1
                              IF (NSPACE.LT.10 .AND.
     -                            CNUMB(NSPACE:NSPACE).EQ.' ')
     -                                GO TO 80

C----                         Transfer number to next segment
                              NXTSEG(LENSEG+1:) = CNUMB(NSPACE:10)
                              LENSEG = LENSEG + 10 - NSPACE + 1

C----                         Reinitialise count of zeros
                              NZERO = 0
                          ENDIF

C----                     If the current value is non-zero then encode
                          IF (IVALUE.NE.0) THEN

C----                         If the value can't be written out encoded,
C                             then write out straight, preceeded by a hash
                              IF (IVALUE.GT.52) THEN

C----                             Write out the value to the segment
                                  WRITE(CNUMB,30) IVALUE

C----                             Count the number of blank spaces up to
C                                 the first digit
                                  NSPACE = 0
 140                              CONTINUE
                                      NSPACE = NSPACE + 1
                                  IF (NSPACE.LT.10 .AND.
     -                                CNUMB(NSPACE:NSPACE).EQ.' ')
     -                                GO TO 140

C----                             Transfer number to next segment
                                  NXTSEG(LENSEG+1:)
     -                                = '#' // CNUMB(NSPACE:10)
                                  LENSEG = LENSEG + 10 - NSPACE + 2

C----                         Otherwise, encode it as a single character
                              ELSE
                                  CVALUE = LETTER(IVALUE:IVALUE)
                                  LENSEG = LENSEG + 1
                                  NXTSEG(LENSEG:LENSEG) = CVALUE
                              ENDIF
                          ENDIF

C----                     If very last value, stick an asterisk on the end
                          IF (IPSTN.EQ.N) THEN
                              LENSEG = LENSEG + 1
                              NXTSEG(LENSEG:LENSEG) = '*'
                          ENDIF

C----                     Transfer next segment to output record,
C                         writing record out if full

C----                     Calculate how many characters left in current
C                         record
                          CLEFT = 80 - IPOS

C----                     If enough space to fit current segment, then
C                         do so
                          IF (CLEFT.GT.LENSEG) THEN
                              IREC(IPOS+1:IPOS+LENSEG) = NXTSEG
                              IPOS = IPOS + LENSEG

C----                     Otherwise, put as much as can into current
C                         record, and write out
                          ELSE
                              IREC(IPOS+1:80) = NXTSEG
                              WRITE(7,220) IREC
 220                          FORMAT(A)

C----                         Put remainder into next record
                              IREC = ' '
                              IPOS = 0
                              IF (CLEFT.LT.LENSEG) THEN
                                  IREC = NXTSEG(CLEFT+1:LENSEG)
                                  IPOS = LENSEG - CLEFT
                              ENDIF
                          ENDIF
                      ENDIF
 300              CONTINUE
 400          CONTINUE

C----         Write out last record for this residue, if not blank
              IF (IPOS.GT.0) THEN
                  WRITE(7,220) IREC(1:IPOS)
              ENDIF
          ENDIF
 500  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE ARROUT  -  Write out the log odds array
C
C----------------------------------------------------------------------+---

      SUBROUTINE ARROUT(ARRAY,IARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      INTEGER       IAMINO, IARRAY(NCELL1*NCELL2), ICELL, IPOS, JCELL,
     -              NCELLS
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1)

C---- Initialise variables
      NCELLS = NCELL1 * NCELL2

C---- Loop through the amino acids
      DO 500, IAMINO = 1, NAMINO

C----     If no observations for this amino acid, then skip
          IF (NCOUNT(IAMINO).NE.0) THEN

C----         Write out amino acid number
              WRITE(8,*) DISTRB, IAMINO, '   ', AMINO(IAMINO)

C----         Convert current array to set of integers
              IPOS = 0
              DO 200, JCELL = 1, NCELL2
                   DO 100, ICELL = 1, NCELL1
                      IPOS = IPOS + 1
C                      IARRAY(IPOS) = NINT((ARRAY(ICELL,JCELL,IAMINO)
C     -                    + 10.0) * 1000.0)
                      IARRAY(IPOS) = NINT(ARRAY(ICELL,JCELL,IAMINO))
 100              CONTINUE
 200          CONTINUE

C----         Write out the integer version of the array
              WRITE(8,260) (IARRAY(IPOS), IPOS = 1, NCELLS)
 260          FORMAT(36I4)
          ENDIF
 500  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLOT3D  -  Plot the distributions or energy values for each
C                        residue type
C
C----------------------------------------------------------------------+---

      SUBROUTINE PLOT3D(ARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      CHARACTER*7   PAGE
      CHARACTER*40  HEADIN, SUBHED
      INTEGER       IAMINO, ICELL, ICOL, IPAGE, IROW, JCELL, LENSTR,
     -              NACIDS
      REAL          ALLMAX, ALLMIN, ARRAY(NCELL1,NCELL2,NAMINO+1),
     -              PERCEN, XCENTR, XCORN1, XCORN2, YCORN1, YCORN2

C---- Initialise variables
      IF (DISTRB.EQ.1) THEN
          HEADIN = 'Ramachandran plots'
      ELSE IF (DISTRB.EQ.2) THEN
          HEADIN = 'Chi1-Chi2 plots'
      ELSE IF (DISTRB.EQ.7) THEN
          HEADIN = 'CA-angle vs CA torsion angle'
      ENDIF
      NACIDS = NAMINO + 1
      WRITE(SUBHED,20) NFILES
 20   FORMAT(I4,' protein chains')
      ICOL = 0
      IPAGE = 0
      IROW = 1
      XCENTR = (BBOXX1 + BBOXX2) / 2.0

C---- Determine the maximum and minimum values across all graphs
      ALLMAX = -999999.99
      ALLMIN = 999999.99
      PERMAX = -999999.99
      PERMIN = 999999.99
      DO 300, IAMINO = 1, NACIDS
          IF (NCOUNT(IAMINO).NE.0) THEN
              DO 200, JCELL = 1, NCELL2
                  DO 100, ICELL = 1, NCELL1
                      PERCEN = ARRAY(ICELL,JCELL,IAMINO)
     -                    * 100.0 / REAL(NCOUNT(IAMINO))
                      IF (IAMINO.EQ.NACIDS) THEN
                          ALLMIN = MIN(ALLMIN,PERCEN)
                          ALLMAX = MAX(ALLMAX,PERCEN)
                      ELSE
                          PERMIN = MIN(PERMIN,PERCEN)
                          PERMAX = MAX(PERMAX,PERCEN)
                      ENDIF
100               CONTINUE
200           CONTINUE
          ENDIF
300   CONTINUE

C---- Loop through all the amino acid types to be plotted
      DO 500, IAMINO = 1, NACIDS

C----     Skip any blank distributions
          IF (NCOUNT(IAMINO).GT.0) THEN

C----         If plotting distribution for all residues, adjust max and
C             mins
              IF (IAMINO.EQ.NACIDS) THEN
                  PERMIN = ALLMIN
                  PERMAX = ALLMAX
              ENDIF

C----         Increment column number on page (1-3) throwing new page if
C             necessary
              ICOL = ICOL + 1
              IF (ICOL.GT.3) THEN
                  IROW = IROW + 1
                  ICOL = 1
              ENDIF
              IF (IPAGE.EQ.0 .OR. IROW.GT.3) THEN

C----             If this is not the first page, then close current
C                 PostScript file
                  IF (IPAGE.GT.0) THEN
                      CALL PSCLOS
                  ENDIF

C----             Open PostScript file and print page-number
                  CALL PSNAME
                  CALL PSOPEN(FILPS)
                  IPAGE = IPAGE + 1
                  WRITE(PAGE,420) IPAGE
 420              FORMAT('Page ',I2)
                  CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)
                  IROW = 1

C----             Print graph headings
                  CALL PSCTXT(XCENTR,BBOXY2 - 40.0,25.0,
     -                HEADIN(1:LENSTR(HEADIN)))
                  CALL PSCTXT(XCENTR,BBOXY2 - 70.0,18.0,
     -                SUBHED(1:LENSTR(SUBHED)))
              ENDIF

C----         Initialise variables
              XCORN1 = XLEFT3 + (ICOL - 1) * (XWID3 + XSEP3)
              XCORN2 = XCORN1 + XWID3
              YCORN1 = YBOTT3 + (3 - IROW) * (YHIGH3 + YSEP3)
              YCORN2 = YCORN1 + YHIGH3

C----         Plot the current graph
              CALL PLTGRD(XCORN1,XCORN2,YCORN1,YCORN2,IAMINO,ICOL,ARRAY,
     -            NCELL1,NCELL2)
          ENDIF
 500  CONTINUE

C---- Close the current PostScript file
      CALL PSCLOS

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLTGRD  -  Plot graph boxes containing the actual, calculated
C                        and difference distributions
C
C----------------------------------------------------------------------+---

      SUBROUTINE PLTGRD(X1,X2,Y1,Y2,IAMINO,ICOL,ARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      CHARACTER*3   AMNAME(NAMINO+1)
      CHARACTER*16  XAXIS, YAXIS
      INTEGER       ICOL, IAMINO
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1), XCENTR, X1, X2,
     -              YCENTR, Y1, Y2

      DATA AMNAME /'Ala', 'Arg', 'Asn', 'Asp', 'Cys', 'Gln', 'Glu',
     -             'Gly', 'His', 'Ile', 'Leu', 'Lys', 'Met', 'Phe',
     -             'Pro', 'Ser', 'Thr', 'Trp', 'Tyr', 'Val', 'ALL' /

C---- Initialise variables
      XCENTR = (X1 + X2) / 2.0
      YCENTR = (Y1 + Y2) / 2.0
      IF (DISTRB.EQ.1) THEN
          XAXIS = 'Phi'
          YAXIS = 'Psi'
      ELSE IF (DISTRB.EQ.2) THEN
          XAXIS = 'Chi-1'
          YAXIS = 'Chi-2'
      ELSE IF (DISTRB.EQ.7) THEN
          XAXIS = 'CA angle'
          YAXIS = 'CA torsion angle'
      ENDIF

C---- Plot the distribution if not empty
      IF (NCOUNT(IAMINO).GT.0) THEN
          CALL PLTDIS(X1,X2,Y1,Y2,IAMINO,ARRAY,NCELL1,NCELL2)
      ENDIF

C---- Draw box round graph and label axes
      CALL AXES(X1,X2,Y1,Y2,NTICKX,NTICKY,VALBEG(1),VALEND(1),
     -    VALBEG(2),VALEND(2),10.0,0,0,15.0)

C---- Graph heading and x-axis title
      CALL PSCTXT(XCENTR,Y2 + YTITGP,15.0,AMNAME(IAMINO))
      CALL PSCTXT(XCENTR,Y1 - 20.0,12.0,XAXIS)

C---- y-axis title
      IF (ICOL.EQ.1) CALL PSRTXT(X1 - 35.0,YCENTR,12.0,YAXIS)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLTDIS  -  Plot the distribution as different-shaded regions
C
C----------------------------------------------------------------------+---

      SUBROUTINE PLTDIS(XCORN1,XCORN2,YCORN1,YCORN2,IAMINO,ARRAY,NCELL1,
     -    NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      INTEGER       IAMINO, ICELL, JCELL
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1), PERCEN, SHADE,
     -              SHAFAC, SHLIM, X, XCORN1, XCORN2, XGAP, XLEFT, Y,
     -              YCORN1, YCORN2, YGAP, YLEFT

      DATA SHLIM / 0.0 /

C---- Initialise variables for shading
      XGAP = (XCORN2 - XCORN1) / NCELL1
      YGAP = (YCORN2 - YCORN1) / NCELL2
      SHAFAC = 1.0 / (PERMAX - PERMIN)

C---- Loop through all the cells in this graph
      CALL PSLWID(0.0)
      Y = YCORN1
      DO 300, JCELL = 1, NCELL2
          XLEFT = XCORN1
          X = XLEFT + XGAP
          YLEFT = Y
          DO 200, ICELL = 1, NCELL1

C----         Determine the shade to be plotted
              IF (NCOUNT(IAMINO).NE.0) THEN
                  PERCEN = 100.0 * ARRAY(ICELL,JCELL,IAMINO)
     -                / REAL(NCOUNT(IAMINO))
                  SHADE = 1.0 - SHAFAC * (PERCEN - PERMIN)
                  IF (SHADE.LT.0.0) SHADE = 0.0
                  IF (SHADE.GT.1.0) SHADE = 1.0
              ELSE
                  SHADE = 0.0
              ENDIF

C----         Write out the appropriate shade
              IF (SHADE.NE.1.0) THEN
                  CALL PSHADE(SHADE)
                  CALL PSUBOX(XLEFT, Y, X, Y, X, Y + YGAP, XLEFT,
     -                Y + YGAP)
              ENDIF

C----         If plotting energy differences, draw line where the zero
C             level occurs
COUT                  IF (ICELL.GT.1) THEN
COUT                      STEST = ARRAY(ICELL,JCELL,IAMINO)
COUT     -                    * ARRAY(ICELL - 1,JCELL,IAMINO)
COUT                      IF (STEST.LT.0.0) THEN
COUT                          CALL PSLWID(0.1)
COUT                          CALL PSLINE(XLEFT,Y,XLEFT,Y + YGAP)
COUT                          CALL PSLWID(0.0)
COUT                      ENDIF
COUT                  ENDIF
COUT                  IF (JCELL.GT.1) THEN
COUT                      STEST = ARRAY(ICELL,JCELL,IAMINO)
COUT     -                    * ARRAY(ICELL,JCELL - 1,IAMINO)
COUT                      IF (STEST.LT.0.0) THEN
COUT                          CALL PSLWID(0.1)
COUT                          CALL PSLINE(XLEFT,Y,X,Y)
COUT                          CALL PSLWID(0.0)
COUT                      ENDIF
COUT                  ENDIF

C----         Increment x-value
              XLEFT = X
              X = X + XGAP
 200      CONTINUE

C----     Increment y-value
          Y = Y + YGAP
 300  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE AXES  -  Draw graph axes and axis-labels, writing out to
C                      PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE AXES(XLIM1,XLIM2,YLIM1,YLIM2,NPTSX,NPTSY,XMIN,XMAX,
     -    YMIN,YMAX,SIZLAB,INTRLX,INTRLY,TSIZE)

      CHARACTER*5    LABEL
      INTEGER        IFROM, IMARK, INTRLX, INTRLY, IVALUE, NPTSX, NPTSY
      REAL           SIZLAB, TSIZE, UGAP, VALUE, VGAP, X, XCENTR, XGAP,
     -               XLIM1, XLIM2, XMAX, XMIN, Y, YCENTR, YGAP, YLIM1,
     -               YLIM2, YMAX, YMIN

C---- Initialise variables
      XGAP = (XLIM2 - XLIM1) / NPTSX
      YGAP = (YLIM2 - YLIM1) / NPTSY
      UGAP = (XMAX - XMIN) / NPTSX
      VGAP = (YMAX - YMIN) / NPTSY
      XCENTR = (XLIM1 + XLIM2) / 2.0
      YCENTR = (YLIM1 + YLIM2) / 2.0

C---- Draw box round graph
      CALL PSLWID(0.6)
      CALL PSLINE(XLIM1,YLIM1,XLIM1,YLIM2)
      CALL PSLINE(XLIM1,YLIM2,XLIM2,YLIM2)
      CALL PSLINE(XLIM2,YLIM2,XLIM2,YLIM1)
      CALL PSLINE(XLIM2,YLIM1,XLIM1,YLIM1)

C---- x-axis point markers and labels
      X = XLIM1
      Y = YLIM1 - TSIZE / 2.0
      DO 100, IMARK = 1, NPTSX + 1
          VALUE = XMIN + (IMARK - 1) * UGAP
          IF (VALUE.GE.0.0) THEN
              IVALUE = VALUE + 0.5
          ELSE
              IVALUE = VALUE - 0.5
          ENDIF
          IF (INTRLX.EQ.0) THEN
              WRITE(LABEL,60) IVALUE
 60           FORMAT(I5)
          ELSE
              WRITE(LABEL,80) VALUE
 80           FORMAT(F5.1)
          ENDIF
          IFROM = 1
          IF (LABEL(1:1).EQ.' ') IFROM = 2
          IF (LABEL(2:2).EQ.' ') IFROM = 3
          IF (LABEL(3:3).EQ.' ') IFROM = 4
          IF (LABEL(4:4).EQ.' ') IFROM = 5
          CALL PSCTXT(X,Y,SIZLAB,LABEL(IFROM:5))
          CALL PSLINE(X,YLIM1,X,YLIM1 - SIZLAB / 3.0)
          X = X + XGAP
 100  CONTINUE

C---- y-axis point markers and labels
      X = XLIM1 - TSIZE
      Y = YLIM1
      DO 200, IMARK = 1, NPTSY + 1
          VALUE = YMIN + (IMARK - 1) * VGAP
          IF (VALUE.GE.0.0) THEN
              IVALUE = VALUE + 0.5
          ELSE
              IVALUE = VALUE - 0.5
          ENDIF
          IF (INTRLY.EQ.0) THEN
              WRITE(LABEL,60) IVALUE
          ELSE
              WRITE(LABEL,80) VALUE
          ENDIF
          IFROM = 1
          CALL PSCTXT(X,Y,SIZLAB,LABEL(1:5))
          CALL PSLINE(XLIM1 - SIZLAB / 3.0,Y,XLIM1,Y)
          Y = Y + YGAP
 200  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE MDCOMP  -  Calculate the similarity between each pair of
C                        distributions, and write out for multi-dimensional
C                        scaling by program princip.f
C
C----------------------------------------------------------------------+---

      SUBROUTINE MDCOMP(ARRAY,NCELL1,NCELL2)

      INCLUDE 'gentors.inc'

      INTEGER       NCELL1, NCELL2

      INTEGER       IAMINO, ICELL, ICOL, IFREE, INDX(NAMINO), IROW,
     -              JAMINO, JCELL, NPOS
      REAL          ARRAY(NCELL1,NCELL2,NAMINO+1), CALC,
     -              MDMAT(NAMINO,NAMINO), SCORE

C---- Initialise MDMAT contents to zero
      DO 30, JAMINO = 1, NAMINO
          INDX(JAMINO) = JAMINO
          DO 20, IAMINO = 1, NAMINO
              MDMAT(IAMINO,JAMINO) = 0.0
20        CONTINUE
30    CONTINUE

C---- Loop through all pairs of amino acids and compare their distributions
C     to obtain a similarity score between each one
      DO 500, JAMINO = 1, NAMINO
          DO 400, IAMINO = JAMINO + 1, NAMINO

C----         Process only if distribution not empty
              IF (NCOUNT(IAMINO).GT.0 .AND. NCOUNT(JAMINO).GT.0) THEN

C----             Initialise score to zero
                  SCORE = 0.0

C----             Loop through all the cells in the distribution
                  DO 300, JCELL = 1, NCELL2
                      DO 200, ICELL = 1, NCELL1
                          CALC = ARRAY(ICELL,JCELL,IAMINO)
     -                        - ARRAY(ICELL,JCELL,JAMINO)
                          SCORE = SCORE + CALC * CALC
 200                  CONTINUE
 300              CONTINUE

C----             Update MDMAT
                  MDMAT(IAMINO,JAMINO) = SCORE
                  MDMAT(JAMINO,IAMINO) = SCORE

C----         Otherwise, if either distribution is empty, set similarity
C             score to -9.0
              ELSE
                  MDMAT(IAMINO,JAMINO) = -9.0
                  MDMAT(JAMINO,IAMINO) = -9.0
              ENDIF
 400      CONTINUE
 500  CONTINUE

C---- Close MDMAT up to remove any residues with no distribution
      IFREE = 1
      NPOS = NAMINO
      DO 800, IAMINO = 2, NAMINO

C----     If previous residue OK, then increment next free position
          IF (NCOUNT(IAMINO - 1).GT.0) THEN
              IFREE = IFREE + 1
          ELSE
              NPOS = NPOS - 1
          ENDIF

C---- If need to perform the shuffling, then do it
          IF (IFREE.LT.IAMINO) THEN

C----         Shuffle up the current column
              DO 600, IROW = 1, NAMINO
                  MDMAT(IFREE,IROW) = MDMAT(IAMINO,IROW)
 600          CONTINUE

C----         Shuffle up the current row
              DO 700, ICOL = 1, NAMINO
                  MDMAT(ICOL,IFREE) = MDMAT(ICOL,IAMINO)
 700          CONTINUE
          ENDIF
 800  CONTINUE

C---- If the last residue is blank, then reduce the number of positions
C     to be written out
      IF (NCOUNT(NAMINO).EQ.0) NPOS = NPOS - 1

C---- Write out MDMAT
C      WRITE(15,*) NPOS
C      DO 950, JAMINO = 1, NPOS
C          WRITE(15,*) (MDMAT(IAMINO,JAMINO), IAMINO = 1, NPOS)
C 950  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSNAME  -  Determine file name for next PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSNAME

      INCLUDE 'gentors.inc'

      SAVE

      CHARACTER*2    CPLOT
      INTEGER        IPLOT

      DATA  IPLOT / 0 /

C---- Increment plot-number
      IPLOT = IPLOT + 1
      IF (IPLOT.GT.99) IPLOT = IPLOT - 100
      WRITE(CPLOT,100) IPLOT
 100  FORMAT(I2)
      IF (CPLOT(1:1).EQ.' ') CPLOT(1:1) = '0'

C---- Form plot filename
      FILPS = 'gentors.d' // CPLOT
      PRINT*
      PRINT*, 'Writing plotfile: ', FILPS(1:11)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSOPEN  -  Open PostScript file and write out header records
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSOPEN(FNAME)

      INCLUDE 'gentors.inc'

      CHARACTER*(*)  FNAME

C---- Open output file
      OPEN(UNIT=11, FILE=FNAME, STATUS='UNKNOWN',
     -     FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST',
     -     ERR=900)

C---- Write out headings to PostScript file
      WRITE(11,100)
 100  FORMAT(
     -    '%!PS-Adobe-3.0',/,
     -    '%%Creator: Procheck',/,
     -    '%%DocumentNeededResources: font Times-Roman Symbol',/,
     -    '%%BoundingBox: (atend)',/,
     -    '%%Pages: 1',/,
     -    '%%EndComments',/,
     -    '%%BeginProlog')
      WRITE(11,200)
 200  FORMAT(
     -    '/L { moveto lineto stroke } bind def',/,
     -    '/Poly3 { moveto lineto lineto fill grestore } bind ',
     -    'def',/,
     -    '/Pl3 { 6 copy Poly3 moveto moveto moveto closepath ',
     -    'stroke } bind def',/,
     -    '/Pline3 { 6 copy Poly3 moveto lineto lineto closepa',
     -    'th stroke } bind def')
      WRITE(11,250)
 250  FORMAT(
     -    '/Poly4 { moveto lineto lineto lineto fill grestore } bind ',
     -    'def',/,
     -    '/Pl4 { 8 copy Poly4 moveto moveto moveto moveto closepath ',
     -    'stroke } bind def',/,
     -    '/Pline4 { 8 copy Poly4 moveto lineto lineto lineto closepa',
     -    'th stroke } bind def')
      WRITE(11,300)
 300  FORMAT(
     -    '/Print { /Times-Roman findfont exch scalefont setfont show',
     -    ' } bind def',/,
     -    '/Gprint { /Symbol findfont exch scalefont setfont show } b',
     -    'ind def',/,
     -    '/Center {',/,
     -    '  dup /Times-Roman findfont exch scalefont setfont',/,
     -    '  exch stringwidth pop -2 div exch -3 div rmoveto',/,
     -    ' } bind def',/,
     -    '/CenterRot90 {',/,
     -    '  dup /Times-Roman findfont exch scalefont setfont',/,
     -    '  exch stringwidth pop -2 div exch 3 div exch rmoveto',/,
     -    ' } bind def',/,
     -    '/Rot90 { gsave currentpoint translate 90 rotate } bind def',/,
     -    '%%EndProlog')
      WRITE(11,400)
 400  FORMAT(
     -    '%%BeginSetup',/,
     -    '1 setlinecap 1 setlinejoin 1 setlinewidth 0 setgray [ ] 0 ',
     -    'setdash newpath',/,
     -    '%%EndSetup',/,
     -    '%%Page: 1 1 ')
      WRITE(11,500) REAL(BBOXX1), REAL(BBOXY1), REAL(BBOXX2),
     -     REAL(BBOXY1), REAL(BBOXX2), REAL(BBOXY2), REAL(BBOXX1),
     -     REAL(BBOXY2)
 500  FORMAT(
     -    '/ProcheckSave save def',/,
     -    2F6.2,' moveto',3(2F7.2,' lineto'),/,
     -    ' closepath gsave',/,
     -    'gsave 1.0000 setgray fill grestore',/,
     -    'clip newpath')


      GO TO 999

C---- Errors on parameter file
 900  CONTINUE
      PRINT*, 'WARNING. Unable to open Postscript file'
      GO TO 999

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSBBOX  -  Write out bounded box to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSBBOX(X1,Y1,X2,Y2,X3,Y3,X4,Y4)

      REAL          X1, X2, Y1, Y2, X3, Y3, X4, Y4

      WRITE(11,100) X1, Y1, X2, Y2, X3, Y3, X4, Y4
 100  FORMAT(8F7.2,' Pline4')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSCTXT  -  Write out centred text to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSCTXT(X,Y,SIZE,TEXT)

      CHARACTER*(*) TEXT
      REAL          SIZE, X, Y

      WRITE(11,100) X, Y
 100  FORMAT(2F7.2,' moveto')
      WRITE(11,200) TEXT, SIZE
 200  FORMAT('(',A,') ',F4.1,' Center')
      WRITE(11,300) TEXT, SIZE
 300  FORMAT('(',A,') ',F4.1,' Print')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSLINE  -  Write line out to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSLINE(X1,Y1,X2,Y2)

      REAL          X1, X2, Y1, Y2

      WRITE(11,100) X1, Y1, X2, Y2
 100  FORMAT(4F7.2,' L')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSLWID  -  Write line-width out to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSLWID(LWIDTH)

      REAL          LWIDTH

      WRITE(11,100) LWIDTH
 100  FORMAT(F5.2,' setlinewidth')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSRTXT  -  Write out text rotated through 90 degrees to
C                        PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSRTXT(X,Y,SIZE,TEXT)

      CHARACTER*(*) TEXT
      REAL          SIZE, X, Y

      WRITE(11,100) X, Y
 100  FORMAT(2F7.2,' moveto')
      WRITE(11,200) TEXT, SIZE
 200  FORMAT('(',A,') ',F4.1,' CenterRot90 Rot90')
      WRITE(11,300) TEXT, SIZE
 300  FORMAT('(',A,') ',F4.1,' Print')
      WRITE(11,400)
 400  FORMAT('grestore')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSHADE  -  Write shading level out to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSHADE(SHADE)

      REAL          SHADE

      WRITE(11,100) SHADE
 100  FORMAT('gsave',F7.4,' setgray')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSTEXT  -  Write out text to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSTEXT(X,Y,SIZE,TEXT)

      CHARACTER*(*) TEXT
      REAL          SIZE, X, Y

      WRITE(11,100) X, Y - SIZE / 4.0
 100  FORMAT(2F7.2,' moveto')
      WRITE(11,300) TEXT, SIZE
 300  FORMAT('(',A,') ',F4.1,' Print')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSUBOX  -  Write out unbounded box to PostScript file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSUBOX(X1,Y1,X2,Y2,X3,Y3,X4,Y4)

      REAL          X1, X2, Y1, Y2, X3, Y3, X4, Y4

      WRITE(11,100) X1, Y1, X2, Y2, X3, Y3, X4, Y4
 100  FORMAT(8F7.2,' Pl4')

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSCLOS  -  Write final lines to PostScript file and close
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSCLOS

      INCLUDE 'gentors.inc'


C---- Write out closing lines to PostScript file
      WRITE(11,100) BBOXX1 - 1, BBOXY1 - 1, BBOXX2 + 1, BBOXY2 + 1
 100  FORMAT(
     -    'grestore stroke',/,
     -    'ProcheckSave restore',/,
     -    'showpage',/,
     -    '%%Trailer',/,
     -    '%%BoundingBox:',4I4,/,
     -    '%%EOF')


C---- Close the file
      CLOSE(11)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  FUNCTION LENSTR  -  Return length of string 'CHARS' excluding
C                      trailing blanks
C
C----------------------------------------------------------------------+---

      INTEGER FUNCTION LENSTR(CHARS)

      CHARACTER*(*) CHARS
      INTEGER J, MVAL

      MVAL = LEN(CHARS)
      DO 10, J = MVAL, 1, -1
          IF (CHARS(J:J).NE.' ') GO TO 20
   10 CONTINUE
      J = 0
   20 CONTINUE
      LENSTR = J

      RETURN
      END

C--------------------------------------------------------------------------
