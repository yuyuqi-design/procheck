C**************************************************************************
C
C  MPLOT.FOR  -  Multiple-structure version of pplot.f. Program reads in the
C                stereochemical data generated by secstr.f and stored in .rin
C                files - one for each structure of the ensemble.
C                The list of .rin files to be included is stored in
C                a file called mplot.in.
C
C     Written by Roman Laskowski, University College, London, October 1992.
C
C     Original version was part of v.3.2 of the PROCHECK suite of programs.
C     
C     Subsequent amendments will be labelled by CHECK v.m.n--> and
C     CHECK v.m.n<-- where m.n is the version number corresponding to the
C     change
C     
C  v.3.2   - Minor bug-fix. Counter NSCORE in routine FRGFRQ defined
C            as a LOGICAL rather than as an INTEGER, causing the
C            residue G-factors to be wildly wrong on some compilers(!).
C            Addition of identifying plot handle to each plot filename.
C            Addition of descriptive plot title to header of PostScript
C            file.
C            Addition of option to print plot filename on the plot itself.
C            Chain ID made case-insensitive.
C            Correction of cis-peptide definition wherein a residue is
C            defined as cis if the omega dihedral angle associated with
C            the PREVIOUS residue is near zero.
C            New plot added: plot of G-factors by model, shown in
C            decreasing order of overall G.
C            Routines to read in residue RMS deviations calculated by
C            program RMSDEV. Third main plot removed from Residue properties
C            plot to leave more room for the other data.
C                                     Roman Laskowski (22 Apr-3 May 1994)
C            Routines to read in restraint data on each residue.
C                                        Roman Laskowski (16-17 May 1994)
C            Option to combine pages 1, 2, 3, ... of each plot into the
C            same PostScript file, rather than have separate files.
C            Separation of NMR plot parameters into a separate parameter
C            file called procheck_nmr.prm.
C            Removal of some of the quality plots, and placement of
C            remainder onto a single page.
C            Amendments to pick up latest PostScript file number as
C            dropped by previous plot program.
C                                        Roman Laskowski (11-14 Oct 1994)
C            Minor bug-fixes in accessibility-shading and GETRMS routines.
C            Calculation of chi-2 torsion angles wrong.
C                                            Roman Laskowski (1 Nov 1994)
C            Print of model-numbers for ensembles.
C                                              Roman Laskowski (3 Nov 1994)
C            Addition of PROCHECK-COMP heading for plots when the
C            ensemble version is run, and use of procheck_comp.prm
C            parameter file.
C                                             Roman Laskowski (10 Nov 1994)
C            Additional code to enable the model-by-model secondary
C            structure plots to cope with different residue types at each
C            residue position in each model.
C            Output of data to ensemble data file (.edt)
C                                          Roman Laskowski (21-23 Nov 1994)
C  v.3.2.1 - Change to RMS deviations heading for case where there are
C            only 2 models, in which case the RMS differences between
C            the two structures are computed, rather than the RMS
C            differences from the mean coordinates.
C                                             Roman Laskowski (30 Nov 1994)
C  v.3.3   - New option for the frequency distribution plots: allowing only
C            those residues having a large circular variance to be plotted.
C                                             Roman Laskowski (13 Feb 1995)
C  v.3.3.1 - Bug fix. Value of OOIMAX applied only to the last file of the
C            ensemble, so accessibility calcs incorrect for any average
C            OOI value that exceeded this. Fixed by only zeroing OOIMAX at
C            start of program and not before each file.
C                                             Roman Laskowski (18 May 1995)
C  v.3.3.3 - Bug fix. Negative chi1 and chi2 values were being omitted
C            from the frequency plots (pointed out by Werner Klaus).
C                                             Roman Laskowski (16 Oct 1995)
C  v.3.4   - Amendment of check for parameter file version (to v.3.4).
C                                              Roman Laskowski (12 Feb 1996)
C            Addition of range-selection allowing outputs to be limited
C            for certain models and certain ranges of residue-numbers.
C            Amendments of plot headings where model- or residue-ranges
C            apply.
C            Amendments to comply with new AQUA output file format.
C            Split into two separate programs: mplot.f and vplot.f, the
C            latter having all routines involving distance restraints and
C            their violations, and the former holding only the plots dealing
C            solely with protein geometry and torsion angle restraints.
C                                           Roman Laskowski (25-26 Mar 1996)
C            Transfer of routines to ps.f:- PINRNO, PINTIC, and DHELIX
C                                              Roman Laskowski (10 Apr 1996)
C            Addition of routine PUTPSN to update the ps.number file with
C            the last-used PostScript file number, for use by the new vplot
C            program.
C                                              Roman Laskowski (12 Apr 1996)
C            Amendments to take into account changes to output format of
C            the .tor file.
C            Bug-fixes on torsion angle restraint ranges.
C                                           Roman Laskowski (22-23 Apr 1996)
C            Bug-fix on accessibility-shading when in colour.
C            Bug-fix to show shaded bands for extents of chi-2 torsion angle
C            restraints.
C            Increase of number of colours that can be user-defined.
C                                              Roman Laskowski (24 Apr 1996)
C            Bug-fixes suggested by Dave Love.
C            Additional option to switch off circular variance dials and
C            G-factors boxes on dihedral angle distribution plots (asked for
C            by Markus Bluemel).
C                                              Roman Laskowski (26 Apr 1996)
C            Colouring of histogram bars and data points on
C            residue-by-residue Ramachandrans according to G-factor.
C                                              Roman Laskowski (30 Apr 1996)
C  v.3.4.1 - Bug-fix for black-and-white version of residue-by-residue
C            Ramachandran plots where squares were filled in black.
C                                              Roman Laskowski ( 1 May 1996)
C  v.3.4.2 - Bug-fix for reading in of PROCHECK-COMP parameter file
C            (spotted by Alexandre Bonvin).
C                                              Roman Laskowski ( 2 May 1996)
C
C  v.3.4.3 - Transfer of GETDAT routine to ps.f.
C                                              Roman Laskowski (22 May 1996)
C            Smearing of the G-factor distributions prior to use.
C                                           Roman Laskowski (22-23 May 1996)
C            Amendment of dihedral G-factor calculation to bring in line with
C            averaging method used in tplot.f. Calculation of all the
C            torsion-angle G-factors.
C                                              Roman Laskowski (29 May 1996)
C            New option on the dihedral angle frequency distributions to
C            splay out the model-numbers on the plot so that can easily
C            identify where on the plot each model's datapoint lies.
C                                              Roman Laskowski ( 1 Aug 1996)
C            Bug-fix on Model secondary structures plot where selection of
C            model-ranges gave only some of the models.
C                                              Roman Laskowski ( 7 Aug 1996)
C            Correction to text on plot when CVCUT cutoff used. Spotted by
C            Alan Roseman.
C                                              Roman Laskowski (20 Aug 1996)
C
C  v.3.4.4 - Bug-fix on overall G-factor in NMR version introduced in v.3.4.3
C            and spotted by Ton Rullmann.
C                                              Roman Laskowski (30 Oct 1996)
C  v.3.5.1 - Increase of MXRES from 1000 residues to 5000.
C                                              Roman Laskowski ( 2 Mar 1998)
C  v.3.5.2 - Extra parameter to call to GETDAT (required elsewhere).
C                                              Roman Laskowski (20 May 1999)
C            Generalisation of arrays holding the torsion angle distributions
C            to allow addition of other data.
C                                              Roman Laskowski (27 May 1999)
C  v.3.5.3 - Modification to array-size of PINSST in routines SSPLOT and
C            ACCSHD which were giving compiler warnings under some
C            compilers.
C                                              Roman Laskowski (18 Jan 2001)
C
C  v.3.5.5 - Bug-fix pointed out by Jeff Saxe.
C                                              Roman Laskowski (25 Apr 2001)
C  v.3.6     Implementation of new Ramachandran regions.
C                                              Roman Laskowski (18 Dec 2012)
C  v.3.6.4   Changes to GETNAM in ps.f to recognize full path in Win-64
C            version.
C            Increase in filename lengths to 512 characters.
C                                              Roman Laskowski ( 8 Aug 2013)
C
C--------------------------------------------------------------------------
C
C Compiling under g77:-
C
C f77 -Wimplicit -fbounds-check -c mplot.f
C f77 -Wimplicit -fbounds-check -c ps.f
C f77 -o mplot mplot.o ps.o
C
C Compilation and linking (on unix)
C -----------------------
C
C f77 -u -c mplot.f
C f77 -u -c ps.f
C f77 -o mplot mplot.o ps.o
C
C Compilation and linking (on VAX VMS)
C -----------------------
C
C FORT MPLOT
C FORT PS
C LINK MPLOT, PS
C
C--------------------------------------------------------------------------
C     
C  Files
C  -----
C     
C  2  mplot.in       - File containing the list of .rin files to be processed
C                      Each line of the file contains the filename and
C                      optional additional information on how the point
C                      is to be plotted. If the first character of the
C                      line is blank it is ignored. The additional
C                      information can include:
C                         A - Average structure
C                         E - Energy-minimized structure
C                         * - Marked structure (eg on which plot
C                             statistics are to be based
C                         Marker type:  Mn    where n = 1,2,...,9
C                             1-3=square, 4-6=triangle, 7-9=diamond
C                             where first is solid, second shaded, and
C                             third is blank for each type
C                         Label, enclosed in quotes (eg '1axc'), to be
C                             printed above the point
C                         X-value for the point, given as a real number
C                             (eg  15.0). Useful if the points are from
C                             different refinement cycles of the same
C                             protein, the x-value gives the cycle no.
C  3  prodata        - File holding the torsion angle distributions for
C                      phi-psi and chi1-chi2 combinations. Data generated
C                      by program gentors from a given database of high
C                      resolution protein structures.
C  4  <filename>.rin - Individual .rin files generated by program secstr.f,
C                      containing the secondary structure information and
C                      all the required torsion angles
C  8  <filename>.rms - Input file holding the residue-by-residue RMS
C                      deviations for each model and for the ensemble
C                      as a whole. File is created by the rmsdev.f
C                      program.
C 10  procheck_nmr.prm - Input parameter file containing user-defined
C                      options governing the plots produced. For ensembles,
C                      file is called procheck_comp.prm
C 11  <outname>.dnn  - Output PostScript files, numbered nn = 01, 02, ...
C 12  <filename>.tor - Dihedral angle restraints output by AQUA
C 13  <filename>.edt - Output file of calculated residue-by-residue data,
C                      including circular variances, G-factors, etc.
C 16  <user-defined> - Optional input file holding the model- and residue-
C                      number ranges to be included in the plots.
C
C--------------------------------------------------------------------------
C     
C     Subroutine calling tree
C     -----------------------
C     
C     MAIN    --> INITS
C             --> GETOUT  --> GETNAM
C             --> PARAMS  --> FINKEY
C                         --> GETCOL
C             --> GETPSN
C             --> GETFIL  --> GETNOD  --> READCH
C                         --> GETNAM
C             --> GETRNG  --> GETOKN
C                         --> INTOKN  --> LENSTR
C                         --> DELTOK
C                         --> STOTOK
C                         --> PRNRNG
C             --> GETWNT  --> INMODL
C             --> GETVAL  --> GETRIN  --> INRANG  --> LENSTR
C                                     --> MEANS   --> RAMREG / RAMNEW
C                                     --> CALCS
C                                     --> STDEVS
C                                     --> SCALCS
C             --> OPNFIL
C             --> OPNOUT
C             --> GETRMS
C             --> GETORS  --> CVIOL
C             --> GETDAT
C             --> CALCRG  --> CALC1D
C                         --> CALC2D
C             --> GETMAX
C
C                 Plot the residue-by-residue frequency distributions
C             --> FRQPLT  --> FILKEY  --> PSTEXT
C                                     --> PSLWID
C                                     --> PSHADE
C                                     --> PSBBOX
C                                     --> PSCTXT
C                         --> FRQEND  --> PSCTXT
C                                     --> PSRCTX
C                                     --> PSTEXT
C                                     --> ACDIAL  --> PSLINE
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSPCIR
C                                                 --> PSCIRC
C                                     --> PSCOLB
C                                     --> PSCSHD
C                                     --> PSCIRC
C                                     --> PSENDP
C                                     --> PSCLOS
C                         --> FRQHED  --> PSNAME
C                                     --> PSOPEN
C                                     --> PSPAGE
C                                     --> PSLWID
C                                     --> PSCTXT
C                                     --> PSTEXT
C                         --> PSLWID
C                         --> PSDASH
C                         --> PSLINE
C                         --> PSHADE
C                         --> PSBBOX
C                         --> PSUBOX
C                         --> AXES    --> PSLWID
C                                     --> PSLINE
C                                     --> PSCTXT
C                         --> RAMLIN  --> PSLWID
C                                     --> PSDASH
C                                     --> RAMREG / RAMNEW
C                                     --> PSLINE
C                         --> FRQGRF  --> FRQDOT  --> PSLWID
C                                                 --> PSCOLB
C                                                 --> PSHADE
C                                                 --> PSCALE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                     --> FRQBAR  --> PSLWID
C                                                 --> PSCOLB
C                                                 --> PSCALE
C                                                 --> PSBBOX
C                                                 --> PSLINE
C                                     --> FRQPRG  --> PSLWID
C                                                 --> PSCOLB
C                                                 --> PSCALE
C                                                 --> PSBBOX
C                                                 --> PSLINE
C                                     --> PSCSHD
C                                     --> PSCIRC
C                                     --> PSTEXT
C                                     --> CTVIOL
C                                     --> PSCOLB
C                                     --> PSCTXT
C                                     --> PSLINE
C                                     --> PSLWID
C                                     --> PSPCIR
C                                     --> PSCALE
C                                     --> PSBBOX
C                                     --> ACDIAL  --> (as above)
C             --> CALCG
C
C                 Plot the residue-by-residue geometry graphs
C             --> PINS    --> PSENDP
C                         --> PSCLOS
C                         --> PINPLT  --> PSNAME
C                                     --> PSOPEN
C                                     --> PSPAGE
C                                     --> PSLWID
C                                     --> PSCTXT
C                                     --> PINGRF  --> PSHADE
C                                                 --> PSUBOX
C                                                 --> AXES    --> (as above)
C                                                 --> PSCTXT
C                                                 --> PSRCTX
C                                     --> PINRNO  --> PSCTXT
C                                                 --> PSLINE
C                                     --> PINPTS  --> PSLWID
C                                                 --> PSDASH
C                                                 --> PSOCIR
C                                                 --> PSCTXT
C                                     --> PSTEXT
C                                     --> DVPLOT  --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                     --> PINTIC  --> PSLWID
C                                                 --> PSLINE
C                                     --> ACCSHD  --> PSCALE
C                                                 --> PSUBOX
C                                     --> SSPLOT  --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSUBOX
C                                                 --> PSUTRI
C                                                 --> DHELIX  --> PSHADE
C                                                             --> PSUBOX
C                                                             --> PSLWID
C                                     --> ACDIAL  --> (as above)
C                                     --> PINACD  --> ACDIAL  --> (as above)
C                                     --> PSCSHD
C                                     --> PSCIRC
C                                     --> PINCIR  --> PSTEXT
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSCIRC
C                                                 --> PSPCIR
C                                     --> PINCHQ  --> PSTEXT
C                                                 --> PSCTXT
C                                                 --> PSCALE
C                                                 --> PSBBOX
C                         --> PINGFS  --> PSCTXT
C                                     --> PSHADE
C                                     --> PSCALE
C                                     --> PSBBOX
C                                     --> PSTEXT
C
C                 Plot the Main-chain and Side-chain Properties plots
C             --> RANGES
C             --> QUALIT  --> PSNAME
C                         --> PSOPEN
C                         --> PSPAGE
C                         --> PSLWID
C                         --> PSCTXT
C                         --> PSTEXT
C                         --> PSLWID
C                         --> PSHADE
C                         --> PSUBOX
C                         --> AXES    --> (as above)
C                         --> PSRCTX
C                         --> PSRTXT
C                         --> CURSHD  --> PSHADE
C                                     --> PSUBOX
C                                     --> PSLINE
C                         --> PSBBOX
C                         --> PSOCIR
C                         --> QSTAT   --> PSCTXT
C                                     --> QPUT    --> PSTEXT
C                                                 --> PSCTXT
C                                     --> PSLWID
C                                     --> PSLINE
C                                     --> BANDIS
C                         --> FILKEY  --> (as above)
C                         --> PSENDP
C                         --> PSCLOS
C
C             --> MODLSS  --> PSENDP
C                         --> PSCLOS
C                         --> MSSPLT  --> PSNAME
C                                     --> PSOPEN
C                                     --> PSPAGE
C                                     --> PSLWID
C                                     --> PSCTXT
C                                     --> PSTEXT
C                                     --> ACCSHD  --> (as above)
C                                     --> SSPLOT  --> (as above)
C                                     --> PINRNO  --> (as above)
C                                     --> PSCSHD
C                                     --> PSCIRC
C                                     --> PINTIC  --> (as above)
C             --> PUTPSN
C
C----------------------------------------------------------------------+---
      
      
      PROGRAM MPLOT
      
      INCLUDE 'mplot.inc'

CHECK v.3.4-->
C      INTEGER       GDISTR, IDISTR, MAXCON, NFILE, PLTYPE
C      REAL          VIOLAT(MAXARR)
CHECK v.3.5.2-->
C      INTEGER       GDISTR, IDISTR, NFILE, PLTYPE
      INTEGER       GDISTR, IDISTR, NCELL1, NCELL2, NFILE, PLTYPE
CHECK v.3.5.2<--
      LOGICAL       BOTHND
CHECK v.3.4<--
      
CHECK v.3.5.2-->
      REAL          ENERGY(MXCELL*(NAMINO+1)), NOBSER(MXCELL*(NAMINO+1))
CHECK v.3.5.2<--

C---- Initialise variables
CHECK v.3.4-->
C      CALL INITS(VIOLAT)
      CALL INITS
CHECK v.3.4<--
      IF (IFAIL) GO TO 999
      
C---- Request the name of the original PDB file
      CALL GETOUT
      IF (IFAIL) GO TO 999

C---- Read in the program parameters
      CALL PARAMS
      IF (IFAIL) GO TO 999

C---- Read in the last-used plot-number for the PostScript files
      CALL GETPSN(IPLOT)

C---- Read in all the filenames and plot attributes from the mplot.in
C     file, and store the details
      CALL GETFIL(NFILE)
      IF (IFAIL) GO TO 999
CHECK v.3.4-->
C      MAXCON = MAXARR / NFILE
CHECK v.3.4<--

CHECK v.3.4-->
C---- Read in the model- and residue-ranges in the supplied ranges file,
C     if there is one
      IF (HAVRAN) THEN
          CALL GETRNG(FILRNG,MODFRM,MODTO,RESFRM,RESTO,MAXRNG,MRANGE,
     -        NRANGE,BOTHND,IFAIL)
          IFAIL = .FALSE.

C----     Check whether the user has selected a range of residues
          IF (RESFRM(1).NE.'*ALL  ') RSELEC = .TRUE.

C----     If this is an NMR structure, then find which of the files
C         contain the wanted models
          IF (NMR) THEN
              CALL GETWNT(MXFILE,NFILE,FILRIN,FFILE,MAXRNG,MODFRM,MODTO,
     -            MRANGE,RSELEC,MWANT,NMODEL,MODNUM,ACTNUM,TOPMOD,
     -            TITLE,NAMLEN,TLEN,IFAIL)
              IF (IFAIL) GO TO 999

C----     Model ranges only apply to NMR ensembles, so set to default
C         if this is not an NMR structure
          ELSE
              MRANGE = 1
              MODFRM(MRANGE) = -99999
              MODTO(MRANGE) = 99999
          ENDIF
      ENDIF
CHECK v.3.4<--

C---- Read in the data from the .rin files
      CALL GETVAL(NFILE)
      IF (IFAIL) GO TO 999

C---- Open the .rms and .cns data files, if required
      IF (PLOTPN) THEN
          CALL OPNFIL
          IF (IFAIL) GO TO 999
      ENDIF

C---- Open the output file
      CALL OPNOUT
      IF (IFAIL) GO TO 999

C---- Read in the RMS deviations from the .rms
      IF (PLOTPN .AND. HAVRMS) THEN
          CALL GETRMS
          IF (IFAIL) GO TO 999
      ENDIF

CHECK v.3.4-->
C---- Read in the restraints from the Aqua output files
C      IF (PLOTVI .OR. PLOTMD) THEN
C          CALL GETCON(VIOLAT,NFILE,MAXCON)
C          IF (IFAIL) GO TO 999
C          CALL GETORS(NFILE)
C          IF (IFAIL) GO TO 999
C          IF (TCONST + ACONST.EQ.0) THEN
C              PLOTVI = .FALSE.
C              PLOTMD = .FALSE.
C          ENDIF
C      ENDIF
C---- Read in just the torsion angle restraints from the Aqua output file
      IF (NMR) THEN
          CALL GETORS(NFILE)
          IF (IFAIL) GO TO 999
      ENDIF
CHECK v.3.4<--

C---- Loop through the all the torsion angle distributions and store the
C     G-factors for each residue
      DO 100, IDISTR = 1, NDISTR

C----     Set flag depending on whether this is a 2D plot or a freq distrib
CHECK v.3.4.3-->
C          IF (IDISTR.EQ.5 .OR. IDISTR.EQ.6) THEN
C              TWODEE = .TRUE.
C          ELSE
              TWODEE = .FALSE.
C          ENDIF
CHECK v.3.4.3<--

C----     If the current distribution is one for which there are G-factors
C         read in and uncompress the appropriate distribution data
CHECK v.3.4.3-->
C          GDISTR = 0
C          HAVEG = .FALSE.
C          IF (IDISTR.EQ.3) GDISTR = 3
C          IF (IDISTR.EQ.5) GDISTR = 1
C          IF (IDISTR.EQ.6) GDISTR = 2
C          IF (GDISTR.NE.0) THEN
C              CALL GETDAT(GDISTR)
CHECK v.3.5.2-->
C              CALL GETDAT(IDISTR,TWODEE,NOBSER,NCELL,NCELL1,NAMINO,
C     -            VALBEG,VALEND,STEP,NCOUNT,NRMEAN,NRMSTD,3,IFAIL)
              CALL GETDAT(IDISTR,TWODEE,NOBSER,MXCELL,NCELL1,NCELL2,
     -            NAMINO,VALBEG,VALEND,STEP,NCOUNT,NRMEAN,NRMSTD,3,
     -            .FALSE.,IFAIL)
CHECK v.3.5.2<--
CHECK v.3.4.3<--
              IF (IFAIL) GO TO 999
CHECK v.3.4.3-->
              VALBEG(1) =    0.0
              VALBEG(2) =    0.0
              VALEND(1) =  360.0
              VALEND(2) =  360.0

C----         Smear the observations over the 2D distributions
              IF (TWODEE) THEN
CHECK v.3.5.2-->
C                  CALL SMEAR(NOBSER,ENERGY,NCELL,NCOUNT,NAMINO)
                  CALL SMEAR(NOBSER,ENERGY,NCELL1,NCELL2,NCOUNT,NAMINO)
CHECK v.3.5.2<--
              ENDIF

C----         Calculate log-odds scores
CHECK v.3.5.2-->
C              CALL CALCLO(NOBSER,ENERGY,NCELL,NAMINO,NCOUNT)
              CALL CALCLO(NOBSER,ENERGY,NCELL1,NCELL2,NAMINO,NCOUNT)
CHECK v.3.5.2<--

C----         Calculate each residue's G-factor and store
CHECK v.3.5.2-->
C              CALL CALCRG(IDISTR,NFILE)
              CALL CALCRG(IDISTR,NFILE,ENERGY,NCELL1,NCELL2)
CHECK v.3.5.2<--
CHECK v.3.4.3<--
              HAVEG = .TRUE.
CHECK v.3.4.3-->
C          ENDIF
 100  CONTINUE

C---- Loop over all the distributions to be plotted
      DO 300, IDISTR = 1, NDISTR
CHECK v.3.4.3<--

C----     Calculate the maximum y-value for the frequency distributions
          IF (.NOT.TWODEE) CALL GETMAX(IDISTR,NFILE)

CHECK v.3.4.3-->
C----     Map current distribution onto corresponding G-factor distribution
          GDISTR = 0
          HAVEG = .FALSE.
          IF (IDISTR.EQ.5 .OR. IDISTR.EQ.6) THEN
              TWODEE = .TRUE.
          ELSE
              TWODEE = .FALSE.
          ENDIF
          IF (IDISTR.EQ.3) GDISTR = 3
          IF (IDISTR.EQ.5) GDISTR = 1
          IF (IDISTR.EQ.6) GDISTR = 2
          IF (GDISTR.GT.0) HAVEG = .TRUE.
CHECK v.3.4.3<--

C----     Plot the distribution, if it is required
          IF (CALALL .OR. PLOTDS(IDISTR)) THEN
              CALL FRQPLT(IDISTR,GDISTR,NFILE)
          ENDIF
CHECK v.3.4.3-->
C 100  CONTINUE
 300  CONTINUE
CHECK v.3.4.3<--

CHECK v.3.4-->
C---- Calculate overall G-factors for each model
      CALL CALCG(NFILE)
CHECK v.3.4<--

C---- Produce the ensemble geometry plot
      PLTYPE = NDISTR + 1
      CALL PINS(PLTYPE,NFILE)

C---- Produce the restraint violations plot
CHECK v.3.4-->
C      PLTYPE = NDISTR + 2
C      IF (PLOTVI) CALL PINVIO(PLTYPE,VIOLAT,NFILE,MAXCON)
CHECK v.3.4<--

C---- Plot the model-by-model G-factors
CHECK v.3.3-->
C      PLTYPE = NDISTR + 3
C      IF (PLOTMD) CALL MODELG(PLTYPE,VIOLAT,NFILE,MAXCON)
CHECK v.3.4-->
C      CALL MODELG(PLTYPE,VIOLAT,NFILE,MAXCON)
CHECK v.3.4<--
CHECK v.3.3<--

C---- Calculate the ranges for the x-axis
CHECK v.3.4.3-->
C      CALL RANGES(NFILE)
      CALL RANGES
CHECK v.3.4.3<--

C---- Plot all the stereochemical quality parameters
CHECK v.3.4-->
C      PLTYPE = NDISTR + 4
      PLTYPE = NDISTR + 2
CHECK v.3.4<--
      CALL QUALIT(NFILE,PLTYPE)

C---- Plot the model-by-model secondary-structure wiring diagrams
CHECK v.3.4-->
C      PLTYPE = NDISTR + 5
      PLTYPE = NDISTR + 3
CHECK v.3.4<--
      IF (PLOTSS) CALL MODLSS(PLTYPE,NFILE)

CHECK v.3.4-->
C---- Write out the current PostScript plot number
      CALL PUTPSN(IPLOT)
CHECK v.3.4<--

 999  CONTINUE
      IF (IFAIL) THEN
         PRINT*, '**** Program terminated with error'
      ELSE 
         PRINT*, 'Program complete'
      ENDIF
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE INITS  -  Initialise variables
C     
C----------------------------------------------------------------------+---
      
CHECK v.3.4-->
C      SUBROUTINE INITS(VIOLAT)
      SUBROUTINE INITS
CHECK v.3.4<--
      
      INCLUDE 'mplot.inc'
      
      CHARACTER*3   AMNAME(NAMINO)
CHECK v.3.4.3-->
C      INTEGER       I, IAMINO, IFILE, IGFACT, IPROPT, IQUALP, IRES,
C     -              ITORS
      INTEGER       I, IAMINO, IDISTR, IFILE, IGFACT, IPROPT, IQUALP,
     -              IRES, ITORS
CHECK v.3.4.3<--
CHECK v.3.4-->
C      REAL          VIOLAT(MAXARR)
CHECK v.3.4<--

      DATA AMNAME /'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -             'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -             'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

C---- Initialise variables
      DO 50, IAMINO = 1, NAMINO
          AMINO(IAMINO) = AMNAME(IAMINO)
 50   CONTINUE
      ASTSTR = 0
      AVESTR = 0
      DO 60, I = 1, NPLOT
          BSHADE(I) = .TRUE.
          INCOLR(I) = .FALSE.
 60   CONTINUE
      CHAIN = ' '
      COMBPS = .FALSE.
      ENASTR = 0
      ENSEMB = .FALSE.
CHECK v.3.4-->
      FFILE = 1
CHECK v.3.4<--
      FSTRES = 1
      HAVANG = .FALSE.
CHECK v.3.4-->
      HAVRAN = .FALSE.
CHECK v.3.4<--
      IFAIL = .FALSE.
      IPLOT = 0
      DO 100, IQUALP = 1, NQUALP
          MEAVAL(IQUALP) = 0.0
          DO 80, IFILE = 1, MXFILE
              NVALUE(IQUALP,IFILE) = 0
              SVALUE(IQUALP,IFILE) = 0.0
 80       CONTINUE
 100  CONTINUE
      MAXLEN = 0
      MINLEN = 0
CXXX      NFILE = 0
CHECK v.3.4-->
      MRANGE = 1
      MODFRM(MRANGE) = -99999
      MODTO(MRANGE) = 99999
      DO 110, IFILE = 1, MXFILE
          MWANT(IFILE) = .TRUE.
 110  CONTINUE
CHECK v.3.6-->
      NEWREG = .FALSE.
CHECK v.3.6<--
      NRANGE = 1
      RESFRM(NRANGE) = '*ALL  '
      RESTO(NRANGE) = 'XXXXXX'
CHECK v.3.4<--
      NFOUND = 0
      NLABEL = 0
      NMR = .TRUE.
      NRES = 0
      OOIMAX = 0
      OOIMIN = 999
      DO 300, IRES = 1, MXRES
          AVRACC(IRES) = 0.0
CHECK v.3.4-->
          CHNBRK(IRES) = ' '
CHECK v.3.4<--
          DO 120, I = 1, NDISTR
              CIRCVR(I,IRES) = 0.0
 120      CONTINUE
          CONSST(IRES) = ' '
CHECK v.3.4.3-->
C          DO 140, IGFACT = 1, NGFACT + 1
          DO 140, IGFACT = 1, NDISTR + 1
CHECK v.3.4.3<--
              GFACT(IGFACT,IRES) = 999.9
 140      CONTINUE
          DOUBL(IRES) = .FALSE.
          NOOI(IRES) = 0
          NXTRES(IRES) = 0
          SSTCNT(1,IRES) = 0
          SSTCNT(2,IRES) = 0
          SSTCNT(3,IRES) = 0
          VALOOI(IRES) = 0.0
          VALRES(IRES) = ' '
          VALSNO(IRES) = ' '
          DO 200, IFILE = 1, MXFILE
              RESMOD(IRES,IFILE) = .FALSE.
              SAVOOI(IRES,IFILE) = 0.0
              STOSST(IRES,IFILE) = ' '
              DO 160, IPROPT = 1, NPROPT
                  VALUE(IPROPT,IRES,IFILE) = 999.9
 160          CONTINUE
 200      CONTINUE
          DO 240, ITORS = 1, MXTORS
              DIHCON(1,ITORS,IRES) = 999.9
              DIHCON(2,ITORS,IRES) = 999.9
              DVIOL(ITORS,IRES) = 0
              DO 220, IFILE = 1, MXFILE
                  DVIOLM(ITORS,IRES,IFILE) = -999.9
 220          CONTINUE
 240      CONTINUE
 300  CONTINUE
      PINDMX = 0.0
CHECK v.3.4-->
      RSELEC = .FALSE.
CHECK v.3.4<--
      DO 400, I = 1, MXPLOT
          PINMAX(I) = 0.0
          PLTSTD(I) = 0.0
 400  CONTINUE
      HISTOG = .TRUE.
      DO 480, IFILE = 1, MXFILE + 1
          DO 460, IRES = 1, MXRES + 1
CHECK v.3.4.3-->
C              SCOMOD(IRES,IFILE) = 0.0
C              NUMSCO(IRES,IFILE) = 0
              DO 440, IDISTR = 1, NDISTR + 1
                  SCOMOD(IDISTR,IRES,IFILE) = 0.0
                  NUMSCO(IDISTR,IRES,IFILE) = 0
 440          CONTINUE
CHECK v.3.4.3<--
 460      CONTINUE
 480  CONTINUE
      WITHAN = .FALSE.
      DO 550, IRES = 1, MXRES
          RMSALL(1,IRES) = 0.0
          RMSALL(2,IRES) = 0.0
          RMSALL(3,IRES) = 0.0
          DO 520, IFILE = 1, MXFILE
              RMSDEV(1,IRES,IFILE) = 0.0
              RMSDEV(2,IRES,IFILE) = 0.0
              RMSDEV(3,IRES,IFILE) = 0.0
 520      CONTINUE
 550  CONTINUE

CHECK v.3.4-->
C---- Initialise the violations array
C      DO 600, I = 1, MAXARR
C          VIOLAT(I) = 0.0
C 600  CONTINUE
CHECK v.3.4<--

C---- Initiliase all the means and standard dev. values used in the
C     Quality Plots
      DO 800, IFILE = 1, MXFILE

 800  CONTINUE

C---- Open data file, prodata
      OPEN(UNIT=3, FILE='prodata', STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

      GO TO 999

900   CONTINUE
      PRINT*, '*** ERROR. Unable to open parameter file, prodata'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETOUT  -  Read in the name out the output file and the
C                        chain
C
C----------------------------------------------------------------------+--- 
 
      SUBROUTINE GETOUT
 
      INCLUDE 'mplot.inc'
 
      CHARACTER*1   LOWERA
      CHARACTER*26  UPPER
      INTEGER       LINE, N
      LOGICAL       IERROR

      DATA  LOWERA / 'a' /
      DATA  UPPER  / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /

C---- Initialise variables
      LINE = 0

C---- Accept name of output file
      PRINT*, 'Enter name of input PDB file'
      PRINT*, '  (or, for a list of files, enter %filelist, where',
     -    ' filelist'
      PRINT*, '   contains the PDB filenames)'
      READ(*,110,ERR=900) PDBFIL
 110  FORMAT(A)
      IF (PDBFIL(1:1).EQ.'%') THEN
          PDBFIL = PDBFIL(2:)
          ENSEMB = .TRUE.
          NMR = .FALSE.
      ENDIF

C---- Peel off directory path and extension
CHECK v.3.6.4-->
C      CALL GETNAM(PDBFIL,ISTART,IEND,IERROR)
      CALL GETNAM(PDBFIL,FNAMLN,ISTART,IEND,IERROR)
CHECK v.3.6.4<--
      IF (IERROR) GO TO 990

C---- Form names of other files that will be required in default directory
      PSLEN = IEND - ISTART + 1
      BRCALL = PDBFIL(ISTART:IEND)
      FILPS = BRCALL
      TITLE = BRCALL
      FILCNS = PDBFIL(ISTART:IEND) // '.cns'
      FILEDT = PDBFIL(ISTART:IEND) // '.edt'
      FILRMS = PDBFIL(ISTART:IEND) // '.rms'
      FILTOR = PDBFIL(ISTART:IEND) // '.tor'
CHECK v.3.4-->
C      FILVIO(1) = PDBFIL(ISTART:IEND) // '.nrv'
C      FILVIO(2) = PDBFIL(ISTART:IEND) // '.hrv'
CHECK v.3.4<--

C---- Accept chain-ID
      PRINT*, 'Enter required chain-ID, or leave blank for all'
      READ(*,110,ERR=904) CHAIN

C---- Convert chain ID to upper-case if necessary
      N = ICHAR(CHAIN) - ICHAR(LOWERA) + 1
      IF (N.GE.1 .AND. N.LE.26) CHAIN = UPPER(N:N)

C---- Add chain identifier to plot headings
      TLEN = PSLEN
      IF (CHAIN.NE.' ' .AND. PSLEN.LT.30) THEN
          TITLE = TITLE(1:PSLEN) // ' - Chain ' // CHAIN
          TLEN = TLEN + 10
      ENDIF
CHECK v.3.4-->
C      IF (TLEN.GT.40) TLEN = 40
      IF (TLEN.GT.78) TLEN = 78
      NAMLEN = TLEN

C---- Read in (optional) name of ranges file
      PRINT*, 'Enter name of ranges file (blank if none)'
      READ(*,110,ERR=900) FILRNG
      IF (FILRNG.EQ.' ') THEN
          HAVRAN = .FALSE.
      ELSE
          HAVRAN = .TRUE.
      ENDIF
CHECK v.3.4<--

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** ERROR. Data error in entered filename'
      GO TO 990

 904  CONTINUE
      PRINT*, '**** ERROR. Data error in entered title'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.
 
999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PARAMS  -  Read in program parameters from parameter file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PARAMS

      INCLUDE 'mplot.inc'

      CHARACTER*1   YESNO
CHECK v.3.4-->
C      CHARACTER*80  FNAME
      CHARACTER*80  FNAME, IREC
CHECK v.3.4<--
      INTEGER       I, ICOL, INUMB1, INUMB2, IP, LINE, LOCATN(MXPLOT),
     -              PLTYPE
CHECK v.3.4-->
C      LOGICAL       ALLCOL, FINERR
      LOGICAL       ALLCOL, ENDCOL, FINERR
CHECK v.3.4<--
      REAL          RNUMB

      DATA LOCATN / LOCHI1, LOCOME, LOCZET /

C---- Open parameter file
      IF (NMR) THEN
          FNAME = 'procheck_nmr.prm'
      ELSE
          FNAME = 'procheck_comp.prm'
      ENDIF
      OPEN(UNIT=10, FILE=FNAME, STATUS='OLD',
     -     FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)
      FINERR = .FALSE.
      LINE = 0

C---- Read in the parameters

C---- Check that have the right version number in the parameter file
      IF (NMR) THEN
CHECK v.3.4-->
C          CALL FINKEY('PROCHECK-NMR. PROCHECK v.3.3',28,LINE,FINERR)
C      ELSE
C          CALL FINKEY('PROCHECK-COMP. PROCHECK v.3.3',29,LINE,FINERR)
          CALL FINKEY('PROCHECK-NMR. PROCHECK v.3.4',28,LINE,FINERR)
      ELSE
          CALL FINKEY('PROCHECK-COMP. PROCHECK v.3.4',29,LINE,FINERR)
CHECK v.3.4<--
      ENDIF
      IF (FINERR) GO TO 901

C---- Find the colours key-word
      CALL FINKEY('Colours',7,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Read in all the RGB colours and corresponding colour names
CHECK v.3.4-->
C      DO 100, ICOL = 1, MXCOLR
C          LINE = LINE + 1
C          READ(10,*,END=902,ERR=904) (RGB(I, ICOL), I = 1, 3),
C     -        COLNAM(ICOL)
C 100  CONTINUE
      ENDCOL = .FALSE.
      NCOLOR = MXCOLR
      DO 100, ICOL = 1, MXCOLR
          IF (.NOT.ENDCOL) THEN
              LINE = LINE + 1
              READ(10,20,END=902,ERR=904) IREC
 20           FORMAT(A)
              IF (IREC.EQ.' ') THEN
                  ENDCOL = .TRUE.
              ELSE
                  READ(IREC,*,ERR=904) (RGB(I,ICOL), I = 1, 3),
     -                COLNAM(ICOL)
                  NCOLOR = ICOL
              ENDIF
          ENDIF

C----     If have reached end of colours then insert default
          IF (ENDCOL) THEN
              RGB(1,ICOL) = 0.0
              RGB(2,ICOL) = 0.0
              RGB(3,ICOL) = 0.0
              COLNAM(ICOL) = 'WHITE'
          ENDIF
 100  CONTINUE
CHECK v.3.4<--

CHECK v.3.6-->
C---- See if new Ramachandran regions are to be used
      CALL FINKEY('Ramachandran regions',20,LINE,FINERR)
      IF (.NOT.FINERR) THEN
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              NEWREG = .TRUE.
          ELSE
              NEWREG = .FALSE.
          ENDIF
      ENDIF
CHECK v.3.6<--

C---- Determine whether all plots are to be in colour

C---- Find the colour-all-plots keywords
      CALL FINKEY('Colour all plots?',17,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Determine whether all plots are to be in colour
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          ALLCOL = .TRUE.
      ELSE
          ALLCOL = .FALSE.
      ENDIF

C---- Determine which plots are to be produced

C---- Find the "Which plots" keyword
CHECK v.3.4-->
C      CALL FINKEY('Which plots',11,LINE,FINERR)
CHECK v.3.4.2-->
C      CALL FINKEY('a. Geometry plots',17,LINE,FINERR)
      IF (NMR) THEN
          CALL FINKEY('a. Geometry plots',17,LINE,FINERR)
      ELSE
          CALL FINKEY('Which plots',11,LINE,FINERR)
      ENDIF
CHECK v.3.4.2<--
CHECK v.3.4<--
      IF (FINERR) GO TO 990

C---- Skip the first 3 options as these are done by tplot.f
      DO 150, I = 1, 3
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
 120      FORMAT(A)
 150  CONTINUE

C---- Loop through all the different plots to see which are required
      DO 200, PLTYPE = 1, NDISTR
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              PLOTDS(PLTYPE) = .TRUE.
          ELSE
              PLOTDS(PLTYPE) = .FALSE.
          ENDIF
 200  CONTINUE

C---- Read in whether the ensemble geometry plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTPN = .TRUE.
      ELSE
          PLOTPN = .FALSE.
      ENDIF

CHECK v.3.4-->
C---- Read in whether the restraint violations plot is required
C      LINE = LINE + 1
C      READ(10,120,END=902,ERR=904) YESNO
C      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
C          PLOTVI = .TRUE.
C      ELSE
C          PLOTVI = .FALSE.
C      ENDIF

C---- Read in whether the model-by-model G-factors plot is required
C      LINE = LINE + 1
C      READ(10,120,END=902,ERR=904) YESNO
C      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
C          PLOTMD = .TRUE.
C      ELSE
C          PLOTMD = .FALSE.
C      ENDIF
CHECK v.3.4<--

C---- Read in whether the Quality Plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTQY = .TRUE.
      ELSE
          PLOTQY = .FALSE.
      ENDIF

CHECK v.3.4-->
C---- For ensembles, don't want to produce any of the NMR-specific plots
C      IF (ENSEMB) THEN
C          PLOTVI = .FALSE.
C          PLOTMD = .FALSE.
CCHECK v.3.3-->
CC          PLOTQY = .FALSE.
CCHECK v.3.3<--
C      ENDIF
CHECK v.3.4<--

C---- Read in whether the model-by-model secondary-structures wiring
C     diagrams are required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTSS = .TRUE.
      ELSE
          PLOTSS = .FALSE.
      ENDIF

C---- Read in the plot parameters for each individual plot
      PLTYPE = 0

C---- Plots 4-9

C---- Find the plot's identifying key-words
      CALL FINKEY('4-9. Dihedral angle',19,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = PLTYPE + 1

C---- Determine whether histograms or progression-plots required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          HISTOG = .TRUE.
      ELSE
          HISTOG = .FALSE.
      ENDIF

CHECK v.3.3-->
C---- Read the circular variance cut-off so that can plot only those
C     residues which have a large circular variance (ie significantly
C     different across the ensemble of structures)
      LINE = LINE + 1
      READ(10,*,END=902,ERR=904) CVCUT
CHECK v.3.3<--

C---- Background shading (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          BSHADE(PLTYPE) = .TRUE.
      ELSE
          BSHADE(PLTYPE) = .FALSE.
      ENDIF

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
CHECK v.3.4-->
C      DO 320, ICOL = 1, 8
      DO 320, ICOL = 1, 6
CHECK v.3.4<--
          CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
 320  CONTINUE

C---- Update all frequency distribution colours with the user-defined
C     colours just read in
      DO 400, PLTYPE = 2, NDISTR
CHECK v.3.4.3-->
C          DO 350, ICOL = 1, 8
          DO 350, ICOL = 1, 6
CHECK v.3.4.3<--
              COLPLT(ICOL,PLTYPE) = COLPLT(ICOL,1)
 350      CONTINUE
 400  CONTINUE

CHECK v.3.4-->
C---- Omit circular variance dials (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          OMITCV = .TRUE.
      ELSE
          OMITCV = .FALSE.
      ENDIF

C---- Omit G-factors (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          OMITGF = .TRUE.
      ELSE
          OMITGF = .FALSE.
      ENDIF

C---- Omit accessibility symbols (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          OMITAS = .TRUE.
      ELSE
          OMITAS = .FALSE.
      ENDIF
CHECK v.3.4<--

CHECK v.3.4.3-->
C---- Splay model-numbering on the 2D plots (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          SPLAYN = .TRUE.
      ELSE
          SPLAYN = .FALSE.
      ENDIF
CHECK v.3.4.3<--

C---- Plot 10

C---- Find the plot's identifying key-words
      CALL FINKEY('10. Ensemble geometry',21,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = NDISTR + 1

C---- Which 3 plots are to appear on the Residues plot (1 - MXPLOT)
      NRGRAF = 0
      LINE = LINE + 1
      READ(10,*,END=902,ERR=904) INUMB1, INUMB2
      IF (INUMB1.GE.0 .AND. INUMB1.LE.MXPLOT) THEN
          DATLOC(1) = LOCATN(INUMB1)
          PLTNUM(1) = INUMB1
      ENDIF
      IF (PLTNUM(1).GT.0) NRGRAF = NRGRAF + 1
      IF (INUMB2.GE.0 .AND. INUMB2.LE.MXPLOT) THEN
          DATLOC(2) = LOCATN(INUMB2)
          PLTNUM(2) = INUMB2
      ENDIF
      IF (PLTNUM(2).GT.0) NRGRAF = NRGRAF + 1
      PLTNUM(3) = 0

C---- Background shading (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          BSHADE(PLTYPE) = .TRUE.
      ELSE
          BSHADE(PLTYPE) = .FALSE.
      ENDIF

C---- No. of standard deviations for highlighting on Residues plot
      LINE = LINE + 1
      READ(10,*,END=902,ERR=904) RNUMB
      LIMRES = RNUMB
      IF (LIMRES.LT.0.0) LIMRES = 0.0
      IF (LIMRES.GT.99.9) LIMRES = 99.9

C---- Shading showing estimated accessibility (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          SHOWAC = .TRUE.
      ELSE
          SHOWAC = .FALSE.
      ENDIF

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 440, ICOL = 1, 10
          CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
 440  CONTINUE

CHECK v.3.4-->
C Plot options for restraint violation plots moved to vplot.f
CHECK v.3.4<--

C---- Plot 11
      PLTYPE = PLTYPE + 1
      IF (PLOTQY) THEN

C----     Find the plot's identifying key-words
CHECK v.3.3-->
	  IF (NMR) THEN
CHECK v.3.3<--
CHECK v.3.4-->
C              CALL FINKEY('13. Equivalent resolution',25,LINE,FINERR)
              CALL FINKEY('11. Equivalent resolution',25,LINE,FINERR)
CHECK v.3.4<--
CHECK v.3.3-->
	  ELSE
CHECK v.3.4-->
C              CALL FINKEY('13. Residue property comparisons',32,
              CALL FINKEY('11. Residue property comparisons',32,
CHECK v.3.4<--
     -            LINE,FINERR)
	  ENDIF
CHECK v.3.3<--
          IF (FINERR) GO TO 990

C----     Background shading (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              BSHADE(PLTYPE) = .TRUE.
          ELSE
              BSHADE(PLTYPE) = .FALSE.
          ENDIF

C----     Produce a black-and-white or colour PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCOLR(PLTYPE) = .TRUE.
          ELSE
              INCOLR(PLTYPE) = .FALSE.
          ENDIF

C----     Get each of the user-defined colours for this plot
          DO 480, ICOL = 1, 3
              CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
 480      CONTINUE
      ENDIF

C---- Plot 14

C---- Find the plot's identifying key-words
CHECK v.3.4-->
C      CALL FINKEY('14. Model-by-model secondary ',29,LINE,FINERR)
      CALL FINKEY('12. Model-by-model secondary ',29,LINE,FINERR)
CHECK v.3.4<--
      IF (FINERR) GO TO 990
      PLTYPE = PLTYPE + 1

C---- Acessibility shading (Y/N)?
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          SHOWSA = .TRUE.
      ELSE
          SHOWSA = .FALSE.
      ENDIF

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 500, ICOL = 1, 4
          CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
 500  CONTINUE

C---- General plot parameters

C---- Find whether file-handles are required or not
      CALL FINKEY('File-handles',12,LINE,FINERR)
      IF (.NOT.FINERR) THEN

C----     See whether the file-handle is required
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              WITHAN = .TRUE.
          ELSE
              WITHAN = .FALSE.
          ENDIF

C----     See whether plot filename to be printed on the plot itself
          LINE = LINE + 1
          READ(10,*,END=902,ERR=904)
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              PLABEL = .TRUE.
          ELSE
              PLABEL = .FALSE.
          ENDIF

C----     See whether all pages of same plot to be combined in one
C         paginated PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              COMBPS = .TRUE.
          ELSE
              COMBPS = .FALSE.
          ENDIF
      ENDIF

C---- If all plots are required to be in colour, then set all the
C     appropriate flags to TRUE
      IF (ALLCOL) THEN
          DO 600, IP = 1, NPLOT
              INCOLR(IP) = .TRUE.
 600      CONTINUE
      ENDIF

C---- Determine if all distributions need to be read in and all
C     calculations performed
CHECK v.3.4-->
C      IF (PLOTPN .OR. PLOTMD) THEN
CHECK v.3.4.3-->
C      IF (PLOTPN) THEN
      IF (PLOTPN .OR. PLOTQY) THEN
CHECK v.3.4.3<--
CHECK v.3.4<--
          CALALL = .TRUE.
      ELSE
          CALALL = .FALSE.
      ENDIF

      GO TO 999


C---- Errors reading parameter file
900   CONTINUE
CHECK v.3.4-->
C      PRINT*, '*** ERROR Parameters file (procheck_nmr.prm) not found.'
      IF (NMR) THEN
          PRINT*, '*** ERROR Parameters file (procheck_nmr.prm) not ',
     -        'found.'
      ELSE
          PRINT*, '*** ERROR Parameters file (procheck_comp.prm) not ',
     -        'found.'
      ENDIF
CHECK v.3.4<--
      GO TO 990

 901  CONTINUE
CHECK v.3.4-->
C      PRINT*, '*** Failed to find correct version number in ',
C     -        'parameters file, procheck_nmr.prm'
      IF (NMR) THEN
          PRINT*, '*** Old version of parameter file, ',
     -        'procheck_nmr.prm, found'
      ELSE
          PRINT*, '*** Old version of parameter file, ',
     -        'procheck_comp.prm, found'
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'
CHECK v.3.4<--
      GO TO 990

902   CONTINUE
CHECK v.3.4-->
C      PRINT*, '*** Premature end of parameters file, procheck_nmr.',
C     -        'prm, encountered at line', LINE
      IF (NMR) THEN
          PRINT*, '*** Premature end in parameter file, ',
     -        'procheck_nmr.prm, at line', LINE
      ELSE
          PRINT*, '*** Premature end in parameter file, ',
     -        'procheck_comp.prm, at line', LINE
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'
CHECK v.3.4<--
      GO TO 990

904   CONTINUE
CHECK v.3.4-->
C      PRINT*, '*** Error reading parameter file, procheck_nmr.prm, ',
C     -        'at line', LINE
      IF (NMR) THEN
          PRINT*, '*** Error reading parameter file, ',
     -        'procheck_nmr.prm, at line', LINE
      ELSE
          PRINT*, '*** Error reading parameter file, ',
     -        'procheck_comp.prm, at line', LINE
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'
CHECK v.3.4<--

      GO TO 990

C---- Close the parameter file
 990  CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE GETFIL  -  Read through the list of files in mplot.in,
C                        picking up information about each one (such
C                        as x-coord, marker-type, label, etc)
C
C----------------------------------------------------------------------+---
      
      SUBROUTINE GETFIL(NFILE)
      
      INCLUDE 'mplot.inc'
      
CHECK v.3.4-->
      CHARACTER*3   NUMSTR
CHECK v.3.4<--
      CHARACTER*10  NAME
      CHARACTER*80  FNAME
CHECK v.3.4-->
C      INTEGER       MARKER, NFILE
      INTEGER       IPOS, MARKER, NFILE
CHECK v.3.4<--
      REAL          NUMBER
      
C---- Initialise variables
      NFILE = 0
      PRINT*
      PRINT*, 'Reading in data ...'
      PRINT*
      RESOL(1) = 2.5

C---- Open input file, mplot.in
      OPEN(UNIT=2, FILE='mplot.in', STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)
      
C---- Read through the file
 100  CONTINUE
      
C----     Read in the next filename
          READ(2,20,END=500,ERR=902) FNAME
 20       FORMAT(A)
          IF (FNAME(1:1).EQ.' ') GO TO 100
          NFILE = NFILE + 1
          IF (NFILE.GT.MXFILE) GO TO 908

C----     Search the line for an x-axis value and description
          NUMBER = NFILE
          CALL GETNOD(FNAME,NUMBER,NAME,MARKER,NLABEL,IEND,NFOUND,
     -        ASTSTR,AVESTR,ENASTR)
          MKNAME(NFILE) = NAME
          MKTYPE(NFILE) = MARKER
          XVALUE(NFILE) = NUMBER
CHECK v.3.3-->
          RESOL(NFILE) = NUMBER
CHECK v.3.3<--

C----     Store maximum and minimum values
          IF (NFILE.EQ.1) THEN
              MINX = NUMBER
              MAXX = NUMBER
          ELSE
              MINX = MIN(NUMBER,MINX)
              MAXX = MAX(NUMBER,MAXX)
          ENDIF

C----     Peel off directory path and extension
          PDBFIL = FNAME(1:IEND)
CHECK v.3.6.4-->
C          CALL GETNAM(PDBFIL,ISTART,IEND,IFAIL)
          CALL GETNAM(PDBFIL,FNAMLN,ISTART,IEND,IFAIL)
CHECK v.3.6.4<--
          IF (IFAIL) GO TO 999
      
C----     Form names of other files that will be required in default directory
          ILEN = IEND - ISTART + 1
          BRCODE(NFILE) = PDBFIL(ISTART:IEND)
          FILRIN(NFILE) = PDBFIL(1:IEND) // '.rin'

C----     Store identifying code
          LENID(NFILE) = IEND - ISTART + 1
          IF (LENID(NFILE).GT.MXLEND) THEN
              LENID(NFILE) = MXLEND
              FILID(NFILE) = PDBFIL(IEND - MXLEND + 1:IEND)
          ELSE
              FILID(NFILE) = PDBFIL(ISTART:IEND)
          ENDIF

C----     If plotting the quality plots, read in the appropriate data
          IF (PLOTQY) THEN

C----         Check whether the resolution is the same as all those already
C             read in
CXXX              IF (RESOL(NFILE).NE.RESOL(1)) RESAME = .FALSE.
              IF (NFILE.EQ.1 .OR. NMR) THEN
                  RESMIN = RESOL(NFILE)
              ELSE
                  RESMIN = MIN(RESOL(NFILE),RESMIN)
              ENDIF
          ENDIF
      GO TO 100

C---- Close the mplot.in file
 500  CONTINUE
      CLOSE(2)
      IF (NFILE.EQ.0) GO TO 910

CHECK v.3.4-->
C---- Add number of models to plot title
      IF (TLEN.LT.65) THEN
          WRITE(NUMSTR,520) NFILE
 520      FORMAT(I3)
          IPOS = 1
          IF (NUMSTR(1:1).EQ.' ') IPOS = 2
          IF (NUMSTR(2:2).EQ.' ') IPOS = 3
          TITLE = TITLE(1:TLEN) // ' (' // NUMSTR(IPOS:) // ' models)'
          TLEN = TLEN + 14 - IPOS
      ENDIF
      NMODEL = NFILE
      TOPMOD = NFILE
CHECK v.3.4<--

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** Unable to open input file, mplot.in'
      GO TO 990
 
 902  CONTINUE
      PRINT*, '**** File error reading file mplot.in at line',
     -    NFILE + 1
      GO TO 990
 
 908  CONTINUE
      PRINT*, '**** Maximum number of files exceeded. Amend parameter ',
     -    'MXFILE =', MXFILE
      GO TO 990
 
 910  CONTINUE
      PRINT*, 'No files found in mplot.in list'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.
 
 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C  SUBROUTINE GETNOD  -  Search for an x-axis value, protein description and
C                        marker-type at the end of the line containing the
C                        name of the .rin file
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE GETNOD(INLINE,NUMBER,NAME,MARKER,NLABEL,IEND,NFOUND,
     -    ASTSTR,AVESTR,ENASTR)

      SAVE

      INTEGER       MXLET
      PARAMETER    (MXLET = 10)

      CHARACTER*1   CQUOTE, DQUOTE, INCHAR, QUOTE
      CHARACTER*(MXLET) NAME
      CHARACTER*20  CHNUMB
      CHARACTER*80  INLINE
      INTEGER       ASTSTR, AVESTR, ENASTR, CURMRK, IEND, IFROM, ILET,
     -              INUM, IPOS, ISTATE, ITO, MARKER, NDECPT,
     -              NFILE, NFOUND, NLABEL, RERROR
      REAL          NUMBER, VALUE

      DATA CURMRK / 1 /
      DATA DQUOTE, QUOTE / '"', '''' /

C---- Initialise variables
      IEND = 80
      ITO = IEND
      IPOS = 0
      MARKER = CURMRK
      NAME = ' '
      NFILE = NUMBER

C---- Find where the file-name ends
 100  CONTINUE
          IPOS = IPOS + 1
          IF (INLINE(IPOS:IPOS).EQ.' ') THEN
              IEND = IPOS - 1
              GO TO 200
          ENDIF
      IF (IPOS.LT.IEND) GO TO 100

C---- No end to filename found, so no other details located
      GO TO 999

C---- End of filename located
 200  CONTINUE
      IFROM = IEND + 1

C---- Initialise variables
      ISTATE = 1
      IPOS = IFROM - 1

C---- Loop through remaining positions in the line for any marker types,
C     labels, or x-positions
 300  CONTINUE
          IPOS = IPOS + 1
          INCHAR = INLINE(IPOS:IPOS)

C----     State 1 - Searching for M, A, E, opening quote, or number
          IF (ISTATE.EQ.1) THEN

C----         Check whether this is one of the characters of interest
              IF (INCHAR.EQ.QUOTE .OR. INCHAR.EQ.DQUOTE) THEN
                  ISTATE = 2
                  ILET = 0
                  CQUOTE = INCHAR
                  NAME = ' '
              ELSE IF (INCHAR.EQ.'*') THEN
                  ASTSTR = NFILE
              ELSE IF (INCHAR.EQ.'A' .OR. INCHAR.EQ.'a') THEN
                  AVESTR = NFILE
              ELSE IF (INCHAR.EQ.'E' .OR. INCHAR.EQ.'e') THEN
                  ENASTR = NFILE
              ELSE IF (INCHAR.EQ.'M' .OR. INCHAR.EQ.'m') THEN
                  ISTATE = 3
              ELSE IF ((INCHAR.LE.'9' .AND. INCHAR.GE.'0') .OR.
     -            INCHAR.EQ.'-') THEN
                  ISTATE = 4
                  CHNUMB = INCHAR
                  NDECPT = 0
                  INUM = 1
              ELSE IF (INCHAR.EQ.'.') THEN
                  ISTATE = 4
                  CHNUMB = '0.'
                  NDECPT = 1
                  INUM = 2
              ENDIF

C----     State 2 - Storing label text (up to maximum of 10 chars), while
C                   waiting for closing quotes
          ELSE IF (ISTATE.EQ.2) THEN

C----         Check for closing quote
              IF (INCHAR.EQ.CQUOTE) THEN
                  ISTATE = 1
                  IF (ILET.GT.0) NLABEL = NLABEL + 1

C----         Otherwise, store the character
              ELSE
                  ILET = ILET + 1
                  IF (ILET.LE.MXLET) THEN
                      NAME(ILET:ILET) = INCHAR
                  ENDIF
              ENDIF

C----     State 3 - Determining what required the marker type is
          ELSE IF (ISTATE.EQ.3) THEN
              IF (INCHAR.LE.'9' .AND. INCHAR.GE.'1') THEN
                  READ(INCHAR,320) MARKER
 320              FORMAT(I1)
                  CURMRK = MARKER
              ENDIF
              ISTATE = 1

C----     State 4 - Storing characters making up the number representing
C                   x-axis value
          ELSE IF (ISTATE.EQ.4) THEN
              IF (INCHAR.EQ.' ') THEN
                  IF (NDECPT.EQ.0 .AND. INUM.LT.20) THEN
                      CHNUMB(INUM+1:INUM+1) = '.'
                  ENDIF
                  CALL READCH(CHNUMB,VALUE,RERROR)
                  IF (RERROR.EQ.0) THEN
                      NUMBER = VALUE
                      NFOUND = NFOUND + 1
                  ENDIF
                  ISTATE = 1
              ELSE IF (INCHAR.EQ.'.') THEN
                  INUM = INUM + 1
                  IF (INUM.LE.20) CHNUMB(INUM:INUM) = INCHAR
                  NDECPT = 1
              ELSE IF (INCHAR.LE.'9' .AND. INCHAR.GE.'0') THEN
                  INUM = INUM + 1
                  IF (INUM.LE.20) CHNUMB(INUM:INUM) = INCHAR
              ENDIF
          ENDIF

      IF (IPOS.LT.ITO) GO TO 300

 999  CONTINUE
      RETURN
      END

C----------------------------------------------------------------------+--- 
C**************************************************************************
C
C  SUBROUTINE READCH  -  Routine to convert character string to real number
C
C--------------------------------------------------------------------------
 
      SUBROUTINE READCH(NUMB,A,RERROR)

      CHARACTER*4   EXPO
      CHARACTER*20  NUMB
      REAL          A, RPOWER
      INTEGER       EPOS, IPOWER, RERROR

      RERROR = 0
      EPOS = INDEX(NUMB,'E')
      IF (EPOS.GT.0) THEN
          READ(NUMB(1:EPOS - 1),160,ERR=904) A
160       FORMAT(F20.0)
          EXPO = NUMB(EPOS + 1:)
          EPOS = INDEX(EXPO,' ')
          IF (EPOS.GT.0) EXPO(EPOS:EPOS) = '.'
          READ(EXPO,160,ERR=904) RPOWER
          IPOWER = RPOWER
          A = A * 10.0 ** IPOWER
      ELSE
          READ(NUMB,160,ERR=904) A
      ENDIF

      GO TO 999

904   CONTINUE
      RERROR = 1

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE OPNFIL  -   Open .rms and .cns data files
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNFIL

      INCLUDE 'mplot.inc'

C---- Initialise variables
      IFAIL = .FALSE.

C---- Open input RMS deviations file, filename.rms
      HAVRMS = .TRUE.
      OPEN(UNIT=8,FILE=FILRMS,STATUS='OLD',ERR=900,FORM='FORMATTED',
CVAX     -     READONLY,
     -     ACCESS='SEQUENTIAL')

C---- Open input Restraints file, filename.cns
CXXX      HAVCON = .TRUE.
CXXX      OPEN(UNIT=9,FILE=FILCNS,STATUS='OLD',ERR=902,FORM='FORMATTED',
CXXXCVAX     -     READONLY,
CXXX     -     ACCESS='SEQUENTIAL')

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Warning. Unable to open input .rms file: '
      PRINT*, FILRMS(1:PSLEN), '*'
      HAVRMS = .FALSE.
      GO TO 999

CXXX 902  CONTINUE
CXXX      PRINT*, '*** NOTE. Input restraints file not supplied: '
CXXX      PRINT*, FILCNS, '*'
CXXX      HAVCON = .FALSE.
CXXX      GO TO 999

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE OPNOUT  -   Open the output .edt file
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNOUT

      INCLUDE 'mplot.inc'

C---- Initialise variables
      IFAIL = .FALSE.

C---- Open the output .edt file
      OPEN(UNIT=13,FILE=FILEDT,STATUS='UNKNOWN',ERR=900,
CVAX     -     CARRIAGECONTROL='LIST',
     -     FORM='FORMATTED',ACCESS='SEQUENTIAL')

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Unable to open output .edt file: '
      PRINT*, FILEDT(1:PSLEN), '*'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4.3-->
C Routine GETDAT transferred to ps.f
CHECK v.3.4.3<--
C**************************************************************************
C     
C  SUBROUTINE GETVAL  -  Read through all the .rin files to pick up the
C                        data for the distributions
C
C----------------------------------------------------------------------+---
      
      SUBROUTINE GETVAL(NFILE)

      SAVE
      
      INCLUDE 'mplot.inc'

      CHARACTER*1   SECSTR(3)
      INTEGER       ICOL, IFILE, IRES, ISTRUC, MCOUNT, NFILE,
     -              TSTRUC
      LOGICAL       RESAME

      DATA SECSTR / 'H', 'E', 'C' / 

C---- Initialise valiables
      RESAME = .TRUE.

C---- Loop through all the .rin files
      DO 100, IFILE = 1, NFILE

CHECK v.3.4-->
C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----         Read in the residue-by-residue torsion angle data from
C             the corresponding .rin file
              CALL GETRIN(IFILE)
              IF (IFAIL) GO TO 999
CHECK v.3.4-->
          ENDIF
CHECK v.3.4<--
 100  CONTINUE

C---- Show sequence statistics
      PRINT*
      PRINT 110, 'Ensemble comprises            ', NFILE, ' files'
 110  FORMAT(1X,A,I4,A)
      PRINT*
      PRINT 110, 'Minimum sequence length       ', MINLEN
      PRINT 110, 'Maximum sequence length       ', MAXLEN
      PRINT*
      PRINT 110, 'Total no. of unique residues  ', NRES
      PRINT*

C---- Adjust Ooi-number maximum and minimum if equal
      IF (OOIMAX.LE.OOIMIN) OOIMAX = OOIMIN + 1.0

C---- Add number of models to plot title
CHECK v.3.4-->
C      IF (TLEN.LT.27) THEN
C          WRITE(NUMBER,120) NFILE
C 120      FORMAT(I3)
C          IPOS = 1
C          IF (NUMBER(1:1).EQ.' ') IPOS = 2
C          IF (NUMBER(2:2).EQ.' ') IPOS = 3
C          TITLE = TITLE(1:TLEN) // ' (' // NUMBER(IPOS:) // ' models)'
C          TLEN = TLEN + 14 - IPOS
C      ENDIF
CHECK v.3.4<--

C---- Determine the consensus secondary structure assignment for
C     each residue and calculate the accessibilities from the Ooi
C     numbers
      DO 200, IRES = 1, NRES
          MCOUNT = 0
          TSTRUC = 3

C----     Find which secondary structure type has been assigned most
C         often for this residue
          DO 150, ISTRUC = 1, 3
              IF (SSTCNT(ISTRUC,IRES).GT.MCOUNT) THEN
                  MCOUNT = SSTCNT(ISTRUC,IRES)
                  TSTRUC = ISTRUC
              ENDIF
 150      CONTINUE

C----     Store the consensus secondary structure type
          CONSST(IRES) = SECSTR(TSTRUC)

C----     Calculate the average Ooi value for this residue
          IF (NOOI(IRES).NE.0) THEN
              VALOOI(IRES) = VALOOI(IRES) / REAL(NOOI(IRES))
              VALOOI(IRES) = 100.0 * (OOIMAX - VALOOI(IRES))
     -            / (OOIMAX - OOIMIN)
              DO 180, IFILE = 1, NFILE
                  SAVOOI(IRES,IFILE)
     -                = 100.0 * (OOIMAX - SAVOOI(IRES,IFILE))
     -                / (OOIMAX - OOIMIN)
 180          CONTINUE
          ELSE
              VALOOI(IRES) = 0.0
          ENDIF
 200  CONTINUE

C---- Calculate mean values of the parameters
      DO 600, ICOL = 1, NQUALP
          MEAVAL(ICOL) = MEAVAL(ICOL) / REAL(NFILE)

C----     Determine which value will be used for the plot statistics
          STATVL(ICOL) = MEAVAL(ICOL)
          IF (PLSTAT.EQ.2) THEN
              IF (AVESTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,AVESTR)
              ELSE
                  PRINT*, '**** Warning. "A" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
          IF (PLSTAT.EQ.3) THEN
              IF (ENASTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,ENASTR)
              ELSE
                  PRINT*, '**** Warning. "E" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
          IF (PLSTAT.EQ.4) THEN
              IF (ASTSTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,ASTSTR)
              ELSE
                  PRINT*, '**** Warning. "*" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
 600  CONTINUE

C---- If not all resolutions are the same, then print warning message
      IF (.NOT.RESAME) THEN
          PRINT*
          PRINT*, '**** Warning. Resolution is not the same for all ',
     -        'files. Comparisons statistics will be '
          PRINT*, '**** calculated for minimum resolution:', RESMIN
          PRINT*
      ENDIF

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE GETRIN  -  Read in the information from the current .rin
C                        file
C     
C----------------------------------------------------------------------+---

      SUBROUTINE GETRIN(IFILE)

      SAVE
      
      INCLUDE 'mplot.inc'
      
      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

CHECK v.3.4-->
C      CHARACTER*1   INCHN, SECSTR
      CHARACTER*1   BRKCH, INCHN, SECSTR
CHECK v.3.4<--
      CHARACTER*3   RESDUE
      CHARACTER*5   SEQNO
      CHARACTER*6   SNO
      CHARACTER*9   SNOKEY
      INTEGER       IFILE, IPOS, IPROPT, IRES, ISTRUC, JPOS, JRES,
     -              LINE, LPOS, OOI1, OOI2, ORES, SERNO
CHECK v.3.4-->
C      LOGICAL       DUPLIC, FIRST
      LOGICAL       DUPLIC, FIRST, INRANG, WANTED
CHECK v.3.4<--
      REAL          CGAMB, CHI1, CHI2, CHI3, CHI4,
     -              DIHANG, DISULF, ENHB, MCBVAL, OMEGA, PHI, PSI,
     -              SCBVAL
      REAL          ALLOWP, GENERP, OUTSIP

C---- Initialise variables
      DO 100, IRES = 1, MXRES
          DO 50, IPROPT = 1, NPROPT
              VALUE(IPROPT,IRES,IFILE) = 999.9
 50       CONTINUE
 100  CONTINUE
      FIRST = .TRUE.
      IPOS = 0
      IRES = 0
      LINE = 0
      LPOS = 0
      ORES = NRES

C---- Open the corresponding .rin file
      OPEN(UNIT=4, FILE=FILRIN(IFILE), STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Loop through the records storing the required data
 300  CONTINUE

C----     Read in the data
CHECK v.3.4-->
C          READ(4,310,END=500,ERR=902) SERNO, RESDUE, INCHN, SEQNO,
C     -        SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4, ENHB,
C     -        DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
C 310      FORMAT(I4,A3,1X,A1,A5,A1,11F7.2,2F7.3,2I3)
          READ(4,310,END=500,ERR=902) SERNO, RESDUE, BRKCH, INCHN,
     -        SEQNO, SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4,
     -        ENHB, DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
 310      FORMAT(I4,A3,A1,A1,A5,A1,11F7.2,2F7.3,2I3)
CHECK v.3.4<--
          SNO = INCHN // SEQNO
          SNOKEY = SNO // RESDUE
          DUPLIC = .FALSE.
          LINE = LINE + 1

CHECK v.3.4-->
C----     Test whether the current residue is within one of the
C         user-defined ranges
          WANTED = INRANG(SEQNO,INCHN,RESFRM,RESTO,MAXRNG,NRANGE)

C----     Process this residue only if it is within the user-specified
C         ranges
          IF (WANTED) THEN
CHECK v.3.4<--

C----         Step to the next residue position
              IPOS = IPOS + 1
              IF (IPOS.GT.MXRES) GO TO 904

C----         If this is the first instance of this residue, then store
C             it and update the appropriate pointer
              IF (IPOS.GT.NRES) THEN
                  IRES = IPOS
                  IF (LPOS.GT.0) THEN
                      NXTRES(LPOS) = IPOS
                  ENDIF
                  LPOS = IPOS

C----         Otherwise, check whether have met this residue in a
C             previous .rin file
              ELSE
                  IRES = 0
                  DO 400, JPOS = 1, NRES

C----                 Get the pointer to the next residue
                      IF (JPOS.EQ.1) THEN
                          JRES = FSTRES
                      ELSE
                          JRES = NXTRES(JRES)
                      ENDIF

C----                 Check whether current residue fits in here
                      IF (SNOKEY.EQ.VALSNO(JRES)) THEN
                          IRES = JRES
                          LPOS = JRES
                          GO TO 410

C----                 If residue doesn't match exactly, see whether the
C                     residue number is right, but just the residue type
C                     that is different
                      ELSE
                          IF (SNOKEY(1:6).EQ.VALSNO(JRES)(1:6)) THEN
                              LPOS = JRES
                              DUPLIC = .TRUE.
                              DOUBL(JRES) = .TRUE.
                          ENDIF
                      ENDIF
 400              CONTINUE
 410              CONTINUE

C----             If existing slot has not been been found, then put
C                 residue at end of list and adjust pointers accordingly
C                 so that it "slots in" between the last matched residue
C                 and the one that follows it
                  IF (IRES.EQ.0) THEN
                      NRES = NRES + 1
                      IF (NRES.GT.MXRES) GO TO 904
                      IRES = NRES
                      IF (LPOS.EQ.0) THEN
                          NXTRES(IRES) = FSTRES
                          FSTRES = IRES
                      ELSE
                          NXTRES(IRES) = NXTRES(LPOS)
                          NXTRES(LPOS) = IRES
                      ENDIF
                      LPOS = IRES
                      IF (DUPLIC) DOUBL(IRES) = .TRUE.
                  ENDIF
              ENDIF

C----         Store the residue type and the required values for
C             plotting
              IF (IRES.GT.0) THEN

C----             Call the routine to accumulate all the mean-values
                  CALL MEANS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,
     -                CHI2,CHI3,ENHB,DISULF,DIHANG,OOI2,FIRST)

C----             Adjust Phi and Psi values
                  IF (PHI.LT.900.0) PHI = PHI + 180.0
                  IF (PSI.LT.900.0) PSI = PSI + 180.0

CHECK v.3.3.3-->
C----             Adjust chi1 and chi2 values
                  IF (RESDUE.EQ.'PRO') CHI1 = 999.9
                  IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
                  IF (CHI1.EQ.360.0) CHI1 = 0.0
                  IF (CHI2.LE.0.0) CHI2 = CHI2 + 360.0
CHECK v.3.3.3<--

CHECK v.3.4.3-->
C----             Adjust chi3, chi4 and omega values
                  IF (CHI3.LE.0.0) CHI3 = CHI3 + 360.0
                  IF (CHI3.EQ.360.0) CHI3 = 0.0
                  IF (CHI4.LE.0.0) CHI4 = CHI4 + 360.0
                  IF (CHI4.EQ.360.0) CHI4 = 0.0
                  IF (OMEGA.LE.0.0) OMEGA = OMEGA + 360.0
                  IF (OMEGA.EQ.360.0) OMEGA = 0.0
CHECK v.3.4.3<--

C----             Save the data that will be required for the distributions
                  VALUE(LOCPHI,IRES,IFILE) = PHI
                  VALUE(LOCPSI,IRES,IFILE) = PSI
                  VALUE(LOCHI1,IRES,IFILE) = CHI1
                  VALUE(LOCHI2,IRES,IFILE) = CHI2
                  VALUE(LOCOME,IRES,IFILE) = OMEGA
                  VALUE(LOCZET,IRES,IFILE) = DIHANG
CHECK v.3.4.3-->
                  VALUE(LOCHI3,IRES,IFILE) = CHI3
                  VALUE(LOCHI4,IRES,IFILE) = CHI4
CHECK v.3.4.3<--

C----             Save the residue ID
                  IF (VALRES(IRES).EQ.' ') VALRES(IRES) = RESDUE
                  VALSNO(IRES) = INCHN // SEQNO // RESDUE

C----             Mark this model as containing this residue
                  RESMOD(IRES,IFILE) = .TRUE.

C----             Save the Kabsch & Sander secondary structure definition
                  IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'G') THEN
                      ISTRUC = HELIX
                  ELSE IF (SECSTR.EQ.'E') THEN
                      ISTRUC = STRAND
                  ELSE IF (SECSTR.EQ.'=') THEN
                      ISTRUC = BLANK
                  ELSE
                      ISTRUC = COIL
                  ENDIF
                  IF (ISTRUC.NE.BLANK) THEN
                      SSTCNT(ISTRUC,IRES) = SSTCNT(ISTRUC,IRES) + 1
                  ENDIF
                  STOSST(IRES,IFILE) = SECSTR

CHECK v.3.4-->
C----             Store the chain break
                  IF (CHNBRK(IRES).EQ.' ') THEN
                      CHNBRK(IRES) = BRKCH
                  ENDIF
CHECK v.3.4<--

C----             Ooi number
                  VALOOI(IRES) = VALOOI(IRES) + OOI2
                  NOOI(IRES) = NOOI(IRES) + 1
                  SAVOOI(IRES,IFILE) = OOI2
              ENDIF
CHECK v.3.4-->
C----     Otherwise, if the residue is not wanted, mark the last-stored
C         residue as being at the end of a chain-break
          ELSE
              IF (IRES.GT.0) THEN
                  CHNBRK(IRES) = 'x'
              ENDIF
          ENDIF
CHECK v.3.4<--

C---- Loop back
      GO TO 300

C---- End of file reached
 500  CONTINUE

C---- Adjust the maximum and minimum sequence length
      IF (NRES.EQ.0) THEN
          NRES = IRES
      ENDIF
      IF (IPOS.GT.0) THEN
          IF (MAXLEN.EQ.0) THEN
              MINLEN = IPOS
              MAXLEN = IPOS
          ELSE
              MINLEN = MIN(IPOS,MINLEN)
              MAXLEN = MAX(IPOS,MAXLEN)
          ENDIF
      ENDIF

C---- Calculate percentages for residues in the different regions of the
C     Ramachandran plot
      IF (NONPG.GT.0) THEN
          ALLOWP = 100.0 * REAL(NALLOW) / REAL(NONPG)
          COREPC = 100.0 * REAL(NCORE) / REAL(NONPG)
          GENERP = 100.0 * REAL(NGENER) / REAL(NONPG)
          OUTSIP = 100.0 * REAL(NOUTSI) / REAL(NONPG)
      ELSE
          ALLOWP = 0.0
          COREPC = 0.0
          GENERP = 0.0
          OUTSIP = 0.0
      ENDIF

C---- Calculate the mean values of the various properties
      CALL CALCS

C---- Rewind the .rin file
      REWIND(4)
      LINE = 0

C---- Read through the residues a second time to accumulate standard
C     deviations
 600  CONTINUE

C----     Read in the data
CHECK v.3.4-->
C          READ(4,310,END=800,ERR=902) SERNO, RESDUE, INCHN, SEQNO,
C     -        SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4, ENHB,
C     -        DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
          READ(4,310,END=800,ERR=902) SERNO, RESDUE, BRKCH, INCHN,
     -        SEQNO, SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4,
     -        ENHB, DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
CHECK v.3.4<--
          LINE = LINE + 1

C----     Accumulate the data for calculation of standard deviations
          CALL STDEVS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,CHI2,
     -        CHI3,ENHB,DISULF,DIHANG)
      GO TO 600

C---- Calculate the standard deviations and store all the values
C     required for the Quality Plots
 800  CONTINUE
      CALL SCALCS(IFILE)

C---- Close the .rin file
      CLOSE(4)

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Unable to open .rin file:'
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 902  CONTINUE
      PRINT*, '*** Data error reading .rin file at line', LINE + 1
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 904  CONTINUE
      PRINT*, '*** Maximum number of residues exceeded:', MXRES
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 990  CONTINUE
      IFAIL = .TRUE.
 
 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE MEANS  -  Increment variables used for calculating means
C                       of properties for the current structure
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE MEANS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,CHI2,CHI3,
     -    ENHB,DISULF,DIHANG,OOI2,FIRST)

      INCLUDE 'mplot.inc'
 
      CHARACTER*1   INCHN, SECSTR
      CHARACTER*2   REGION
      CHARACTER*3   RESDUE

      INTEGER       OOI2, REGNO, REGTYP
      LOGICAL       DISALL, FIRST
      REAL          CHI1, CHI2, CHI3, DIHANG, DISULF, ENHB, OMEGA,
     -              PHI, PSI

C---- If the first time round, initialise variables
      IF (FIRST) THEN
          ACDEV = 0.0
          ACMEAN = 0.0
          ACSTD = 0.0
          CH2DEV = 0.0
          CH2MEA = 0.0
          CH2STD = 0.0
          C3LMEA = 0.0
          C3LSTD = 0.0
          C3RMEA = 0.0
          C3RSTD = 0.0
          GMIDEV = 0.0
          GMIMEA = 0.0
          GMISTD = 0.0
          GPLDEV = 0.0
          GPLMEA = 0.0
          GPLSTD = 0.0
          GTRDEV = 0.0
          GTRMEA = 0.0
          GTRSTD = 0.0
          HBDEV = 0.0
          HBMEAN = 0.0
          HBSTD = 0.0
          HPMEAN = 0.0
          HPSTD = 0.0
          NALPHC = 0
          NALLOW = 0
          NAROMA = 0
          NASN = 0
          NCORE = 0
          NCPOOL = 0
          NCHI2 = 0
          NCHI3L = 0
          NCHI3R = 0
          NCIS = 0
          NDAM = 0
          NDISUL = 0
          NENDCH = 0
          NGENER = 0
          NGLY = 0
          NGMINU = 0
          NGPLUS = 0
          NGTRAN = 0
          NHBOND = 0
          NHXPSI = 0
          NOMEGA = 0
          NONPG = 0
          NOUTSI = 0
          NPHIHX = 0
          NPRO = 0
          NPROPH = 0
          NRAMPL = 0
          OMDEV = 0.0
          OMSTD = 0.0
          OMMEAN = 0.0
CHECK v.3.3.1-->
C          OOIMAX = 0
C          OOIMIN = 999
CHECK v.3.3.1<--
          PHMEAN = 0.0
          PHSTD = 0.0
          SSMEAN = 0.0
          FIRST = .FALSE.
      ENDIF

C---- Only process this residue if it belongs to the required chain
      IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN

C----     Accumulate values for calculation of means

C----     Chi-1 torsion angle
          IF (RESDUE.EQ.'PRO') CHI1 = 999.9
          IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
          IF (CHI1.EQ.360.0) CHI1 = 0.0
          IF (CHI1.GE.0.0 .AND. CHI1.LT.360.0) THEN
              POOMEA = POOMEA + CHI1
              NCPOOL = NCPOOL + 1

C----         Chi-1 gauche minus
              IF (CHI1.GE.0.0 .AND. CHI1.LT.120.0) THEN
                  GMIMEA = GMIMEA + CHI1
                  GMIDEV = GMIDEV + (CHI1 - GLOBGM)
     -                * (CHI1 - GLOBGM)
                  NGMINU = NGMINU + 1
                  PINMAX(PLTCH1) = MAX(ABS(CHI1 - GLOBGM),
     -                PINMAX(PLTCH1))

C----         Chi-1 trans
              ELSE IF (CHI1.GE.120.0 .AND. CHI1.LT.240.0) THEN
                  GTRMEA = GTRMEA + CHI1
                  GTRDEV = GTRDEV + (CHI1 - GLOBGT)
     -                * (CHI1 - GLOBGT)
                  NGTRAN = NGTRAN + 1
                  PINMAX(PLTCH1) = MAX(ABS(CHI1 - GLOBGT),
     -                PINMAX(PLTCH1))

C----         Chi-1 gauche plus
              ELSE IF (CHI1.GE.240.0 .AND. CHI1.LT.360.0) THEN
                  GPLMEA = GPLMEA + CHI1
                  GPLDEV = GPLDEV + (CHI1 - GLOBGP)
     -                * (CHI1 - GLOBGP)
                  NGPLUS = NGPLUS + 1
                  PINMAX(PLTCH1) = MAX(ABS(CHI1 - GLOBGP),
     -                PINMAX(PLTCH1))
              ENDIF
          ENDIF

C----     Chi-2 trans torsion angle
          IF (RESDUE.NE.'PHE' .AND. RESDUE.NE.'TYR' .AND.
     -        RESDUE.NE.'TRP' .AND. RESDUE.NE.'HIS' .AND.
     -        RESDUE.NE.'ASP' .AND. RESDUE.NE.'ASN') THEN
              IF (CHI2.LE.0.0) CHI2 = CHI2 + 360.0
              IF (CHI2.GT.120.0 .AND. CHI2.LE.240.0) THEN
                  CH2MEA = CH2MEA + CHI2
                  CH2DEV = CH2DEV + (CHI2 - GLOBC2)
     -                * (CHI2 - GLOBC2)
                  NCHI2 = NCHI2 + 1
              ENDIF
          ENDIF

C----     Proline phi
          IF (RESDUE.EQ.'PRO' .AND. PHI.NE.999.9) THEN
              PPMEAN = PPMEAN + PHI
              NPROPH = NPROPH + 1
          ENDIF

C----     Phi helix
          IF (SECSTR.EQ.'H' .AND. PHI.NE.999.9) THEN
              PHMEAN = PHMEAN + PHI
              NPHIHX = NPHIHX + 1
          ENDIF

C----     Helix psi
          IF (SECSTR.EQ.'H' .AND. PSI.NE.999.9) THEN
              HPMEAN = HPMEAN + PSI
              NHXPSI = NHXPSI + 1
          ENDIF

C----     Chi-3 right-hand
          IF (RESDUE.EQ.'CYS' .AND. CHI3.GT.0.0 .AND.
     -        CHI3.LE.180.0) THEN
              C3RMEA = C3RMEA + CHI3
              NCHI3R = NCHI3R + 1
          ENDIF

C----     Chi-3 left-hand
          IF (RESDUE.EQ.'CYS' .AND. CHI3.LE.0.0 .AND.
     -        CHI3.GE.-180.0) THEN
              C3LMEA = C3LMEA + CHI3
              NCHI3L = NCHI3L + 1
          ENDIF

C----     Disulphide bond
          IF (RESDUE.EQ.'CYS') THEN
              IF (DISULF.NE.0.0) THEN
                  SSMEAN = SSMEAN + DISULF
                  NDISUL = NDISUL + 1
              ENDIF
          ENDIF

C----     Case of trans peptide (ie abs(omega) > 45) 
          IF (ABS(OMEGA).GE.45.0 .AND. OMEGA.NE.999.9) THEN
              IF (OMEGA.LE.0.0) OMEGA = OMEGA + 360.0
              OMMEAN = OMMEAN + OMEGA
              NOMEGA = NOMEGA + 1
              PINMAX(PLTOME) = MAX(ABS(OMEGA - GLOBOM),
     -            PINMAX(PLTOME))

C----     Case of cis peptide (ie abs(omega) < 45) 
          ELSE IF (ABS(OMEGA).LT.45.0 .AND. OMEGA.NE.999.9) THEN
              PINMAX(PLTOME) = MAX(ABS(OMEGA),PINMAX(PLTOME))
          ENDIF

C----     Hydrogen bond energy mean and standard deviation
          IF (ENHB.LT.0.0) THEN
              HBMEAN = HBMEAN + ENHB
              HBDEV = HBDEV + (ENHB - GLOBHB) * (ENHB - GLOBHB)
              NHBOND = NHBOND + 1
CXXX              PINMAX(PLTHB) = MAX(ABS(ENHB - GLOBHB),PINMAX(PLTHB))
          ENDIF

C----     Alpha-carbon tetrahedral chirality
          IF (DIHANG.LE.360.0) THEN
              ACMEAN = ACMEAN + DIHANG
              ACDEV = ACDEV + (DIHANG - GLOBDH) * (DIHANG - GLOBDH)
              NALPHC = NALPHC + 1
              PINMAX(PLTCAL) = MAX(ABS(DIHANG - GLOBDH),
     -            PINMAX(PLTCAL))
          ENDIF

C----     Ooi number
          OOIMIN = MIN(OOI2,OOIMIN)
          OOIMAX = MAX(OOI2,OOIMAX)

C----     Determine which region of Ramachandran plot residue lies
C         in 
          DISALL = .FALSE.
CHECK v.3.6-->
C         CALL RAMREG(PHI,PSI,REGION,IREG,REGTYP)
          IF (NEWREG) THEN
              CALL RAMNEW(PHI,PSI,REGION,REGNO,REGTYP) 
          ELSE
              CALL RAMREG(PHI,PSI,REGION,REGNO,REGTYP) 
          ENDIF
CHECK v.3.6<--

C----     If residue is neither a glycine nor a proline, then
C         determine in which region of the Ramachandran plot its
C         phi-psi values fall
          IF (RESDUE.NE.'GLY' .AND. RESDUE.NE.'PRO') THEN

C----         Check whether this is an end-residue at a chain break
              IF (PHI.EQ.999.9 .OR. PSI.EQ.999.9) THEN
                  NENDCH = NENDCH + 1

C----         If valid phi-psi, then determine region type
              ELSE
                  NONPG = NONPG + 1

C----             Increment counts of residues in each region type
                  IF (REGION.EQ.'XX') THEN
                      NOUTSI = NOUTSI + 1
                      DISALL = .TRUE.
                  ELSE IF (REGION.EQ.'B ' .OR. REGION.EQ.'A '
     -                .OR. REGION.EQ.'L ') THEN
                      NCORE = NCORE + 1
                  ELSE IF (REGION.EQ.'b ' .OR. REGION.EQ.'a '
     -                .OR. REGION.EQ.'l ' .OR. REGION.EQ.'p ') THEN
                      NALLOW = NALLOW + 1
                  ELSE IF (REGION.EQ.'~b' .OR. REGION.EQ.'~a'
     -                .OR. REGION.EQ.'~l' .OR. REGION.EQ.'~p') THEN
                      NGENER = NGENER + 1
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CALCS  -  Calculate means and the deviations from ideal
C                       values
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE CALCS

      INCLUDE 'mplot.inc'

C---- Calculate means and standard deviations

C---- Chi-1 torsion angle (gauche minus)
      IF (NGMINU.NE.0) THEN
          GMIMEA = GMIMEA / NGMINU
          IF (NGMINU.GT.1) THEN
              GMIDEV = SQRT(GMIDEV / (NGMINU - 1))
          ELSE
              GMIDEV = 0.0
          ENDIF
      ENDIF

C---- Chi-1 torsion angle (trans)
      IF (NGTRAN.NE.0) THEN
          GTRMEA = GTRMEA / NGTRAN
          IF (NGTRAN.GT.1) THEN
              GTRDEV = SQRT(GTRDEV / (NGTRAN - 1))
          ELSE
              GTRDEV = 0.0
          ENDIF
      ENDIF

C---- Chi-1 torsion angle (gauche plus)
      IF (NGPLUS.NE.0) THEN
          GPLMEA = GPLMEA / NGPLUS
          IF (NGPLUS.GT.1) THEN
              GPLDEV = SQRT(GPLDEV / (NGPLUS - 1))
          ELSE
              GPLDEV = 0.0
          ENDIF
      ENDIF

C---- Chi-1 torsion angle (pooled standard deviation)
      IF (NCPOOL.NE.0) THEN
          POOSTD = NGMINU * GMIDEV + NGTRAN * GTRDEV + NGPLUS * GPLDEV
          POOSTD = POOSTD / (NGMINU + NGTRAN + NGPLUS)
      ELSE
          POOSTD = 0.0
      ENDIF

C---- Chi-2 trans torsion angle
      IF (NCHI2.NE.0) THEN
          CH2MEA = CH2MEA / NCHI2
          IF (NCHI2.GT.1) THEN
              CH2DEV = SQRT(CH2DEV / (NCHI2 - 1))
          ELSE
              CH2DEV = 0.0
          ENDIF
      ENDIF

C---- Proline phi torsion angle
      IF (NPROPH.NE.0) THEN
          PPMEAN = PPMEAN / NPROPH
      ENDIF

C---- Phi torsion angle in helices
      IF (NPHIHX.NE.0) THEN
          PHMEAN = PHMEAN / NPHIHX
      ENDIF

C---- Helix psi torsion angle
      IF (NHXPSI.NE.0) THEN
          HPMEAN = HPMEAN / NHXPSI
      ENDIF

C---- Chi-3 torsion angle, right-handed
      IF (NCHI3R.NE.0) THEN
          C3RMEA = C3RMEA / NCHI3R
      ENDIF

C---- Chi-3 torsion angle, left-handed
      IF (NCHI3L.NE.0) THEN
          C3LMEA = C3LMEA / NCHI3L
      ENDIF

C---- Disulphide bond
      IF (NDISUL.NE.0) THEN
          SSMEAN = SSMEAN / NDISUL
      ENDIF

C---- Omega torsion angle
      IF (NOMEGA.NE.0) THEN
          OMMEAN = OMMEAN / NOMEGA
      ENDIF

C---- Hydrogen bond energy
      IF (NHBOND.NE.0) THEN
          HBMEAN = HBMEAN / NHBOND
          IF (NHBOND.GT.1) THEN
              HBDEV = SQRT(HBDEV / (NHBOND - 1))
          ELSE
              HBDEV = 0.0
          ENDIF
      ENDIF

C---- Alpha carbon tetrahedral distortion
      IF (NALPHC.NE.0) THEN
          ACMEAN = ACMEAN / NALPHC
          IF (NALPHC.GT.1) THEN
              ACDEV = SQRT(ACDEV / (NALPHC - 1))
          ELSE
              ACDEV = 0.0
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE STDEVS  -   Second pass through data file(s), calculating
C                         standard deviations
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE STDEVS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,CHI2,
     -    CHI3,ENHB,DISULF,DIHANG)

      INCLUDE 'mplot.inc'
 
      CHARACTER*1   INCHN, SECSTR
      CHARACTER*3   RESDUE
      REAL          CHI1, CHI2, CHI3, DIHANG, DISULF, ENHB,
     -              OMEGA, PHI, PSI


C---- Only process this residue if it belongs to the required chain
      IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN

C----     Accumulate figures for calculation of standard deviations

C----     Chi-1 torsion angle
          IF (RESDUE.EQ.'PRO') CHI1 = 999.9
          IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
          IF (CHI1.EQ.360.0) CHI1 = 0.0
          IF (CHI1.GE.0.0 .AND. CHI1.LT.360.0) THEN

C----         Chi-1 gauche minus
              IF (CHI1.GE.0.0 .AND. CHI1.LT.120.0) THEN
                  GMISTD = GMISTD + (CHI1 - GMIMEA)
     -                * (CHI1 - GMIMEA)

C----         Chi-1 trans
              ELSE IF (CHI1.GE.120.0 .AND. CHI1.LT.240.0) THEN
                  GTRSTD = GTRSTD + (CHI1 - GTRMEA)
     -                * (CHI1 - GTRMEA)

C----         Chi-1 gauche plus
              ELSE IF (CHI1.GE.240.0 .AND. CHI1.LT.360.0) THEN
                  GPLSTD = GPLSTD + (CHI1 - GPLMEA)
     -                * (CHI1 - GPLMEA)
              ENDIF
          ENDIF

C----     Chi-2 trans torsion angle
          IF (CHI2.LE.0.0) CHI2 = CHI2 + 360.0
          IF (RESDUE.NE.'PHE' .AND. RESDUE.NE.'TYR' .AND.
     -        RESDUE.NE.'TRP' .AND. RESDUE.NE.'HIS' .AND.
     -        RESDUE.NE.'ASP' .AND. RESDUE.NE.'ASN') THEN
              IF (CHI2.GT.120.0 .AND. CHI2.LE.240.0) THEN
                  CH2STD = CH2STD + (CHI2 - CH2MEA)
     -                * (CHI2 - CH2MEA)
              ENDIF
          ENDIF

C----     Proline phi
          IF (RESDUE.EQ.'PRO' .AND. PHI.NE.999.9) THEN
              PPSTD = PPSTD + (PHI - PPMEAN) * (PHI - PPMEAN)
          ENDIF

C----     Phi helix
          IF (SECSTR.EQ.'H' .AND. PHI.NE.999.9) THEN
              PHSTD = PHSTD + (PHI - PHMEAN) * (PHI - PHMEAN)
          ENDIF

C----     Helix psi
          IF (SECSTR.EQ.'H' .AND. PSI.NE.999.9) THEN
              HPSTD = HPSTD + (PSI - HPMEAN) * (PSI - HPMEAN)
          ENDIF

C----     Chi-3 right-hand
          IF (RESDUE.EQ.'CYS' .AND. CHI3.GT.0.0 .AND.
     -        CHI3.LE.180.0) THEN
              C3RSTD = C3RSTD + (CHI3 - C3RMEA) * (CHI3 - C3RMEA)
          ENDIF

C----     Chi-3 left-hand
          IF (RESDUE.EQ.'CYS' .AND. CHI3.LE.0.0 .AND.
     -        CHI3.GE.-180.0) THEN
              C3LSTD = C3LSTD + (CHI3 - C3LMEA) * (CHI3 - C3LMEA)
          ENDIF

C----     Disulphide bond
          IF (RESDUE.EQ.'CYS') THEN
              IF (DISULF.NE.0.0) THEN
                 SSSTD = SSSTD + (DISULF - SSMEAN)
     -               * (DISULF - SSMEAN)
              ENDIF
          ENDIF

C----     Omega torsion angle
          IF (ABS(OMEGA).GE.45.0 .AND. OMEGA.NE.999.9) THEN
              IF (OMEGA.LE.0.0) OMEGA = OMEGA + 360.0
              OMSTD = OMSTD + (OMEGA - OMMEAN) * (OMEGA - OMMEAN)
          ENDIF

C----     Hydrogen bond energy
          IF (ENHB.LT.0.0) THEN
              HBSTD = HBSTD + (ENHB - HBMEAN) * (ENHB - HBMEAN)
          ENDIF

C----     Alpha-carbon tetrahedral chirality
          IF (DIHANG.LE.360.0) THEN
              ACSTD = ACSTD + (DIHANG - ACMEAN) * (DIHANG - ACMEAN)
          ENDIF

C----     Plot this point on the Chi-1 vs Chi-2 plot
          IF (CHI1.NE.999.9 .AND. CHI2.NE.999.9) THEN
              NCHICH = NCHICH + 1
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SCALCS  -  Calculate standard deviations
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE SCALCS(IFILE)

      INCLUDE 'mplot.inc'
 
      INTEGER       IFILE

C---- Calculate means and standard deviations

C---- Chi-1 torsion angle (gauche minus)
      IF (NGMINU.GT.1) THEN
          GMISTD = SQRT(GMISTD / (NGMINU - 1))
      ELSE
          GMISTD = 999.9
      ENDIF

C---- Chi-1 torsion angle (trans)
      IF (NGTRAN.GT.1) THEN
          GTRSTD = SQRT(GTRSTD / (NGTRAN - 1))
      ELSE
          GTRSTD = 999.9
      ENDIF

C---- Chi-1 torsion angle (gauche plus)
      IF (NGPLUS.GT.1) THEN
          GPLSTD = SQRT(GPLSTD / (NGPLUS - 1))
      ELSE
          GPLSTD = 999.9
      ENDIF

C---- Chi-2 trans torsion angle
      IF (NCHI2.GT.1) THEN
          CH2STD = SQRT(CH2STD / (NCHI2 - 1))
      ELSE
          CH2STD = 999.9
      ENDIF

C---- Proline phi torsion angle
      IF (NPROPH.GT.1) THEN
          PPSTD = SQRT(PPSTD / (NPROPH - 1))
      ELSE
          PPSTD = 999.9
      ENDIF

C---- Phi torsion angle in helices
      IF (NPHIHX.GT.1) THEN
          PHSTD = SQRT(PHSTD / (NPHIHX - 1))
      ELSE
          PHSTD = 999.9
      ENDIF

C---- Helix psi torsion angle
      IF (NHXPSI.GT.1) THEN
          HPSTD = SQRT(HPSTD / (NHXPSI - 1))
      ELSE
          HPSTD = 999.9
      ENDIF

C---- Chi-3 torsion angle, right-handed
      IF (NCHI3R.GT.1) THEN
          C3RSTD = SQRT(C3RSTD / (NCHI3R - 1))
      ELSE
          C3RSTD = 999.9
      ENDIF

C---- Chi-3 torsion angle, left-handed
      IF (NCHI3L.GT.1) THEN
          C3LSTD = SQRT(C3LSTD / (NCHI3L - 1))
      ELSE
          C3LSTD = 999.9
      ENDIF

C---- Disulphide bond
      IF (NDISUL.GT.1) THEN
          SSSTD = SQRT(SSSTD / (NDISUL - 1))
      ELSE
          SSSTD = 999.9
      ENDIF

C---- Omega torsion angle
      IF (NOMEGA.GT.1) THEN
          OMSTD = SQRT(OMSTD / (NOMEGA - 1))
      ELSE
          OMSTD = 999.9
      ENDIF

C---- Hydrogen bond energy
      IF (NHBOND.GT.1) THEN
          HBSTD = SQRT(HBSTD / (NHBOND - 1))
      ELSE
          HBSTD = 999.9
      ENDIF

C---- Alpha carbon chirality
      IF (NALPHC.GT.1) THEN
          ACSTD = SQRT(ACSTD / (NALPHC - 1))
      ELSE
          ACSTD = 999.9
      ENDIF

C---- Store the values used in the stereochemical quality plots
      SVALUE(1,IFILE) = COREPC
      SVALUE(2,IFILE) = HBSTD
      SVALUE(3,IFILE) = POOSTD
      SVALUE(4,IFILE) = CH2STD
      NVALUE(1,IFILE) = NONPG
      NVALUE(2,IFILE) = NHBOND
      NVALUE(3,IFILE) = NGMINU + NGTRAN + NGPLUS
      NVALUE(4,IFILE) = NCHI2

      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C  SUBROUTINE GETMAX  -  Find the maximum frequency for the frequency
C                        distributions plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE GETMAX(IDISTR,NFILE)

      INCLUDE 'mplot.inc'

      INTEGER       BAR(NHIST), IDISTR, IFILE, IFREQ, IHIST, IPOS,
     -              IPROPT, IRANGE, IRES, NFILE

C---- Initialise variables
      IPROPT = IDISTR
      MAXFRQ = 0

C---- If plotting the distribution as an ensemble, have to loop through
C     all the residues to see which gives the highest histogram value
      IF (HISTOG) THEN

C----     Loop through all the residues
          DO 1000, IPOS = 1, NRES

C----         Get the pointer to the next residue
              IF (IPOS.EQ.1) THEN
                  IRES = FSTRES
              ELSE
                  IRES = NXTRES(IRES)
              ENDIF

C----         Zero the frequency counts for this residue
              DO 100, IHIST = 1, NHIST
                  BAR(IHIST) = 0
 100          CONTINUE

C----         Loop through all the values for this residue
              DO 500, IFILE = 1, NFILE
                  IF (VALUE(IPROPT,IRES,IFILE).LT.900.0) THEN

C----                 Determine which range the value falls into
                      IRANGE = VALUE(IPROPT,IRES,IFILE) / DANGLE + 1
                      IF (IRANGE.LT.1) IRANGE = 1
                      IF (IRANGE.GT.NHIST) IRANGE = NHIST
                      BAR(IRANGE) = BAR(IRANGE) + 1
                  ENDIF
 500          CONTINUE

C----         Loop through all the accumulated frequencies to determine
C             the maximum
              DO 800, IHIST = 1, NHIST
                  MAXFRQ = MAX(BAR(IHIST),MAXFRQ)
 800          CONTINUE
 1000     CONTINUE

C---- Otherwise, if the plots are progressions, then maximum value
C     is just the number of structures in the ensemble
      ELSE
CHECK v.3.4-->
C          MAXFRQ = NFILE
          MAXFRQ = NMODEL
CHECK v.3.4<--
      ENDIF

C---- Adjust the maximum frequency for plotting
      MAXFRQ = REAL(MAXFRQ) * 1.2
      IFREQ = 1000
      IF (MAXFRQ.LT.1000) IFREQ = 1000
      IF (MAXFRQ.LT.500) IFREQ = 500
      IF (MAXFRQ.LT.250) IFREQ = 250
      IF (MAXFRQ.LT.200) IFREQ = 200
      IF (MAXFRQ.LT.150) IFREQ = 150
      IF (MAXFRQ.LT.125) IFREQ = 125
      IF (MAXFRQ.LT.100) IFREQ = 100
      IF (MAXFRQ.LT.75) IFREQ = 75
      IF (MAXFRQ.LT.60) IFREQ = 60
      IF (MAXFRQ.LT.50) IFREQ = 50
      IF (MAXFRQ.LT.40) IFREQ = 40
      IF (MAXFRQ.LT.35) IFREQ = 35
      IF (MAXFRQ.LT.30) IFREQ = 30
      IF (MAXFRQ.LT.25) IFREQ = 25
      IF (MAXFRQ.LT.20) IFREQ = 20
      IF (MAXFRQ.LT.15) IFREQ = 15
      IF (MAXFRQ.LT.10) IFREQ = 10
      IF (MAXFRQ.LT.5) IFREQ = 5
      MAXFRQ = IFREQ

      RETURN
      END

C----------------------------------------------------------------------+--- 
CHECK v.3.4.3-->
C**************************************************************************
C
C  SUBROUTINE CALCRG  -  Calculate the torsion-angle G-factors for each
C                        residue
C
C----------------------------------------------------------------------+--- 

CHECK v.3.5.2-->
C      SUBROUTINE CALCRG(IDISTR,NFILE)
      SUBROUTINE CALCRG(IDISTR,NFILE,ENERGY,NCELL1,NCELL2)
CHECK v.3.5.2<--

      INCLUDE 'mplot.inc'

CHECK v.3.5.2-->
C      INTEGER      NFILE
      INTEGER      NFILE, NCELL1, NCELL2
CHECK v.3.5.2<--

      CHARACTER*3  RESDUE
      INTEGER      I, IAMINO, IDISTR, IDPOS, IFILE, IPOS, IPROP1,
     -             IPROP2, IRES, NSCORE
      LOGICAL      STORIT, VALOK
CHECK v.3.5.2-->
C      REAL         ANGLE1, ANGLE2, CALC1D, CALC2D, MEANSC, SC
      REAL         ANGLE1, ANGLE2, CALC1D, CALC2D,
     -             ENERGY(NCELL1,NCELL2,NAMINO+1), MEANSC, SC
CHECK v.3.5.2<--

C---- Initialise variables
      ANGLE1 = 0.0
      ANGLE2 = 0.0
      IF (IDISTR.EQ.1) THEN
          IPROP1 = LOCPHI
          IPROP2 = LOCPSI
          TWODEE = .TRUE.
      ELSE IF (IDISTR.EQ.2) THEN
          IPROP1 = LOCHI1
          IPROP2 = LOCHI2
          TWODEE = .TRUE.
      ELSE IF (IDISTR.EQ.3) THEN
          IPROP1 = LOCHI1
          IPROP2 = 0
          TWODEE = .FALSE.
      ELSE IF (IDISTR.EQ.4) THEN
          IPROP1 = LOCHI3
          IPROP2 = 0
          TWODEE = .FALSE.
      ELSE IF (IDISTR.EQ.5) THEN
          IPROP1 = LOCHI4
          IPROP2 = 0
          TWODEE = .FALSE.
      ELSE IF (IDISTR.EQ.6) THEN
          IPROP1 = LOCOME
          IPROP2 = 0
          TWODEE = .FALSE.
      ENDIF

C---- Loop through the residues and get the G-factors
      DO 1000, IPOS = 1, NRES

C----     Get the pointer to the next residue
          IF (IPOS.EQ.1) THEN
              IRES = FSTRES
          ELSE
              IRES = NXTRES(IRES)
          ENDIF

C----     Get residue name and decide whether residue has a chi-2
          RESDUE = VALSNO(IRES)(7:9)
          IF (RESDUE.EQ.'ALA' .OR. RESDUE.EQ.'GLY' .OR.
     -        RESDUE.EQ.'PRO' .OR. RESDUE.EQ.'SER' .OR.
     -        RESDUE.EQ.'THR' .OR. RESDUE.EQ.'VAL') THEN
              STORIT = .TRUE.
          ELSE

C----         If this distribution is a Chi-1 distrib, then as this
C             residue type is represented on the Chi1-chi2 distrib
C             then don't need to store the Chi-1 contribution to the
C             G-factors
              IF (IDISTR.EQ.3) THEN
                  STORIT = .FALSE.
              ELSE
                  STORIT = .TRUE.
              ENDIF
          ENDIF

C----     Determine the amino-acid type
          IAMINO = 0
          DO 100, I = 1, NAMINO
              IF (VALRES(IRES).EQ.AMINO(I)) IAMINO = I
 100      CONTINUE

C----     Initialise variables for calculation of G-factor scores for
C         this residue
          MEANSC = 0.0
          NSCORE = 0

C----     Determine whether this residue-type has a value corresponding to
C         this torsion angle
          DO 200, IFILE = 1, NFILE

C----         Process only if this is one of the selected models
              IF (MWANT(IFILE)) THEN

C----             Calculate the G-factor for this point
                  IF (IAMINO.GT.0) THEN

C----                 Check that the value is within the bounds
                      ANGLE1 = VALUE(IPROP1,IRES,IFILE)
                      IF (ANGLE1.GE.VALBEG(1) .AND.
     -                    ANGLE1.LE.VALEND(1)) THEN
                          IF (TWODEE) THEN
                              ANGLE2 = VALUE(IPROP2,IRES,IFILE)
                              IF (ANGLE2.GE.VALBEG(2) .AND.
     -                            ANGLE2.LE.VALEND(2)) THEN
                                  VALOK = .TRUE.
                              ELSE
                                  VALOK = .FALSE.
                              ENDIF
                          ELSE
                              VALOK = .TRUE.
                          ENDIF
                      ELSE
                          VALOK = .FALSE.
                      ENDIF

C----                 If falls within plot area, then calculate G-factor
                      IF (VALOK) THEN

C----                     Calculate the log-odds score for this value
                          IF (TWODEE) THEN
CHECK v.3.5.2-->
C                              SC = CALC2D(IAMINO,ANGLE1,ANGLE2,
C     -                            NAMINO,NCELL,ENERGY,STEP,VALBEG)
                              SC = CALC2D(IAMINO,ANGLE1,ANGLE2,NAMINO,
     -                            NCELL1,NCELL2,ENERGY,STEP,VALBEG)
CHECK v.3.5.2<--
                          ELSE
CHECK v.3.5.2-->
C                              SC = CALC1D(IAMINO,ANGLE1,NAMINO,
C     -                            NCELL,NCELL1,ENERGY,STEP,VALBEG)
                              SC = CALC1D(IAMINO,ANGLE1,NAMINO,
     -                            NCELL1,ENERGY,STEP,VALBEG)
CHECK v.3.5.2<--
                          ENDIF

C----                     Apply normalisation factor to the score
                          IF (SC.NE.0.0 .AND.
     -                        NRMSTD(IAMINO).NE.0.0) THEN
                              SC = (SC - NRMEAN(IAMINO))
     -                            / NRMSTD(IAMINO)
                          ELSE
                              SC = 999.99
                          ENDIF
                      ELSE
                          SC = 999.99
                      ENDIF

C----                 Accumulate mean G-factor scores for this residue
                      IF (SC.LT.900.0) THEN
                          MEANSC = MEANSC + SC
                          NSCORE = NSCORE + 1
                      ENDIF    

C----                 Combine chi-3 and chi-4 scores together,
C                     and move omega distribution back one position
                      IF (STORIT .AND. SC.LT.900.0) THEN
                          IF (IDISTR.GT.4) THEN
                              IDPOS = IDISTR - 1
                          ELSE
                              IDPOS = IDISTR
                          ENDIF
                          SCOMOD(IDPOS,IRES,IFILE)
     -                        = SCOMOD(IDPOS,IRES,IFILE) + SC
                          NUMSCO(IDPOS,IRES,IFILE)
     -                        = NUMSCO(IDPOS,IRES,IFILE) + 1
                      ENDIF    
                  ENDIF
              ENDIF
 200      CONTINUE

C----     Calculate mean G-factor score for this residue
          IF (NSCORE.GT.0) THEN
              MEANSC = MEANSC / REAL(NSCORE)
          ELSE
              MEANSC = 999.9
          ENDIF
          GFACT(IDISTR,IRES) = MEANSC
 1000 CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4.3<--
C**************************************************************************
C
C  SUBROUTINE FRQPLT  -  Plot the frequency distribution and 2D plots
C                        for the ensemble's torsion angles
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE FRQPLT(IDISTR,GDISTR,NFILE)

      INCLUDE 'mplot.inc'

      CHARACTER*3  RESDUE
CHECK v.3.4.3-->
C      INTEGER      GDISTR, I, IACROS, IAMINO, ICROSS, IDISTR, IDOWN,
C     -             IFILE, IPAGE, IPOS, IPROP1, IPROP2, IRES, ITORX,
C     -             ITORY, MAPSIZ, NANGLE, NDWN, NFILE, NSCORE, NSHAD
      INTEGER      GDISTR, I, IACROS, IAMINO, ICROSS, IDISTR, IDOWN,
     -             IFILE, IPAGE, IPOS, IPROP1, IPROP2, IRES,
     -             ITORX, ITORY, MAPSIZ, NANGLE, NDWN, NFILE, NSHAD
CHECK v.3.4.3<--
      LOGICAL      FIRST, LAST, NOVALS, NOEND, NUMBEX, NUMBEY, OFFBOT,
CHECK v.3.4.3-->
C     -             OFFLFT, OFFRT, OFFTOP, SHADOK, STORIT, VALOK, XOK,
C     -             YOK, ZEROS
     -             OFFLFT, OFFRT, OFFTOP, SHADOK, STORIT, XOK, YOK,
     -             ZEROS
CHECK v.3.4.3<--
CHECK v.3.4.3-->
C      REAL         ADD, ANGBEG, ANGEND, ANGLE1, ANGLE2, CALC1D, CALC2D,
C     -             CIRVAR, CROSHT, DIST, KEYPSX, KEYPSY, MEANSC, MKSZ,
C     -             PGAP, PI, RADDEG, RCOMP, SC, SCALEX, SCALEY, SCOMP,
C     -             SCORE(MXFILE), SHADE, SWAP, TCOMP, UCOMP, X, XL,
      REAL         ADD, ANGBEG, ANGEND, ANGLE1, ANGLE2, CIRVAR, CROSHT,
     -             DIST, KEYPSX, KEYPSY, MEANSC, MKSZ, PGAP, PI,
     -             RADDEG, RCOMP, SCALEX, SCALEY, SCOMP,
     -             SHADE, SWAP, TCOMP, UCOMP, X, XL,
CHECK v.3.4.3<--
     -             XMAX, XR, XSTART,  XWID, X1, X2, Y, YB, YBEG, YEND,
     -             YHIGHT, YLIGHT, YMIN, YT, YTOP, YTOPMG, YWID,
     -             YWIDTH, Y1, Y2

      PARAMETER   (MAPSIZ = 36)
      PARAMETER   (MKSZ = 3.0, PI = 3.141592654, RADDEG = 180.0 / PI)

C---- Initialise variables
      IACROS = NACROS
      FIRST = .TRUE.
      LAST = .FALSE.
      IF (TWODEE) THEN
          NDWN = NDOWN2
          NFGAPY = 6
          IF (IDISTR.EQ.5) THEN
              IPROP1 = LOCPHI
              IPROP2 = LOCPSI
              YBEG = -180.0
              YEND = 180.0
              ADD = 180.0
              ITORX = 1
              ITORY = 2
          ELSE
              IPROP1 = LOCHI1
              IPROP2 = LOCHI2
              YBEG = 0.0
              YEND = 360.0
              ADD = 0.0
              ITORX = 3
              ITORY = 0
          ENDIF
          YLIGHT = YDAYL2
          YTOPMG = YFQTM2
          YWIDTH = YFQWD2
      ELSE
          IPROP1 = IDISTR
          IPROP2 = 0
          NDWN = NDOWN
          NFGAPY = 5
          YBEG = 0.0
          YEND = REAL(MAXFRQ)
          YLIGHT = YDAYLT
          YTOPMG = YFQTMG
          YWIDTH = YFQWID
          ADD = 180.0
          ITORX = IDISTR
          ITORY = 0
          IF (IDISTR.EQ.3) ADD = 0.0
CHECK v.3.4-->
C          IF (IDISTR.EQ.4) ITORX = 0
          IF (IDISTR.EQ.4) ADD = 0.0
CHECK v.3.4<--
      ENDIF
      IDOWN = NDWN
      IPAGE = 0
      NSHAD = 0
      NTICKX = 7
      NUMBEY = .TRUE.
      SCALEX = XFQWID / 360.0
      SCALEY = (YFQWD2 - YDAYL2) / 360.0
      XSTART = BBOXX1 + XFQLMG
      YTOP = BBOXY2 - YTOPMG
      KEYPSX = XSTART + NACROS * XFQWID + 6.0 * MKSZ
      KEYPSY = YTOP - MKSZ
      IF (IDISTR.EQ.3 .OR. IDISTR.EQ.4 .OR. IDISTR.EQ.6) THEN
          ANGBEG = 0.0
          ANGEND = 360.0
      ELSE
          ANGBEG = -180.0
          ANGEND = 180.0
      ENDIF

C---- Loop through the residues
      DO 1000, IPOS = 1, NRES

C----     Get the pointer to the next residue
          IF (IPOS.EQ.1) THEN
              IRES = FSTRES
          ELSE
              IRES = NXTRES(IRES)
          ENDIF

C----     Get residue name and decide whether residue has a chi-2
          RESDUE = VALSNO(IRES)(7:9)
          IF (RESDUE.EQ.'ALA' .OR. RESDUE.EQ.'GLY' .OR.
     -        RESDUE.EQ.'PRO' .OR. RESDUE.EQ.'SER' .OR.
     -        RESDUE.EQ.'THR' .OR. RESDUE.EQ.'VAL') THEN
              STORIT = .TRUE.
          ELSE

C----         If this distribution is a Chi-1 distrib, then as this
C             residue type is represented on the Chi1-chi2 distrib
C             then don't need to store the Chi-1 contribution to the
C             G-factors
              IF (IDISTR.EQ.3) THEN
                  STORIT = .FALSE.
              ELSE
                  STORIT = .TRUE.
              ENDIF
          ENDIF

C----     Determine the amino-acid type
          IAMINO = 0
          DO 100, I = 1, NAMINO
              IF (VALRES(IRES).EQ.AMINO(I)) IAMINO = I
 100      CONTINUE

C----     Initialise circular variance accumulators
          NANGLE = 0
          RCOMP = 0.0
          SCOMP = 0.0
          TCOMP = 0.0
          UCOMP = 0.0

C----     Initialise variables for calculation of G-factor scores for
C         this residue
          MEANSC = 0.0
CHECK v.3.4.3-->
C          NSCORE = 0
CHECK v.3.4.3<--

C----     Determine whether this residue-type has any values to be
C         plotted, and calculate its "circular variance"
          NOVALS = .TRUE.
          DO 200, IFILE = 1, NFILE

CHECK v.3.4-->
C----         Process only if this is one of the selected models
              IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----             Retrieve the angle/two angles for calculating circular
C                 variance
                  ANGLE1 = VALUE(IPROP1,IRES,IFILE)
                  IF (TWODEE) THEN
                      ANGLE2 = VALUE(IPROP2,IRES,IFILE)
                  ELSE
                      ANGLE2 = 0.0
                  ENDIF

C----             Check whether have a valid value/pair of values
                  IF (ANGLE1.LT.900.0 .AND. ANGLE2.LT.900.0) THEN
                      NOVALS = .FALSE.

C----                 Calculate the x-, y-, and z-components of the vector
C                     representing the current value/pair of values, and
C                     add onto the accumulating vector sum
                      ANGLE1 = ANGLE1 / RADDEG
                      ANGLE2 = ANGLE2 / RADDEG
                      RCOMP = RCOMP + COS(ANGLE1)
                      SCOMP = SCOMP + SIN(ANGLE1)
                      IF (TWODEE) THEN
                          TCOMP = TCOMP + COS(ANGLE2)
                          UCOMP = UCOMP + SIN(ANGLE2)
                      ENDIF
                      NANGLE = NANGLE + 1

CHECK v.3.4.3-->
CC----                 Calculate the G-factor for this point, if have a
CC                     G-factor distribution
C                      IF (HAVEG .AND. IAMINO.GT.0) THEN
C
CC----                     Check that the value is within the bounds
C                          ANGLE1 = VALUE(IPROP1,IRES,IFILE)
C                          IF (ANGLE1.GE.VALBEG(1) .AND.
C     -                        ANGLE1.LE.VALEND(1)) THEN
C                              IF (TWODEE) THEN
C                                  ANGLE2 = VALUE(IPROP2,IRES,IFILE)
C                                  IF (ANGLE2.GE.VALBEG(2) .AND.
C     -                                ANGLE2.LE.VALEND(2)) THEN
C                                      VALOK = .TRUE.
C                                  ELSE
C                                      VALOK = .FALSE.
C                                  ENDIF
C                              ELSE
C                                  VALOK = .TRUE.
C                              ENDIF
C                          ELSE
C                              VALOK = .FALSE.
C                          ENDIF
C
CC----                     If falls within plot area, then calculate G-factor
C                          IF (VALOK) THEN
C
CC----                         Calculate the log-odds score for this value
C                              IF (TWODEE) THEN
C                                  SC = CALC2D(IAMINO,ANGLE1,ANGLE2)
C                              ELSE
C                                  SC = CALC1D(IAMINO,ANGLE1)
C                              ENDIF
C
CC----                         Apply normalisation factor to the score
C                              IF (SC.NE.0.0 .AND.
C     -                            NRMSTD(IAMINO).NE.0.0) THEN
C                                  SC = (SC - NRMEAN(IAMINO))
C     -                                / NRMSTD(IAMINO)
C                              ELSE
C                                  SC = 999.99
C                              ENDIF
C                          ENDIF
C
CC----                     Accumulate mean G-factor scores for this residue
C                          SCORE(IFILE) = SC
C                          IF (SC.LT.900.0) THEN
C                              MEANSC = MEANSC + SC
C                              NSCORE = NSCORE + 1
C                              SCOMOD(IRES,IFILE) = SCOMOD(IRES,IFILE)
C     -                            + SC
C                              NUMSCO(IRES,IFILE) = NUMSCO(IRES,IFILE)
C     -                            + 1
C
C                          ENDIF    
C                      ENDIF
CHECK v.3.4.3<--
                  ENDIF
CHECK v.3.4-->
              ENDIF
CHECK v.3.4<--
 200      CONTINUE

C----     Calculate the circular variance for this property for this
C         residue
          IF (NANGLE.GT.0) THEN
              DIST = SQRT(RCOMP * RCOMP + SCOMP * SCOMP
     -            + TCOMP * TCOMP + UCOMP * UCOMP) / NANGLE
              IF (TWODEE) DIST = DIST / SQRT(2.0)
              CIRVAR = 1.0 - DIST
CHECK v.3.4-->
              IF (CIRVAR.LT.0.0) CIRVAR = 0.0
CHECK v.3.4<--
          ELSE
              CIRVAR = 999.9
          ENDIF
          CIRCVR(IDISTR,IRES) = CIRVAR

CHECK v.3.4.3-->
CC----     Calculate mean G-factor score for this residue
C          IF (HAVEG) THEN
C              IF (NSCORE.GT.0) THEN
C                  MEANSC = MEANSC / REAL(NSCORE)
C              ELSE
C                  MEANSC = 999.9
C              ENDIF
C              GFACT(GDISTR,IRES) = MEANSC
C          ENDIF
C----      Retrieve this residue's mean G-factor
           IF (GDISTR.NE.0) THEN
               MEANSC = GFACT(GDISTR,IRES)
           ELSE
               MEANSC = 999.99
           ENDIF
CHECK v.3.4.3<--

C----     If plotting this distribution, then increment graph and
C         produce page headings/tails, as required
CHECK v.3.3-->
C          IF (PLOTDS(IDISTR)) THEN
CHECK v.3.4-->
C          IF (PLOTDS(IDISTR) .AND. CIRVAR.GT.CVCUT .AND.
          IF (PLOTDS(IDISTR) .AND. CIRVAR.GE.CVCUT .AND.
CHECK v.3.4<--
     -        CIRVAR.LT.900.0) THEN
CHECK v.3.3<--

CHECK v.3.3--> (moved)
C----         Increment graph-count
              IACROS = IACROS + 1
              IF (IACROS.GT.NACROS) THEN
                  IDOWN = IDOWN + 1

C----             If off the end of the page, start a new one
                  IF (IDOWN.GT.NDWN) THEN

C----                 If this is not the first page, then finish off
C                     previous page
                      IF (IPAGE.GT.0) THEN

C----                     Print key for model numbers
                          IF (ENSEMB) THEN
                              CALL FILKEY(KEYPSX,KEYPSY,MKSZ,MKSZ,
     -                            8.0,5.0,NFILE)
                          ENDIF
                          CALL FRQEND(IDISTR,XSTART,XMAX,YMIN,YTOP,
     -                        NSHAD,LAST)
                      ENDIF

C----                 Open new PostScript file and print headings
                      CALL FRQHED(IDISTR,IPAGE,IRES,FIRST)
                      FIRST = .FALSE.
                      IDOWN = 1
                      NSHAD = 0
                      NUMBEX = .FALSE.
                      XMAX = XSTART
                      YMIN = YTOP
                  ENDIF
                  IACROS = 1
                  NUMBEY = .TRUE.
              ENDIF

C----         Calculate graph position
              XL = XSTART + (IACROS - 1) * XFQWID
              XR = XL + XFQWID
              YT = YTOP - (IDOWN - 1) * YWIDTH
              YB = YT - YWIDTH + YLIGHT
              XMAX = MAX(XR,XMAX)
              YMIN = MIN(YB,YMIN)
CHECK v.3.3<--

C----         Draw in the shading for this graph
              CALL PSLWID(0.1)
              IF (NOVALS) THEN
                  CALL PSDASH(2)
                  CALL PSLINE(XL,YB,XL,YT)
                  CALL PSLINE(XL,YT,XR,YT)
                  CALL PSLINE(XR,YT,XR,YB)
                  CALL PSLINE(XR,YB,XL,YB)
                  CALL PSDASH(0)
              ELSE IF (BSHADE(IDISTR)) THEN
                  SHADE = 0.996
                  CALL PSHADE(SHADE,COLPLT(2,IDISTR),RGB,MXCOLR,
     -                INCOLR(IDISTR))
                  CALL PSBBOX(XL,YB,XL,YT,XR,YT,XR,YB)
              ENDIF

C----         Shade in restraint region
              IF (.NOT.NOVALS) THEN

C----             If there is a dihedral angle restraint on this
C                 residue, show the restraint region in a darker
C                 shade
                  X1 = XL
                  X2 = XR
                  Y1 = YB
                  Y2 = YT
                  XOK = .TRUE.
                  YOK = .TRUE.
                  IF (ITORX.NE.0) THEN
                      IF (DIHCON(1,ITORX,IRES).LT.900.0) THEN
                          X1 = XL + (XR - XL)
     -                        * (DIHCON(1,ITORX,IRES) + ADD)
     -                        / 360.0
                          X2 = XL + (XR - XL)
     -                        * (DIHCON(2,ITORX,IRES) + ADD)
     -                         / 360.0
                      ELSE
                          XOK = .FALSE.
                      ENDIF
                  ENDIF
                  IF (ITORY.NE.0) THEN
                      IF (DIHCON(1,ITORY,IRES).LT.900.0) THEN
                          Y1 = YB + (YT - YB)
     -                        * (DIHCON(1,ITORY,IRES) + ADD)
     -                        / 360.0
                          Y2 = YB + (YT - YB)
     -                        * (DIHCON(2,ITORY,IRES) + ADD)
     -                        / 360.0
                      ELSE
                          YOK = .FALSE.
                      ENDIF
                  ENDIF

C----             Determine whether to print the shading
                  SHADOK = .TRUE.
                  IF (ITORX.EQ.0 .AND. ITORY.EQ.0) THEN
                      SHADOK = .FALSE.
                  ELSE IF (ITORX.NE.0 .AND. ITORY.EQ.0) THEN
                      IF (.NOT.XOK) SHADOK = .FALSE.
                  ELSE IF (ITORX.EQ.0 .AND. ITORY.NE.0) THEN
                      IF (.NOT.YOK) SHADOK = .FALSE.
                  ELSE
                      IF (.NOT.XOK .AND. .NOT.YOK) THEN
                          SHADOK = .FALSE.
                      ENDIF
                  ENDIF

C----             Print the shaded area corresponding to the
C                 restraint
                  IF (SHADOK) THEN
                      IF (TWODEE) THEN
                          SHADE = 0.85
                      ELSE
                          SHADE = 0.9
                      ENDIF

C----                 Swap x- and y-coords if necessary to make
C                     sure lower one is first
                      IF (X1.GT.X2) THEN
                          SWAP = X1
                          X1 = X2
                          X2 = SWAP
                      ENDIF
                      IF (Y1.GT.Y2) THEN
                          SWAP = Y1
                          Y1 = Y2
                          Y2 = SWAP
                      ENDIF

C----                 Check if shaded area falls outside bounds
C                     of plot area at all
                      OFFLFT = .FALSE.
                      OFFRT = .FALSE.
                      OFFTOP = .FALSE.
                      OFFBOT = .FALSE.
                      IF (X1.LT.XL) OFFLFT = .TRUE.
                      IF (X2.GT.XR) OFFRT = .TRUE.
                      IF (Y1.LT.YB) OFFBOT = .TRUE.
                      IF (Y2.GT.YT) OFFTOP = .TRUE.
                      YHIGHT = YT - YB

C----                 If off top-left, print in bottom-right
                      IF (OFFLFT .AND. OFFTOP) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(X1 + XFQWID,YB,
     -                                X1 + XFQWID,Y2 - YHIGHT,
     -                                XR,Y2 - YHIGHT,
     -                                XR,YB)

C----                 If off top-right, print in bottom-left
                      ELSE IF (OFFRT .AND. OFFTOP) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(XL,YB,
     -                                XL,Y2 - YHIGHT,
     -                                X2 - XFQWID,Y2 - YHIGHT,
     -                                X2 - XFQWID,YB)

C----                 If off bottom-left, print in top-right
                      ELSE IF (OFFLFT .AND. OFFBOT) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(X1 + XFQWID,Y1 + YHIGHT,
     -                                X1 + XFQWID,YT,
     -                                XR,YT,
     -                                XR,Y1 + YHIGHT)

C----                 If off bottom-right, print in top-left
                      ELSE IF (OFFRT .AND. OFFBOT) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(XL,Y1 + YHIGHT,
     -                                XL,YT,
     -                                X2 - XFQWID,YT,
     -                                X2 - XFQWID,Y1 + YHIGHT)
                      ENDIF

C----                 If off left, then print on right
                      IF (OFFLFT) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(X1 + XFQWID,MAX(Y1,YB),
     -                                X1 + XFQWID,MIN(Y2,YT),
     -                                XR,MIN(Y2,YT),
     -                                XR,MAX(Y1,YB))
                      ENDIF

C----                 If off right, then print on left
                      IF (OFFRT) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(XL,MAX(Y1,YB),
     -                                XL,MIN(Y2,YT),
     -                                X2 - XFQWID,MIN(Y2,YT),
     -                                X2 - XFQWID,MAX(Y1,YB))
                      ENDIF

C----                 If off top, then print on bottom
                      IF (OFFTOP) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(MAX(X1,XL),YB,
     -                                MAX(X1,XL),Y2 - YHIGHT,
     -                                MIN(X2,XR),Y2 - YHIGHT,
     -                                MIN(X2,XR),YB)
                      ENDIF

C----                 If off bottom, then print on top
                      IF (OFFBOT) THEN
                          CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                        MXCOLR,INCOLR(IDISTR))
                          CALL PSUBOX(MAX(X1,XL),Y1 + YHIGHT,
     -                                MAX(X1,XL),YT,
     -                                MIN(X2,XR),YT,
     -                                MIN(X2,XR),Y1 + YHIGHT)
                      ENDIF

C----                 Shade in the box that's within the graph
                      CALL PSHADE(SHADE,COLPLT(3,IDISTR),RGB,
     -                    MXCOLR,INCOLR(IDISTR))
                      CALL PSUBOX(MAX(X1,XL),MAX(Y1,YB),
     -                            MAX(X1,XL),MIN(Y2,YT),
     -                            MIN(X2,XR),MIN(Y2,YT),
     -                            MIN(X2,XR),MAX(Y1,YB))
                      NSHAD = NSHAD + 1
                  ENDIF
              ENDIF

C----         Determine whether the axes need to be numbered
              IF (IDOWN.EQ.NDWN .OR. NRES - IPOS.LT.NACROS)
     -            NUMBEX = .TRUE.
              ZEROS = .FALSE.
              IF (NUMBEX .AND. IACROS.EQ.1) ZEROS = .TRUE.
              NOEND = .TRUE.
              IF (IACROS.EQ.NACROS .OR. IPOS.EQ.NRES) 
     -            NOEND = .FALSE.

C----         Plot the axes
              IF (.NOT.NOVALS) THEN
                  CALL AXES(XL,XR,YB,YT,NTICKX - 1,NFGAPY,ANGBEG,
     -                ANGEND,YBEG,YEND,8.0,0,0,12.0,NUMBEX,NUMBEY,
     -                ZEROS,NOEND,.FALSE.)
                  NUMBEY = .FALSE.
              ENDIF

C----         If this is an ensemble Ramachandran plot, then draw in the
C             lines marking out the different regions
              IF (.NOT.NOVALS .AND. IDISTR.EQ.5) THEN

C----             Set the step-size for the "pixels" on the Ramachandran
C                 plot
                  PGAP = 360.0 / MAPSIZ
                  XWID = (XR - XL) / MAPSIZ
                  YWID = (YT - YB) / MAPSIZ

C----             Plot the lines defining the different regions
                  CALL RAMLIN(PGAP,XL,YB,XWID,YWID)
              ENDIF

C----         Highlight the gauche minus, trans and gauche plus
C             positions for plots involving Chi-1 and/or Chi-2
              IF (.NOT.NOVALS) THEN

C----             Lines parallel to y-axis
                  IF (IDISTR.EQ.3 .OR. IDISTR.EQ.4 .OR.
     -                IDISTR.EQ.6) THEN
                      DO 600, ICROSS = 60, 360, 120
                          X = XL + (XR - XL) * REAL(ICROSS) / 360.0
                          CROSHT = YT
                          IF (ICROSS.EQ.60)
     -                        CROSHT = YT - 0.20 * (YT - YB)
                          CALL PSLWID(0.1)
                          CALL PSDASH(4)
                          CALL PSLINE(X,YB,X,CROSHT)
                          CALL PSDASH(0)
 600                  CONTINUE
                  ENDIF

C----             Lines parallel to y-axis
                  IF (IDISTR.EQ.6) THEN
                      DO 700, ICROSS = 60, 360, 120
                          Y = YB + (YT - YB) * REAL(ICROSS) / 360.0
                          CALL PSLWID(0.1)
                          CALL PSDASH(4)
                          CALL PSLINE(XL,Y,XR,Y)
                          CALL PSDASH(0)
 700                  CONTINUE
                  ENDIF
              ENDIF

C----         Plot the frequency distribution for this residue
              CALL FRQGRF(IDISTR,IRES,XL,XR,YB,YT,SCALEX,SCALEY,
CHECK v.3.4.3-->
C     -            CIRVAR,SCORE,MEANSC,NFILE)
     -            CIRVAR,MEANSC,NFILE)
CHECK v.3.4.3<--
          ENDIF
 1000 CONTINUE

C---- Finish off the last page
      IF (PLOTDS(IDISTR) .AND. IPAGE.GT.0) THEN
          LAST = .TRUE.

C----     Print key for model numbers
          IF (ENSEMB) THEN
              CALL FILKEY(KEYPSX,KEYPSY,MKSZ,MKSZ,8.0,5.0,NFILE)
          ENDIF
          CALL FRQEND(IDISTR,XSTART,XMAX,YMIN,YTOP,NSHAD,LAST)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE FRQHED  -  Start new page for frequency distribution plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE FRQHED(IDISTR,IPAGE,IRES,FIRST)

      SAVE

      INCLUDE 'mplot.inc'

      CHARACTER*2   PAGENO
      CHARACTER*7   PAGE
      CHARACTER*9   HANAME(NDISTR), PLHAND
      CHARACTER*30  DNAME(NDISTR), PLDESC
      CHARACTER*48  GTITLE(NDISTR), PTITLE(NDISTR - 2)
      CHARACTER*60  PLOTIT
      INTEGER       BAKCOL, IDISTR, IHEAD, IPAGE, IRES, LDISTR, NHEAD,
     -              TITLEN(NDISTR), PITLEN(NDISTR - 2)
      LOGICAL       FIRST
      REAL          DX, DY, GTGPOS, GTGSIZ, X, XCENTR, XL, XR, XSTART,
     -              Y, YTOP

      PARAMETER    (DX = 3.0, DY = 2.0, GTGPOS = 5.0, GTGSIZ = 8.0)

      DATA DNAME /  'Phi angle distributions',
     -              'Psi angle distributions',
     -              'Chi-1 angle distributions',
     -              'Chi-2 angle distributions',
     -              'Ensemble Ramachandran plots',
     -              'Ensemble chi1-chi2 plots' /
      DATA HANAME / 'phidistrb',
     -              'psidistrb',
     -              'ch1distrb',
     -              'ch2distrb',
     -              'ensramach',
     -              'ensch1ch2' /
      DATA LDISTR / 0 /
      DATA GTITLE / 'Phi frequency distributions                     ',
     -              'Psi frequency distributions                     ',
     -              'Chi-1 frequency distributions                   ',
     -              'Chi-2 frequency distributions                   ',
     -              'Ensemble Ramachandran plots                     ',
     -              'Ensemble chi1-chi2 plots                        ' /
      DATA TITLEN /    27, 27, 29, 29, 27, 24 /
      DATA PTITLE / 'Progression of phi values                       ',
     -              'Progression of psi values                       ',
     -              'Progression of chi-1 values                     ',
     -              'Progression of chi-2 values                     ' /
      DATA PITLEN /    25, 25, 27, 27 /

C---- Open new PostScript file
      BAKCOL = COLPLT(1,IDISTR)
      PLDESC = DNAME(IDISTR)
      PLHAND = HANAME(IDISTR)
      PLOTIT = DNAME(IDISTR)
      IF (IDISTR.EQ.LDISTR) PLDESC = ' '
      LDISTR = IDISTR
      IF (FIRST.OR..NOT.COMBPS) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,PLHAND,WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(IDISTR),PLOTIT,
C     -        IPAGE + 1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(IDISTR),PLOTIT,
     -        IPAGE + 1)
CHECK v.3.4<--
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
CHECK v.3.4-->
C     -    INCOLR(IDISTR),BAKCOL,IPAGE + 1,PLABEL)
     -    INCOLR(IDISTR),BAKCOL,IPAGE + 1,PLABEL,RSELEC)
CHECK v.3.4<--

C---- Initialise variables
      DONPAG = .FALSE.
      XSTART = BBOXX1 + XFQLMG
      XCENTR = XSTART + NACROS * XFQWID / 2.0
      IF (TWODEE) THEN
          YTOP = BBOXY2 - YFQTM2
      ELSE
          YTOP = BBOXY2 - YFQTMG
      ENDIF
      CALL PSLWID(0.1)

C---- Main graph heading
      IF (HISTOG .OR. IDISTR.GT.NDISTR - 2) THEN
          CALL PSCTXT(XCENTR,YTOP + 60.0,28.0,
     -        GTITLE(IDISTR)(1:TITLEN(IDISTR)))
      ELSE
          CALL PSCTXT(XCENTR,YTOP + 60.0,28.0,
     -        PTITLE(IDISTR)(1:PITLEN(IDISTR)))
      ENDIF
      CALL PSCTXT(XCENTR,YTOP + 35.0,25.0,TITLE(1:TLEN))

C---- Print Chi-1/Chi-2 types at the top of the graphs
      IF (IDISTR.EQ.3 .OR. IDISTR.EQ.4) THEN

C----     Determine the number required
          NHEAD = NRES - IRES
          IF (NHEAD.GT.NACROS) NHEAD = NACROS      
          Y = YTOP + GTGPOS

C----     Loop through the boxes along the top
          DO 100, IHEAD = 1, NHEAD
              XL = XSTART + (IHEAD - 1) * XFQWID
              XR = XL + XFQWID

C----         Print gauche minus heading
              X = XL + (XR - XL) * 60.0 / 360.0 - DX / 2.0
              CALL PSCTXT(X,Y,GTGSIZ,'g')
              CALL PSCTXT(X + DX,Y + DY,GTGSIZ,'-')

C----         Print gauche minus heading
              X = XL + (XR - XL) * 180.0 / 360.0 - DX / 2.0
              CALL PSCTXT(X + DX / 2.0,Y,GTGSIZ,'t')

C----         Print gauche plus heading
              X = XL + (XR - XL) * 300.0 / 360.0 - DX / 2.0
              CALL PSCTXT(X,Y,GTGSIZ,'g')
              CALL PSCTXT(X + DX,Y + DY,GTGSIZ,'+')

 100      CONTINUE
      ENDIF

C---- Print page number
      IPAGE = IPAGE + 1
      WRITE(PAGENO,'(I2)') IPAGE
      PAGE = 'Page ' // PAGENO      
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

C---- Print program name in top left-hand corner
      IF (NMR) THEN
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-NMR')
      ELSE
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-COMP')
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE FRQEND  -  Finish current page for frequency distribution plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE FRQEND(IDISTR,XL,XR,YB,YT,NSHAD,LAST)

      INCLUDE 'mplot.inc'

CHECK v.3.3-->
      CHARACTER*6   CHARCV
CHECK v.3.3<--
      CHARACTER*20  XTITLE(NDISTR), YTITLE(NDISTR)
      CHARACTER*100 TEXT
      INTEGER       IDISTR, NSHAD, PLTYPE, TLENTH, XLENTH(NDISTR),
     -              YLENTH(NDISTR)
      LOGICAL       LAST
      REAL          X, XL, XR, Y, YB, YT

      DATA XTITLE / 'Phi (degrees)       ',
     -              'Psi (degrees)       ',
     -              'Chi-1 (degrees)     ',
     -              'Chi-2 (degrees)     ',
     -              'Phi (degrees)       ',
     -              'Chi-1 (degrees)     ' /
      DATA XLENTH / 13, 13, 15, 15, 13, 15 /
      DATA YTITLE / 'Frequency           ',
     -              'Frequency           ',
     -              'Frequency           ',
     -              'Frequency           ',
     -              'Psi (degrees)       ',
     -              'Chi-2 (degrees)     ' /
      DATA YLENTH /  9,  9,  9,  9, 13, 15 /

C---- Initialise variables
      PLTYPE = IDISTR

C---- x-axis title
      CALL PSCTXT((XL + XR) / 2.0,YB - 20.0,18.0,
     -    XTITLE(IDISTR)(1:XLENTH(IDISTR)))

C---- y-axis title
      IF (HISTOG .OR. IDISTR.GT.NDISTR - 2) THEN
          CALL PSRCTX(XL - 30.0,(YB + YT) / 2.0,18.0,
     -        YTITLE(IDISTR)(1:YLENTH(IDISTR)))
      ELSE
          CALL PSRCTX(XL - 30.0,(YB + YT) / 2.0,18.0,'Model number')
      ENDIF

C---- Key to graph
      Y = YB - 42.0
      TEXT = 'cv = Circular Variance (low values signify hig' //
     -    'h clustering of the data points).'
      TLENTH = 79
      CALL PSTEXT(XL,Y,7.0,TEXT(1:TLENTH))

C---- Print the legend explaining the accessibility icons
      X = XL + 240.0
CHECK v.3.4-->
C      CALL ACDIAL(X,Y,DIARAD,90.0,INCOLR,MXCOLR,RGB,COLPLT(8,PLTYPE))
      CALL ACDIAL(X,Y,DIARAD,90.0,INCOLR(PLTYPE),MXCOLR,RGB,
     -    COLPLT(6,PLTYPE))
CHECK v.3.4<--
      X = XL + 300.0
CHECK v.3.4-->
C      CALL ACDIAL(X,Y,DIARAD,10.0,INCOLR,MXCOLR,RGB,COLPLT(8,PLTYPE))
      CALL ACDIAL(X,Y,DIARAD,10.0,INCOLR(PLTYPE),MXCOLR,RGB,
     -    COLPLT(6,PLTYPE))
CHECK v.3.4<--
      X = XL + 248.0
      CALL PSTEXT(X,Y,7.0,'Accessible')
      X = XL + 308.0
      CALL PSTEXT(X,Y,7.0,'Buried')

C---- Print legend for G-factors
      IF (HAVEG) THEN
          Y = Y - 8.0
          TEXT = 'Gf = Average G-factor for the residue (the hig' //
     -        'her the value the more favourable the conformatio' //
     -        'ns)'
          TLENTH = 98
          CALL PSTEXT(XL,Y,7.0,TEXT(1:TLENTH))
          X = XL + 282.0
          TEXT = 'based on analysis of high-res. Xstal structure' //
     -        's'
          TLENTH = 49
          CALL PSTEXT(X,Y,7.0,TEXT(1:TLENTH))
      ENDIF
CXXX      IF (TWODEE) THEN
CXXX          Y = Y - 8.0
CXXX          TEXT = 'Markers:        Favourable,      Less favourab' //
CXXX     -        'le,      Unfavourable,      Disallowed'
CXXX          TLENTH = 84
CXXX          CALL PSTEXT(XL,Y,7.0,TEXT(1:TLENTH))

C----     Plot the 4 markers
CXXX          CALL PSLWID(0.1)
CXXX          YMID = Y
CXXX          Y1 = YMID - MSIZE / 2.0
CXXX          Y2 = YMID + MSIZE / 2.0

C----     Marker 1
CXXX          XMID = 115.0
CXXX          X1 = XMID - MSIZE / 2.0
CXXX          X2 = XMID + MSIZE / 2.0
CXXX          CALL PSLINE(XMID,Y1,XMID,Y2)
CXXX          CALL PSLINE(X1,YMID,X2,YMID)

C----     Marker 2
CXXX          XMID = 158.0
CXXX          X1 = XMID - MSIZE / 2.0
CXXX          X2 = XMID + MSIZE / 2.0
CXXX          CALL PSLINE(X1,Y1,X2,Y2)
CXXX          CALL PSLINE(X2,Y1,X1,Y2)

C----     Marker 3
CXXX          XMID = 215.0
CXXX          X1 = XMID - MSIZE / 2.0
CXXX          X2 = XMID + MSIZE / 2.0
CXXX          CALL PSLINE(X1,Y1,X1,Y2)
CXXX          CALL PSLINE(X1,Y2,X2,Y2)
CXXX          CALL PSLINE(X2,Y2,X2,Y1)
CXXX          CALL PSLINE(X2,Y1,X1,Y1)

C----     Marker 4
CXXX          XMID = 265.0
CXXX          X1 = XMID - MSIZE / 2.0
CXXX          X2 = XMID + MSIZE / 2.0
CXXX          CALL PSHADE(0.0,0,RGB,MXCOLR,.FALSE.)
CXXX          CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
CXXX      ENDIF

C---- Print explanation of shaded bands
      IF (NSHAD.GT.0) THEN
          Y = Y - 8.0
          TEXT = 'Darker shading defines bounds of experimentall' //
     -        'y-derived dihedral angle restraints'
          TLENTH = 81
          CALL PSTEXT(XL,Y,7.0,TEXT(1:TLENTH))
      ENDIF

CHECK v.3.4-->
C---- Print explanation of histogram-bar/data-point coloura
      IF (HAVEG .AND. INCOLR(IDISTR)) THEN
          Y = Y - 8.0
          IF (TWODEE) THEN
              TEXT = 'Data points coloured according to G-factor:'
              TLENTH = 43
          ELSE
              TEXT = 'Data bars coloured according to G-factor:'
              TLENTH = 41
          ENDIF
          CALL PSTEXT(XL,Y,7.0,TEXT(1:TLENTH))
          CALL PSCOLB(RGB(1,COLPLT(4,IDISTR)),
     -                RGB(2,COLPLT(4,IDISTR)),
CHECK v.3.4.3-->
C     -                RGB(2,COLPLT(4,IDISTR)))
     -                RGB(3,COLPLT(4,IDISTR)))
CHECK v.3.4.3<--
          CALL PSTEXT(XL + 140.0,Y,7.0,'Favourable')
          CALL PSCOLB(RGB(1,COLPLT(5,IDISTR)),
     -                RGB(2,COLPLT(5,IDISTR)),
CHECK v.3.4.3-->
C     -                RGB(2,COLPLT(5,IDISTR)))
     -                RGB(3,COLPLT(5,IDISTR)))
CHECK v.3.4.3<--
          CALL PSTEXT(XL + 190.0,Y,7.0,'Unfavourable')
          CALL PSCOLB(0.0,0.0,0.0)
      ENDIF
CHECK v.3.4<--

C---- Comment at bottom
      TLENTH = 0
      IF (PLSTAT.EQ.1) THEN
          TEXT = 'The asterisks mark the average values over all' //
     -        ' the structures'
          TLENTH = 61
      ELSE IF (PLSTAT.EQ.2) THEN
          WRITE(TEXT,20) AVESTR
 20       FORMAT('The asterisks mark the values in the averaged ',
     -        'structure: No.',I3)
          TLENTH = 63
      ELSE IF (PLSTAT.EQ.3) THEN
          WRITE(TEXT,40) ENASTR
 40       FORMAT('The asterisks mark the values in the energy mi',
     -        'nimized structure: No.',I3)
          TLENTH = 77
      ELSE IF (PLSTAT.EQ.4) THEN
          WRITE(TEXT,60) ASTSTR
 60       FORMAT('The asterisks mark the values in structure no. ',
     -        I3)
          TLENTH = 50
      ENDIF
      IF (TLENTH.GT.0) THEN
          CALL PSCTXT((XL + XR) / 2.0,YB - 50.0,10.0,TEXT(1:TLENTH))
      ENDIF

C---- If any duplicate residues on this page, then print explanatory text
      IF (DONPAG) THEN
          Y = Y - 12.0
          TEXT = 'before residue name signifies different residue-ty' //
     -        'pes at this position in the different structures'
          TLENTH = 98
          CALL PSTEXT(XL + 8.0,Y,8.0,TEXT(1:TLENTH))
          CALL PSCSHD(0.0)
          CALL PSCIRC(XL + 2.5,Y,2.5)
          CALL PSCSHD(1.0)
          CALL PSCIRC(XL + 2.5,Y,1.0)
      ENDIF
      DONPAG = .FALSE.

CHECK v.3.3-->
C---- If only residues with high circular variance plotted, show the
C     cut-off
      IF (CVCUT.GT.0.0) THEN
          Y = Y - 12.0
          WRITE(CHARCV,120) CVCUT
120       FORMAT(F6.3)
CHECK v.3.4.3-->
C          TEXT = 'Only residues with circular variance lower than' //
          TEXT = 'Only residues with circular variance higher than' //
CHECK v.3.4.3<--
     -        CHARCV // 'are shown'
          TLENTH = 62
          CALL PSTEXT(XL,Y,8.0,TEXT(1:TLENTH))
      ENDIF
CHECK v.3.3<--

C---- Close the current PostScript file
      CALL PSENDP
      IF (.NOT.COMBPS .OR. LAST) THEN
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RAMLIN  -  Draw in the lines separating the different
C                        Ramachandran plot regions
C
C----------------------------------------------------------------------+---

      SUBROUTINE RAMLIN(PWID,XL,YB,XWID,YWID)

      INCLUDE 'mplot.inc'

      INTEGER        MAPSIZ, NHATCH
      PARAMETER     (MAPSIZ = 36, NHATCH=50)

      CHARACTER*2    REGION
      INTEGER        I, J, IREG, ITYPE, LSTREG, LTYPE(MAPSIZ), REGTYP
      LOGICAL        CRONLY
      REAL           PWID, PHI, PSI, X, XWID, XL, Y, YB, YWID

C---- Initialise region-types (ie core, allowed, generous, disallowed)
      CRONLY = .TRUE.
      DO 100, I = 1, MAPSIZ
          LTYPE(I) = 0
 100  CONTINUE

C---- Loop through all the map-points
      CALL PSLWID(0.02)
      CALL PSDASH(1)
      Y = YB
      PSI = -180.0 + PWID / 2.0
      DO 300, I = 1, MAPSIZ
          X = XL
          LSTREG = 0
          PHI = -180.0 + PWID / 2.0
          DO 200, J = 1, MAPSIZ

C----         Determine which region this point is in
CHECK v.3.6-->
C              CALL RAMREG(PHI,PSI,REGION,IREG,REGTYP)
              IF (NEWREG) THEN
                  CALL RAMNEW(PHI,PSI,REGION,IREG,REGTYP) 
              ELSE
                  CALL RAMREG(PHI,PSI,REGION,IREG,REGTYP) 
              ENDIF
CHECK v.3.6<--

C----         Determine region-type
              ITYPE = REGTYP

C----         If region is a new one, then may need to draw a line between
C             it and the last
              IF (J.GT.1 .AND. ITYPE.NE.LTYPE(J - 1)) THEN

C----             Write out the appropriate line
                  IF (.NOT.CRONLY .OR. (ITYPE.EQ.4 .OR.
     -                LTYPE(J - 1).EQ.4)) THEN
                      CALL PSLINE(X, Y, X, Y + YWID)
                  ENDIF
              ENDIF

C----         Check whether to draw line between region and one above it
              IF (I.GT.1) THEN
                  IF (ITYPE.NE.LTYPE(J)) THEN
                      IF (.NOT.CRONLY .OR. (ITYPE.EQ.4 .OR.
     -                    LTYPE(J).EQ.4)) THEN
                          CALL PSLINE(X, Y, X + XWID, Y)
                      ENDIF
                  ENDIF
              ENDIF

C----         Store current details and prepare for next square
              LSTREG = IREG
              LTYPE(J) = ITYPE
              X = X + XWID
              PHI = PHI + PWID
 200      CONTINUE

C----     Increment y-value
          Y = Y + YWID
          PSI = PSI + PWID
 300  CONTINUE
      CALL PSDASH(0)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE FRQGRF  -  Plot the frequency distribution for the given
C                        residue
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE FRQGRF(IDISTR,IRES,XL,XR,YB,YT,SCALEX,SCALEY,CIRVAR,
CHECK v.3.4.3-->
C     -     SCORE,MEANSC,NFILE)
     -     MEANSC,NFILE)
CHECK v.3.4.3<--

      INCLUDE 'mplot.inc'

CHECK v.3.4-->
C      REAL          ASTHT, MINSHD, VALLOW, VALUPP
C      PARAMETER    (
C     -              ASTHT  =  2.0,
C     -              MINSHD =  0.995,
C     -              VALLOW =  0.00,
C     -              VALUPP = -3.00
C     -             )
      REAL          ASTHT
      PARAMETER    (ASTHT  =  2.0)
CHECK v.3.4<--

CHECK v.3.4-->
      CHARACTER*6   NUMBER
CHECK v.3.4<--
      CHARACTER*11  TEXT
CHECK v.3.4-->
C      INTEGER       I, IDISTR, IFILE, IPROPT, IRES, J, NFILE, NVALS,
C     -              PLTYPE
      INTEGER       I, IDISTR, IFILE, IPOS, IPROPT, IRES, J, NFILE,
     -              NVALS, NVIOL, PLTYPE
CHECK v.3.4<--
      REAL          ANGBEG, ANGEND, AVEVAL, CIRVAR, MEANSC, SCALEX,
CHECK v.3.4-->
C     -              SCALEY, SCORE(MXFILE), SHADE, SHIFT, X, X1, X2, XL,
C     -              XR, Y, Y1, Y2, YB, YT
CHECK v.3.4.3-->
C     -              SCALEY, SCORE(MXFILE), SHADE, SHIFT, TSIZE, X, X1,
     -              SCALEY, SHADE, SHIFT, TSIZE, X, X1,
CHECK v.3.4.3<--
     -              X2, XL, XR, Y, Y1, Y2, YB, YT
CHECK v.3.4<--


C---- Initialise variables
      PLTYPE = IDISTR

C---- Plot the values for this residues as: 1. a 2D plot, 2. a histogram
C     of the ensemble of values, or 3. as a progression of the values from
C     one structure to the next (eg showing progress of structure at
C     different stages in refinement)
      IF (TWODEE) THEN
CHECK v.3.4.3-->
C          CALL FRQDOT(IDISTR,IRES,XL,YB,SCALEX,SCALEY,SCORE,NFILE)
          CALL FRQDOT(IDISTR,IRES,XL,YB,SCALEX,SCALEY,NFILE)
CHECK v.3.4.3<--
      ELSE IF (HISTOG) THEN
CHECK v.3.4-->
C          CALL FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3-->
C          CALL FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,SCORE,NFILE)
          CALL FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3<--
CHECK v.3.4<--
      ELSE
CHECK v.3.4-->
C          CALL FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3-->
C          CALL FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,SCORE,NFILE)
          CALL FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3<--
CHECK v.3.4<--
      ENDIF
      IPROPT = IDISTR

C---- If this residue-position has different residue types in the different
C     files, identify the duplication by a black dot
      X1 = XL + 0.05 * (XR - XL)
      IF (TWODEE) THEN
          Y1 = YT + 0.06 * (YT - YB)
      ELSE
          Y1 = YT - 0.09 * (YT - YB)
      ENDIF
      SHIFT = 0.0
      IF (DOUBL(IRES)) THEN
          CALL PSCSHD(0.0)
          CALL PSCIRC(X1,Y1,2.5)
          CALL PSCSHD(1.0)
          CALL PSCIRC(X1,Y1,1.0)
          DONPAG = .TRUE.
          SHIFT = 5.0
      ENDIF

C---- Label the plot with the residue name and number
      J = 1
      DO 400, I = 1, 4
          IF (VALSNO(IRES)(I+1:I+1).EQ.' ') J = I + 1
 400  CONTINUE
      IF (VALSNO(IRES)(1:1).EQ.' ') THEN
          TEXT = VALRES(IRES) // ' ' // VALSNO(IRES)(J + 1:6)
      ELSE
          TEXT = VALSNO(IRES)(1:1) // ' ' // VALRES(IRES) // ' ' //
     -        VALSNO(IRES)(J + 1:6)
          J = J - 2
      ENDIF
      X1 = XL + 0.03 * (XR - XL) + SHIFT
      IF (TWODEE) THEN
          Y1 = YT + 0.05 * (YT - YB)
      ELSE
          Y1 = YT - 0.10 * (YT - YB)
      ENDIF
      CALL PSTEXT(X1,Y1,8.0,TEXT(1:5 + (5 - J)))

CHECK v.3.4-->
C---- If the dihedral restraints are violated, then show number of
C     violations
      CALL CTVIOL(IDISTR,IRES,NFILE,NVIOL)
      IF (NVIOL.GT.0) THEN

C----     Print the number of violations
          WRITE(NUMBER,420) NVIOL
 420      FORMAT(I3)
          IPOS = 1
          IF (NUMBER(1:1).EQ.' ') IPOS = 2
          IF (NUMBER(2:2).EQ.' ') IPOS = 3
          X1 = (XR + XL) / 2.0 - 8.0
          TSIZE = 6.0
          IF (TWODEE) THEN
              X1 = X1 + 4.0
              Y1 = Y1 + TSIZE
          ENDIF
          IF (INCOLR(IDISTR)) THEN
              CALL PSCOLB(RGB(1,COLPLT(5,IDISTR)),
     -                    RGB(2,COLPLT(5,IDISTR)),
     -                    RGB(3,COLPLT(5,IDISTR)))
          ENDIF
          CALL PSCTXT(X1,Y1,TSIZE,'VIOL')
          CALL PSCTXT(X1,Y1 - TSIZE,TSIZE,NUMBER(IPOS:3))
          X = X1
          Y = Y1
          X1 = X - TSIZE * 1.3
          X2 = X + TSIZE * 1.3
          Y1 = Y - TSIZE / 2.0 - TSIZE
          Y2 = Y + TSIZE / 2.0
          CALL PSLINE(X1,Y1,X1,Y2)
          CALL PSLINE(X1,Y2,X2,Y2)
          CALL PSLINE(X2,Y2,X2,Y1)
          CALL PSLINE(X2,Y1,X1,Y1)
          IF (INCOLR(IDISTR)) THEN
              CALL PSCOLB(0.0,0.0,0.0)
          ENDIF
      ENDIF
CHECK v.3.4<--

C---- If showing average value across all files, calculate this average
      IF (.NOT.TWODEE) THEN
          IF (PLSTAT.EQ.1) THEN
              AVEVAL = 0.0
              NVALS = 0.0
              DO 500, IFILE = 1, NFILE

CHECK v.3.4-->
C----             Process only if this is one of the selected models
                  IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

                      IF (VALUE(IPROPT,IRES,IFILE).LT.900.0) THEN
                          AVEVAL = AVEVAL + VALUE(IPROPT,IRES,IFILE)
                          NVALS = NVALS + 1
                      ENDIF
CHECK v.3.4-->
                  ENDIF
CHECK v.3.4<--
 500          CONTINUE
              IF (NVALS.GT.0) THEN
                  AVEVAL = AVEVAL / REAL(NVALS)
              ELSE
                  AVEVAL = 999.9
              ENDIF

C----     Otherwise, use the value of the marked structure
          ELSE IF (PLSTAT.GT.0) THEN
              AVEVAL = VALUE(IPROPT,IRES,PLSTAT)
          ENDIF      

C----     Find the value of the marked structure, and mark it on the graph
          IF (PLSTAT.GT.0) THEN
              IF (AVEVAL.LT.900.0) THEN
                  X1 = XL + (XR - XL) * AVEVAL / 360.0
                  Y1 = YB + (YT - YB) * 0.82
                  CALL PSLWID(0.2)
                  CALL PSLINE(X1,Y1 - ASTHT,X1,Y1 + ASTHT)
                  CALL PSLINE(X1 + ASTHT,Y1 + 0.6 * ASTHT, X1 - ASTHT,
     -                Y1 - 0.6 * ASTHT)
                  CALL PSLINE(X1 + ASTHT,Y1 - 0.6 * ASTHT, X1 - ASTHT,
     -                Y1 + 0.6 * ASTHT)
              ENDIF
          ENDIF
      ENDIF

C---- Print the circular variance value on the graph
CHECK v.3.4-->
C      IF (CIRVAR.GE.0.0 .AND. CIRVAR.LE.1.0) THEN
      IF (CIRVAR.GE.0.0 .AND. CIRVAR.LE.1.0 .AND. .NOT.OMITCV) THEN
CHECK v.3.4<--

C----     Write out the value
          WRITE(TEXT,620) CIRVAR
 620      FORMAT('cv ',F5.3)
          X1 = XL + 0.73 * (XR - XL)
          IF (TWODEE) THEN
              Y1 = YT + 0.11 * (YT - YB)
          ELSE
              Y1 = YT - 0.10 * (YT - YB)
          ENDIF
          CALL PSCTXT(X1,Y1,6.0,TEXT(1:8))

C----     Show a part-circle representing the circular variance
          X1 = XL + 0.88 * (XR - XL)
          ANGBEG = 90.0 - CIRVAR * 360.0
          IF (ANGBEG.LT.0.0) ANGBEG = ANGBEG + 360.0
          ANGEND = 90.0
          CALL PSLWID(0.05)
          CALL PSCSHD(1.0)
          CALL PSCIRC(X1,Y1,DIARAD)
          CALL PSLWID(0.0)
          CALL PSCSHD(0.0)
          CALL PSPCIR(X1,Y1,DIARAD,ANGBEG,ANGEND)
          CALL PSLWID(0.1)
      ENDIF

C---- Show the mean G-factor score for this residue
CHECK v.3.4-->
C      IF (HAVEG .AND. MEANSC.LT.900.0) THEN
      IF (HAVEG .AND. MEANSC.LT.900.0 .AND. .NOT.OMITGF) THEN
CHECK v.3.4<--

C----     Write out the value
          WRITE(TEXT,640) MEANSC
 640      FORMAT('Gf ',F5.2)
          X1 = XL + 0.73 * (XR - XL)
          IF (TWODEE) THEN
              Y = YT + 0.04 * (YT - YB)
          ELSE
              Y = YT - 0.24 * (YT - YB)
          ENDIF
          CALL PSCTXT(X1,Y,6.0,TEXT(1:8))

C----     Show a shaded square representing the residue's G-factor score
          X = XL + 0.88 * (XR - XL)
          X1 = X - 2.0
          X2 = X + 2.0
          Y1 = Y - 2.0
          Y2 = Y + 2.0
          IF (MEANSC.GT.VALLOW) THEN
              SHADE = MINSHD
          ELSE IF (MEANSC.LE.VALUPP) THEN
              SHADE = 0.0
          ELSE
              SHADE = MINSHD - MINSHD * (MEANSC - VALLOW)
     -            / (VALUPP - VALLOW)
          ENDIF
          CALL PSLWID(0.05)
CHECK v.3.4-->
C          CALL PSHADE(SHADE,0,RGB,MXCOLR,.FALSE.)
CHECK v.3.5.5-->
C          CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,COLPLT(4,PLTYPE),
C     -        COLPLT(5,PLTYPE))
          CALL PSCALE(SHADE,INCOLR(IDISTR),MXCOLR,RGB,COLPLT(4,PLTYPE),
     -        COLPLT(5,PLTYPE))
CHECK v.3.5.5<--
CHECK v.3.4<--
          CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      ENDIF

C---- Show the dial representing the average residue accessibility
CHECK v.3.4-->
      IF (.NOT.OMITAS) THEN
CHECK v.3.4<--
          X = XL + 0.96 * (XR - XL)
          IF (TWODEE) THEN
              Y = YT + 0.11 * (YT - YB)
          ELSE
              Y = YT - 0.10 * (YT - YB)
          ENDIF
CHECK v.3.5.5-->
C          CALL ACDIAL(X,Y,DIARAD,VALOOI(IRES),INCOLR,MXCOLR,
          CALL ACDIAL(X,Y,DIARAD,VALOOI(IRES),INCOLR(IDISTR),MXCOLR,
CHECK v.3.5.5<--
CHECK v.3.4-->
C     -            RGB,COLPLT(8,PLTYPE))
     -            RGB,COLPLT(6,PLTYPE))
      ENDIF
CHECK v.3.4<--

      RETURN
      END

C----------------------------------------------------------------------+--- 
CHECK v.3.4.3-->
C Modified functions CALC1D and CALC2D transferred to ps.f
CHECK v.3.4.3<--
CHECK v.3.4-->
C**************************************************************************
C
C  SUBROUTINE CTVIOL  -  Count the number of times the given residue's
C                        given torsions are violated
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE CTVIOL(IDISTR,IRES,NFILE,NVIOL)

      INCLUDE 'mplot.inc'

      INTEGER       IDISTR, IFILE, IRES, ITORS, NFILE, NVIOL

C---- Initialise number of violations
      NVIOL = 0

C---- For single torsion-angle distribution, get the number of violations
      IF (IDISTR.LE.4) THEN
          ITORS = IDISTR
          IF (DVIOL(ITORS,IRES).GT.0) THEN
              NVIOL = DVIOL(ITORS,IRES)
          ENDIF

C---- Ramachandran violations
      ELSE IF (IDISTR.EQ.5) THEN
          IF (DVIOL(LOCPHI,IRES).GT.0 .OR. DVIOL(LOCPSI,IRES).GT.0) THEN

C----         Count numbers of times either the phi or psi torsion is
C             violated
              DO 100, IFILE = 1, NFILE

C----             Process only if this is one of the selected models
                  IF (MWANT(IFILE)) THEN
                      IF (DVIOLM(LOCPHI,IRES,IFILE).GT.0.0 .OR.
     -                    DVIOLM(LOCPHI,IRES,IFILE).GT.0.0) THEN
                          NVIOL = NVIOL + 1
                      ENDIF
                  ENDIF
 100          CONTINUE
          ENDIF

C---- Chi1-chi2 violations
      ELSE IF (IDISTR.EQ.6) THEN
          IF (DVIOL(LOCHI1,IRES).GT.0 .OR. DVIOL(LOCHI2,IRES).GT.0) THEN

C----         Count numbers of times either the phi or psi torsion is
C             violated
              DO 200, IFILE = 1, NFILE

C----             Process only if this is one of the selected models
                  IF (MWANT(IFILE)) THEN
                      IF (DVIOLM(LOCHI1,IRES,IFILE).GT.0.0 .OR.
     -                    DVIOLM(LOCHI2,IRES,IFILE).GT.0.0) THEN
                          NVIOL = NVIOL + 1
                      ENDIF
                  ENDIF
 200          CONTINUE
          ENDIF
      ENDIF

      RETURN
      END

C----------------------------------------------------------------------+--- 
CHECK v.3.4<--
C*****************************************************************************
C
C  SUBROUTINE FRQBAR  -  Plot the frequency distribution for the given
C                        residue as a histogram of the ensemble values
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4-->
C      SUBROUTINE FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3-->
C      SUBROUTINE FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,SCORE,NFILE)
      SUBROUTINE FRQBAR(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3<--
CHECK v.3.4<--

      INCLUDE 'mplot.inc'

CHECK v.3.4-->
C      INTEGER       BAR(NHIST), IDISTR, IFILE, IHIST, IPROPT, IRANGE,
C     -              IRES, NFILE
C      REAL          DX, SCALEX, X1, X2, XL, Y1, Y2, YB, YHIGHT, YT
CHECK v.3.4.3-->
C      INTEGER       BAR(NHIST), ICOL, IDISTR, IFILE, IHIST, IPROPT,
C     -              IRANGE, IRES, NFILE
      INTEGER       BAR(NHIST), GDISTR, ICOL, IDISTR, IFILE, IHIST,
     -              IPROPT, IRANGE, IRES, NFILE
CHECK v.3.4.3<--
      LOGICAL       RESET
      REAL          BSCORE(NHIST), COLOUR(3), DX, SCALEX,
CHECK v.3.4.3-->
C     -              SCORE(MXFILE), SHADE, VAL, X1, X2, XL, Y1, Y2, YB,
C     -              YHIGHT, YT
     -              SHADE, VAL, X1, X2, XL, Y1, Y2, YB, YHIGHT, YT
CHECK v.3.4.3<--
CHECK v.3.4<--


C---- Zero the frequency counts for this residue
      DO 100, IHIST = 1, NHIST
          BAR(IHIST) = 0
CHECK v.3.4-->
          BSCORE(IHIST) = 999.99
CHECK v.3.4<--
 100  CONTINUE
      CALL PSLWID(0.01)
      IPROPT = IDISTR
CHECK v.3.4.3-->
      GDISTR = 0
      IF (IDISTR.EQ.3) GDISTR = 3
      IF (IDISTR.EQ.5) GDISTR = 1
      IF (IDISTR.EQ.6) GDISTR = 2
CHECK v.3.4.3<--

C---- Loop through all the values for this residue
      DO 200, IFILE = 1, NFILE
CHECK v.3.4-->
C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--
              IF (VALUE(IPROPT,IRES,IFILE).LT.900.0) THEN

C----             Determine which range the value falls into
                  IRANGE = VALUE(IPROPT,IRES,IFILE) / DANGLE + 1
                  IF (IRANGE.LT.1) IRANGE = 1
                  IF (IRANGE.GT.NHIST) IRANGE = NHIST
                  BAR(IRANGE) = BAR(IRANGE) + 1

CHECK v.3.4-->
C----             Store the G-factor corresponding to this position
CHECK v.3.4.3-->
C                  BSCORE(IRANGE) = SCOMOD(IDISTR,IRES,IFILE)
                  IF (GDISTR.NE.0) THEN
                      BSCORE(IRANGE) = SCOMOD(GDISTR,IRES,IFILE)
                  ELSE
                      BSCORE(IRANGE) = 999.99
                  ENDIF
CHECK v.3.4.3<--

CHECK v.3.4.3-->
C                  IF (BSCORE(IRANGE).GT.900.0 .AND. IDISTR.EQ.3) THEN
C                      BSCORE(IRANGE) = SCOMOD(2,IRES,IFILE)
                  IF (BSCORE(IRANGE).GT.900.0 .AND. GDISTR.EQ.2) THEN
                      BSCORE(IRANGE) = SCOMOD(3,IRES,IFILE)
CHECK v.3.4.3<--
                  ENDIF
CHECK v.3.4<--
              ENDIF
CHECK v.3.4-->
          ENDIF
CHECK v.3.4<--
 200  CONTINUE

C---- Initialise plot positions
      DX = DANGLE * SCALEX
      X1 = XL
      Y1 = YB
      YHIGHT = YT - YB
CHECK v.3.4-->
      RESET = .FALSE.
CHECK v.3.4<--
CHECK v.3.4.3-->
      CALL PSLWID(0.2)
CHECK v.3.4.3<--

C---- Plot the bars on the graph
      DO 300, IRANGE = 1, NHIST
          X2 = X1 + DX
          IF (BAR(IRANGE).GT.0) THEN
              Y2 = Y1 + YHIGHT * REAL(BAR(IRANGE)) / REAL(MAXFRQ)
              IF (Y2.GT.YT) Y2 = YT
CHECK v.3.4-->
C              CALL PSHADE(0.0,0,RGB,MXCOLR,.FALSE.)
C----         Calculate the colour of the bar according to its
C             G-factor
              IF (HAVEG) THEN
                  VAL = BSCORE(IRANGE)
              ELSE
                  VAL = 999.99
              ENDIF
              IF (VAL.GT.999.0) THEN
                  SHADE = 1.0
                  CALL PSCOLB(0.0,0.0,0.0)
              ELSE
                  IF (VAL.GT.VALLOW) THEN
                      SHADE = MINSHD
                  ELSE IF (VAL.LE.VALUPP) THEN
                      SHADE = 0.0
                  ELSE
                      SHADE = MINSHD
     -                    - MINSHD * (VAL - VALLOW)
     -                    / (VALUPP - VALLOW)
                  ENDIF
                  IF (INCOLR(IDISTR)) THEN
                      DO 250, ICOL = 1, 3
                          COLOUR(ICOL) = RGB(ICOL,COLPLT(4,IDISTR))
     -                        + (1.0 - SHADE)
     -                        * (RGB(ICOL,COLPLT(5,IDISTR))
     -                        - RGB(ICOL,COLPLT(4,IDISTR)))
 250                  CONTINUE
                      CALL PSCOLB(COLOUR(1),COLOUR(2),COLOUR(3))
                      RESET = .TRUE.
                  ENDIF
              ENDIF
              CALL PSCALE(SHADE,INCOLR(IDISTR),MXCOLR,
     -            RGB,COLPLT(4,IDISTR),COLPLT(5,IDISTR))
CHECK v.3.4<--
              CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
CHECK v.3.4.3-->
              IF (RESET) THEN
                  CALL PSCOLB(0.0,0.0,0.0)
                  CALL PSLWID(0.05)
                  CALL PSLINE(X1 + DX / 2.0,Y1,X1 + DX / 2.0,Y2)
                  CALL PSLWID(0.2)
              ENDIF
CHECK v.3.4.3<--
          ENDIF
          X1 = X2
 300  CONTINUE

CHECK v.3.4-->
CHECK v.3.4.3-->
C      IF (RESET) THEN
C          CALL PSCOLB(0.0,0.0,0.0)
C      ENDIF
CHECK v.3.4.3<--
CHECK v.3.4<--

      RETURN
      END

C----------------------------------------------------------------------+--- 
C*****************************************************************************
C
C  SUBROUTINE FRQDOT  -  Plot a 2D distribution (ie Ramachandran plot or
C                        chi1-chi2 plot for this residue)
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE FRQDOT(IDISTR,IRES,XL,YB,SCALEX,SCALEY,SCORE,NFILE)
      SUBROUTINE FRQDOT(IDISTR,IRES,XL,YB,SCALEX,SCALEY,NFILE)
CHECK v.3.4.3<--

      INCLUDE 'mplot.inc'

      CHARACTER*3   NUMBER
CHECK v.3.4-->
C      INTEGER       ICOLR, IDISTR, IFILE, IMARK, IPOS, IPROP1, IPROP2,
C     -              IRES, NFILE
C      REAL          ANG1, ANG2, MKSIZE, SCALEX, SCALEY, SCORE(MXFILE),
C     -              SHADE, TSIZE, VAL, VALFAV, VALESS, VALUNF, X, X1,
C     -              X2, XL, XMID, Y, Y1, Y2, YB, YMID
CHECK v.3.4.3-->
C      INTEGER       ICOL, IDISTR, IFILE, IPOS, IPROP1, IPROP2, IRES,
C     -              NFILE
C      REAL          ANG1, ANG2, COLOUR(3), MKSIZE, SCALEX, SCALEY,
C     -              SCORE(MXFILE), SHADE, TSIZE, VAL, VALFAV, VALESS,
C     -              VALUNF, X, X1, X2, XL, XMID, Y, Y1, Y2, YB, YMID
      INTEGER       GDISTR, IANGLE, IDISTR, IFILE, IPOS, IPROP1, IPROP2,
     -              IRES, JFILE, NANGLE, NFILE
      LOGICAL       FOUND, ONPLOT, PLACED
      REAL          ANG1, ANG2, BORDX1, BORDX2, BORDY1, BORDY2,
     -              DISMIN(2), DIST, DIST2, DTHETA, FRACTN, MKSIZE, PI,
     -              RADDEG, RADIUS, SCALEX, SCALEY, SHADE,
     -              STOREX(2,MXFILE), STOREY(2,MXFILE), THETA, TOPSHD,
     -              TSIZE, VAL, VALFAV, VALESS, VALUNF, X, X1, X2,
     -              XBEST, XL, XMID, YBEST, Y, Y1, Y2, YB, YMID
CHECK v.3.4.3<--
CHECK v.3.4<--

      PARAMETER    (
CHECK v.3.4.3-->
     -              DTHETA = 10.0,
     -              PI = 3.141592654,
     -              RADDEG = 180.0 / PI,
CHECK v.3.4.3<--
     -              VALFAV = -1.0,
     -              VALESS = -2.5,
     -              VALUNF = -3.5
     -             )

C---- Initialise
      CALL PSLWID(0.1)
      IF (IDISTR.EQ.5) THEN
          IPROP1 = LOCPHI
          IPROP2 = LOCPSI
      ELSE
          IPROP1 = LOCHI1
          IPROP2 = LOCHI2
      ENDIF
      MKSIZE = MSIZE * 0.75
      IF (NFILE.EQ.1) MKSIZE = MSIZE * 0.5
CHECK v.3.4.3-->
      IF (INCOLR(IDISTR)) THEN
          TOPSHD = 0.0
      ELSE
          TOPSHD = MAXSHD
      ENDIF
      GDISTR = 0
      IF (IDISTR.EQ.3) GDISTR = 3
      IF (IDISTR.EQ.5) GDISTR = 1
      IF (IDISTR.EQ.6) GDISTR = 2
CHECK v.3.4.3<--

C---- Loop through all the values for this residue
      DO 200, IFILE = 1, NFILE

CHECK v.3.4.3-->
C----     Initialise saved coordinates
          BORDX1 = XL
          BORDX2 = XL + 360.0 * SCALEX - MKSIZE
          BORDY1 = YB
          BORDY2 = YB + 360.0 * SCALEY
          STOREX(1,IFILE) = -999.9
          STOREY(1,IFILE) = -999.9
          STOREX(2,IFILE) = -999.9
          STOREY(2,IFILE) = -999.9
CHECK v.3.4.3<--

CHECK v.3.4-->
C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----         Check that residue has valid values for both properties
              ANG1 = VALUE(IPROP1,IRES,IFILE)
              ANG2 = VALUE(IPROP2,IRES,IFILE)
              IF (ANG1.GE.0.0 .AND. ANG1.LE.360.0 .AND.
     -            ANG2.GE.0.0 .AND. ANG2.LE.360.0) THEN

C-----            Calculate x- and y-coordinates of the point
                  X = ANG1 * SCALEX
                  X1 = XL + X - MKSIZE * 0.75
                  X2 = XL + X + MKSIZE * 0.75
                  XMID = (X1 + X2) / 2.0
                  Y = ANG2 * SCALEY
                  Y1 = YB + Y - MKSIZE * 0.75
                  Y2 = YB + Y + MKSIZE * 0.75
                  YMID = (Y1 + Y2) / 2.0

CHECK v.3.4.3-->
C----             Store the x- and y-coordinates of this point in
C                 case need them for the splay-numbering
                  STOREX(1,IFILE) = XMID
                  STOREY(1,IFILE) = YMID
CHECK v.3.4.3<--

C----             Calculate whether the point is favourable, less favourable,
C                 unfavourable, or disallowed
CHECK v.3.4.3-->
C                  VAL = SCORE(IFILE)
                  IF (GDISTR.NE.0) THEN
                      VAL = SCOMOD(GDISTR,IRES,IFILE)
                  ELSE
                      VAL = 999.99
                  ENDIF
                  IF (VAL.GT.900.0 .AND. GDISTR.EQ.2) THEN
                      VAL = SCOMOD(3,IRES,IFILE)
                  ENDIF
CHECK v.3.4.3<--
CHECK v.3.4-->
C                  IMARK = 1
C                  ICOLR = COLPLT(4,IDISTR)
C                  IF (VAL.LT.VALFAV) THEN
C                      IMARK = 2
C                      ICOLR = COLPLT(5,IDISTR)
C                  ENDIF
C                  IF (VAL.LT.VALESS) THEN
C                      IMARK = 3
C                      ICOLR = COLPLT(6,IDISTR)
C                  ENDIF
C                  IF (VAL.LT.VALUNF) THEN
C                      IMARK = 4
C                      ICOLR = COLPLT(7,IDISTR)
C                  ENDIF
                  IF (VAL.GT.999.0) THEN
                      SHADE = 1.0
                  ELSE
                      IF (VAL.GT.VALLOW) THEN
                          SHADE = MINSHD
                      ELSE IF (VAL.LE.VALUPP) THEN
CHECK v.3.4.3-->
C                          SHADE = 0.0
                          SHADE = TOPSHD
CHECK v.3.4.3<--
                      ELSE
                          SHADE = MINSHD
CHECK v.3.4.3-->
C     -                        - MINSHD * (VAL - VALLOW)
     -                        - (MINSHD - TOPSHD) * (VAL - VALLOW)
CHECK v.3.4.3<--
     -                        / (VALUPP - VALLOW)
                      ENDIF
                  ENDIF
CHECK v.3.4<--

C----             Plot clear or filled box depending on whether more than
C                 one model
CHECK v.3.4.3-->
CCHECK v.3.4-->
CC                  IF (NFILE.GT.1) THEN
C                  IF (NMODEL.GT.1) THEN
CCHECK v.3.4<--
C                      CALL PSLWID(0.2)
CCHECK v.3.4-->
CC                      SHADE = 1.0
CC                      ICOLR = COLPLT(1,IDISTR)
C                      IF (INCOLR(IDISTR)) THEN
C                          DO 100, ICOL = 1, 3
C                              COLOUR(ICOL) = RGB(ICOL,COLPLT(4,IDISTR))
C     -                            + (1.0 - SHADE)
C     -                            * (RGB(ICOL,COLPLT(5,IDISTR))
C     -                            - RGB(ICOL,COLPLT(4,IDISTR)))
C 100                      CONTINUE
C                          CALL PSCOLB(COLOUR(1),COLOUR(2),COLOUR(3))
C                          CALL PSHADE(1.0,COLPLT(2,IDISTR),RGB,MXCOLR,
C     -                        INCOLR(IDISTR))
CCHECK v.3.4.1-->
C                      ELSE
C                          SHADE = 1.0
C                          CALL PSHADE(SHADE,1,RGB,MXCOLR,
C     -                        INCOLR(IDISTR))
CCHECK v.3.4.1<--
C                      ENDIF
CCHECK v.3.4<--
C                  ELSE
CCHECK v.3.4-->
CC                      SHADE = 0.0
CHECK v.3.4.3<--
                      CALL PSLWID(0.1)
                      CALL PSCALE(SHADE,INCOLR(IDISTR),MXCOLR,
     -                    RGB,COLPLT(4,IDISTR),COLPLT(5,IDISTR))
CHECK v.3.4.3-->
CCHECK v.3.4<--
C                  ENDIF
CCHECK v.3.4-->
CHECK v.3.4.3<--
C                  CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(IDISTR))
CHECK v.3.4<--
                  CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----             Label point with its model number
CHECK v.3.4-->
C                  IF (NFILE.GT.1) THEN
                  IF (NMODEL.GT.1) THEN
CHECK v.3.4<--
                      WRITE(NUMBER,110) IFILE
 110                  FORMAT(I3)
                      IF (NUMBER(2:2).EQ.' ') THEN
                          IPOS = 3
                      ELSE IF (NUMBER(1:1).EQ.' ') THEN
                          IPOS = 2
                      ELSE
                          IPOS = 1
                      ENDIF
CHECK v.3.4-->
C                      IF (NFILE.LT.10) THEN
                      IF (TOPMOD.LT.10) THEN
CHECK v.3.4<--
                          TSIZE = 6.0
                      ELSE
                          TSIZE = 4.0
                      ENDIF
                      CALL PSCTXT(XMID,YMID,TSIZE,NUMBER(IPOS:))
CHECK v.3.4-->
                      IF (INCOLR(IDISTR)) THEN
                          CALL PSCOLB(0.0,0.0,0.0)
                      ENDIF
CHECK v.3.4<--
                  ENDIF
              ENDIF
CHECK v.3.4-->
          ENDIF
CHECK v.3.4<--
 200  CONTINUE

CHECK v.3.4.3-->
C---- If models are to be splay-numbered, then loop through them and do
C     that
      IF (SPLAYN .AND. NMODEL.GT.1) THEN

C----     Set the text-size for the model-numbers
          TSIZE = 8.0
          DIST = TSIZE + MKSIZE * 0.75
          DISMIN(1) = DIST * DIST
          DIST = TSIZE
          DISMIN(2) = DIST * DIST
          NANGLE = NINT(360.0 / DTHETA)

C----     Loop through all the models again
          DO 600, IFILE = 1, NFILE

C----         Process only if point is on the graph
              IF (STOREX(1,IFILE).GT.-900.0 .AND.
     -            STOREY(1,IFILE).GT.-900.0) THEN

C----             Get this point's coordinates
                  X = STOREX(1,IFILE)
                  Y = STOREY(1,IFILE)

C----             Initialise for generating trial positions for this
C                 model-number
                  RADIUS = 0.0
                  X1 = X
                  Y1 = Y

C----             Loop until a suitable position for placing the point's
C                 model-number is found
                  FOUND = .FALSE.
                  PLACED = .FALSE.
 300              CONTINUE

C----                 Generate next set of trial positions by incrementing
C                     radius
                      RADIUS = RADIUS + TSIZE / 2.0
                      ONPLOT = .FALSE.

C----                 Loop over positions around the current circle
                      DO 400, IANGLE = 1, NANGLE

C----                     Calculate current angle
                          THETA = (IANGLE - 1) * DTHETA / RADDEG

C----                     Calculate x- and y-coords of this point
                          X1 = X + RADIUS * COS(THETA)
                          Y1 = Y + RADIUS * SIN(THETA)

C----                     Check that point is within the graph area
                          IF (X1.LE.BORDX1 .OR. X1.GE.BORDX2 .OR.
     -                        Y1.LE.BORDY1 .OR. Y1.GE.BORDY2) GO TO 400
                          ONPLOT = .TRUE.

C----                     Loop over all the points and labels to see if
C                         any of them clash with this position
                          DO 350, JFILE = 1, NFILE
                              DO 320, IPOS = 1, 2

C----                             Process only if point is on the graph
                                  IF (STOREX(IPOS,JFILE).GT.-900.0 .AND.
     -                                STOREY(IPOS,JFILE).GT.-900.0) THEN

C----                                 Get this point's coordinates
                                      X2 = STOREX(IPOS,JFILE)
                                      Y2 = STOREY(IPOS,JFILE)

C----                                 Calculate the distance between this
C                                     position and the current point
                                      DIST2 = (X1 - X2) * (X1 - X2)
     -                                    + (Y1 - Y2) * (Y1 - Y2)

C----                                 If distance is small, suggesting an
C                                     overlap, then abandon this point
                                      IF (DIST2.LT.DISMIN(IPOS))
     -                                    GO TO 400
                                  ENDIF
 320                          CONTINUE
 350                      CONTINUE

C----                     If have reached here, then have a viable position
C                         for the model-number
                          FOUND = .TRUE.
                          XBEST = X1
                          YBEST = Y1
                          GO TO 401
 400                  CONTINUE

C----                 If have a valid position, then print the model-number
C                     there
 401                  CONTINUE
                      IF (FOUND) THEN

C----                     Get the full length of the line to be drawn
                          DIST2 = (X - XBEST) * (X - XBEST)
     -                        + (Y - YBEST) * (Y - YBEST)
                          DIST = SQRT(DIST2)

C----                     Eliminate the part over the data point
                          FRACTN = (MKSIZE * 0.75) / DIST
                          IF (FRACTN.GT.0.5) FRACTN = 0.5
                          X1 = X + FRACTN * (XBEST - X)
                          Y1 = Y + FRACTN * (YBEST - Y)

C----                     Eliminate the part next to the number
                          FRACTN = (TSIZE / 2.0) / DIST
                          IF (FRACTN.GT.0.5) FRACTN = 0.5
                          X2 = X + (1.0 - FRACTN) * (XBEST - X)
                          Y2 = Y + (1.0 - FRACTN) * (YBEST - Y)

C----                     Draw line from point to model-number
                          CALL PSLINE(X1,Y1,X2,Y2)

C----                     Print the model number
                          WRITE(NUMBER,110) IFILE
                          IF (NUMBER(2:2).EQ.' ') THEN
                              IPOS = 3
                          ELSE IF (NUMBER(1:1).EQ.' ') THEN
                              IPOS = 2
                          ELSE
                              IPOS = 1
                          ENDIF
                          CALL PSCTXT(XBEST,YBEST,TSIZE,NUMBER(IPOS:))

C----                     Store the label-position
                          STOREX(2,IFILE) = XBEST
                          STOREY(2,IFILE) = YBEST
                          PLACED = .TRUE.
                      ENDIF

                  IF (.NOT.PLACED .AND. ONPLOT) GO TO 300
              ENDIF
 600  CONTINUE

      ENDIF
CHECK v.3.4.3<--

      RETURN
      END

C----------------------------------------------------------------------+--- 
C*****************************************************************************
C
C  SUBROUTINE FRQPRG  -  Plot the frequency distribution for the given
C                        residue as a progression of values
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4-->
C      SUBROUTINE FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3-->
C      SUBROUTINE FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,SCORE,NFILE)
      SUBROUTINE FRQPRG(IDISTR,IRES,XL,YB,YT,SCALEX,NFILE)
CHECK v.3.4.3<--
CHECK v.3.4<--

      INCLUDE 'mplot.inc'

CHECK v.3.4-->
C      INTEGER       IDISTR, IFILE, IPROPT, IRANGE, IRES, NFILE
C      LOGICAL       FIRST
C      REAL          DX, DY, SCALEX, X1, X2, XL, XLAST, Y1, Y2, YB,
C     -              YLAST, YT
CHECK v.3.4.3-->
C      INTEGER       ICOL, IDISTR, IFILE, IPROPT, IRANGE, IRES, NFILE
      INTEGER       ICOL, GDISTR, IDISTR, IFILE, IPROPT, IRANGE, IRES,
     -              NFILE
CHECK v.3.4.3<--
      LOGICAL       FIRST, RESET
CHECK v.3.4.3-->
C      REAL          COLOUR(3), DX, DY, SCALEX, SCORE(MXFILE), SHADE,
C     -              VAL, X1, X2, XL, XLAST, Y1, Y2, YB, YLAST, YT
      REAL          COLOUR(3), DX, DY, SCALEX, SHADE, VAL, X1, X2, XL,
     -              XLAST, Y1, Y2, YB, YLAST, YT
CHECK v.3.4.3<--
CHECK v.3.4<--


C---- Initialise variables
      CALL PSLWID(0.1)
      DX = DANGLE * SCALEX
      DY = (YT - YB) / MAXFRQ
      FIRST = .TRUE.
      IPROPT = IDISTR
      XLAST = 0.0
      YLAST = 0.0
      Y1 = YB
CHECK v.3.4.3-->
      GDISTR = 0
      IF (IDISTR.EQ.3) GDISTR = 3
      IF (IDISTR.EQ.5) GDISTR = 1
      IF (IDISTR.EQ.6) GDISTR = 2
CHECK v.3.4.3<--

C---- Loop through all the values for this residue
      DO 200, IFILE = 1, NFILE
CHECK v.3.4-->
C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

              Y2 = Y1 + DY
              IF (Y2.GT.YT) Y2 = YT

C----         If the value is a valid one, plot a bar for this structure
              IF (VALUE(IPROPT,IRES,IFILE).LT.900.0) THEN

C----             Determine which range the value falls into
                  IRANGE = VALUE(IPROPT,IRES,IFILE) / DANGLE + 1
                  IF (IRANGE.LT.1) IRANGE = 1
                  IF (IRANGE.GT.NHIST) IRANGE = NHIST
                  X1 = XL + (IRANGE - 1) * DX
                  X2 = X1 + DX
CHECK v.3.4.3-->
C                  CALL PSLWID(0.1)
                  CALL PSLWID(0.2)
CHECK v.3.4.3<--
CHECK v.3.4-->
C                  CALL PSHADE(0.0,0,RGB,MXCOLR,.FALSE.)
C----             Calculate the colour of the bar according to its
C                 G-factor
                  RESET = .FALSE.
                  IF (HAVEG) THEN
CHECK v.3.4.3-->
C                      VAL = SCORE(IFILE)
                      IF (GDISTR.NE.0) THEN
                          VAL = SCOMOD(GDISTR,IRES,IFILE)
                      ELSE
                          VAL = 999.99
                      ENDIF
                      IF (VAL.GT.900.0 .AND. GDISTR.EQ.2) THEN
                          VAL = SCOMOD(3,IRES,IFILE)
                      ENDIF
CHECK v.3.4.3<--
                  ELSE
                      VAL = 999.99
                  ENDIF
                  IF (VAL.GT.999.0) THEN
                      SHADE = 1.0
                      CALL PSCOLB(0.0,0.0,0.0)
                  ELSE
                      IF (VAL.GT.VALLOW) THEN
                          SHADE = MINSHD
                      ELSE IF (VAL.LE.VALUPP) THEN
                          SHADE = 0.0
                      ELSE
                          SHADE = MINSHD
     -                        - MINSHD * (VAL - VALLOW)
     -                        / (VALUPP - VALLOW)
                      ENDIF
                      IF (INCOLR(IDISTR)) THEN
                          DO 250, ICOL = 1, 3
                              COLOUR(ICOL) = RGB(ICOL,COLPLT(4,IDISTR))
     -                            + (1.0 - SHADE)
     -                            * (RGB(ICOL,COLPLT(5,IDISTR))
     -                            - RGB(ICOL,COLPLT(4,IDISTR)))
 250                      CONTINUE
                          CALL PSCOLB(COLOUR(1),COLOUR(2),COLOUR(3))
                          RESET = .TRUE.
                      ENDIF
                  ENDIF
                  CALL PSCALE(SHADE,INCOLR(IDISTR),MXCOLR,
     -                RGB,COLPLT(4,IDISTR),COLPLT(5,IDISTR))
CHECK v.3.4<--
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)

CHECK v.3.4-->
C----             Reset colour to black
                  IF (RESET) THEN
                      CALL PSCOLB(0.0,0.0,0.0)
CHECK v.3.4.3-->
                      CALL PSLWID(0.05)
                      CALL PSLINE(X1 + DX / 2.0,Y1,X1 + DX / 2.0,Y2)
CHECK v.3.4.3<--
                  ENDIF
CHECK v.3.4<--

C----             If this is not the first bar (or a bar after a break in the
C                 sequence of files with valid values here), join a line from
C                 the previous bar to the current one
                  IF (.NOT.FIRST) THEN
                      CALL PSLWID(0.1)
                      CALL PSLINE(XLAST,YLAST,X1 + DX / 2.0,Y1)
                  ENDIF
                  FIRST = .FALSE.
              ELSE
                  FIRST = .TRUE.
              ENDIF

              Y1 = Y2
              XLAST = X1 + DX / 2.0
              YLAST = Y2
CHECK v.3.4-->
          ENDIF
CHECK v.3.4<--
 200  CONTINUE

      RETURN
      END

C----------------------------------------------------------------------+--- 
C**************************************************************************
C
C  SUBROUTINE GETRMS  -  Read through the .rms file to pick up all the
C                        residue-by-residue RMS deviations
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETRMS

      INCLUDE 'mplot.inc'

      CHARACTER*6   IDENT
      CHARACTER*13  RESKEY
      CHARACTER*78  IREC
      INTEGER       I, IMODEL, IPOS, IRES, LINE
      LOGICAL       ALLMOD, HAVEIT, READIN
      REAL          RMS(3)

C---- Initialise variables
      ALLMOD = .FALSE.
      IFAIL = .FALSE.
      IRES = FSTRES
      IMODEL = 0
      LINE = 0
      READIN = .FALSE.

C---- Loop through the .rms file, reading in all the residue deviations
100   CONTINUE
          READ(8,150,END=800,ERR=900) IREC
150       FORMAT(A)
          LINE = LINE + 1
          IDENT = IREC(1:6)

C----     If MODEL record, then reinitialise variables
          IF (IDENT.EQ.'MODEL ') THEN
              IRES = FSTRES
              IMODEL = IMODEL + 1
              READIN = .TRUE.

C----     If ENDMDL record, then stop reading in values
          ELSE IF (IDENT.EQ.'ENDMDL') THEN
              READIN = .FALSE.

C----     If this is the ensemble record, then mark as such
          ELSE IF (IDENT.EQ.'ALL MO') THEN
              IRES = FSTRES
              READIN = .TRUE.
              ALLMOD = .TRUE.

C----     Otherwise, read in and store the RMS values
          ELSE IF (READIN) THEN

C----         Pick off the residue identifier
              RESKEY = IREC(7:15)

C----         Retrieve the 3 RMS values
              READ(IREC,160,ERR=902) (RMS(I), I = 1, 3)
160           FORMAT(15X,3F10.0)

C----         Find the residue's location in the sequence

C----         Check whether key matches the current atom we're looking at
              HAVEIT = .FALSE.
              IF (IRES.GT.0) THEN
                  IF (RESKEY.EQ.VALSNO(IRES)) THEN
                      HAVEIT = .TRUE.
                  ENDIF
              ENDIF

C----         If a match not found, start the search at the beginning
              IF (.NOT.HAVEIT) THEN
                  IPOS = 0

C----             Loop until match found, or all atoms searched
200               CONTINUE
                      IPOS = IPOS + 1

C----                 Get the pointer to the next atom
                      IF (IPOS.EQ.1) THEN
                          IRES = FSTRES
                      ELSE
                          IRES = NXTRES(IRES)
                      ENDIF

C----                 Check whether current atom matches here
                      IF (IRES.GT.0) THEN
                          IF (RESKEY.EQ.VALSNO(IRES)) HAVEIT = .TRUE.
                      ENDIF

C----              Loop back, if necessary
                   IF (.NOT.HAVEIT .AND. IPOS.LT.NRES) GO TO 200
              ENDIF

C----         Store the RMS deviations/distance restraint
              IF (HAVEIT) THEN
                  IF (ALLMOD) THEN
                      RMSALL(1,IRES) = RMS(1)
                      RMSALL(2,IRES) = RMS(2)
                      RMSALL(3,IRES) = RMS(3)
                      PINDMX = MAX(RMS(1),PINDMX)
                      PINDMX = MAX(RMS(2),PINDMX)
                  ELSE
                      RMSDEV(1,IRES,IMODEL) = RMS(1)
                      RMSDEV(2,IRES,IMODEL) = RMS(2)
                      RMSDEV(3,IRES,IMODEL) = RMS(3)
                  ENDIF

C----             Prepare pointer to the next residue
                  IRES = NXTRES(IRES)
              ELSE
                  IRES = FSTRES
              ENDIF

          ENDIF
      GO TO 100

C---- End of .rms file reached
 800  CONTINUE
CHECK v.3.4-->
C      NMODEL = IMODEL
C      PRINT*, 'RMS deviations read in for', NMODEL, ' models'
      PRINT*, 'RMS deviations read in for', IMODEL, ' models'
CHECK v.3.4<--

      GO TO 999

C---- Fatal errors
900   CONTINUE
      PRINT*, '**** Data error reading file:  [', FILRMS, ']'
      PRINT*, '    Line: ', LINE
      GO TO 990

902   CONTINUE
      PRINT*, '**** Error in RMS values for model: ', IMODEL,
     -    ', residue: ', RESKEY
      GO TO 100

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C Routine GETCON transferred to vplot.f
CHECK v.3.4<--
C**************************************************************************
C
C  SUBROUTINE GETORS  -  Read through the Aqua output files to pick up
C                        the dihedral angle restraints
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETORS(NFILE)

      INCLUDE 'mplot.inc'

      CHARACTER*1   INCHN
      CHARACTER*4   TORTYP
      CHARACTER*10  RESDET
      CHARACTER*80  IREC, TMPREC
      INTEGER       ICONST, IERR, IPOS, IRES, IRESID, ITORS,
     -              LINE, NFILE
      REAL          LOWER, UPPER

C---- Initialise variables
      IFAIL = .FALSE.
      LINE = 0
      ICONST = 0

C---- Open the restraints file
      OPEN(UNIT=12, FILE=FILTOR, STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Read in the data from the file
 100  CONTINUE
          READ(12,120,END=500,IOSTAT=IERR) IREC
 120      FORMAT(A)
          LINE = LINE + 1
          IF (IERR.NE.0) THEN
              PRINT*, '*  File-read error at line', LINE
              IREC = ' '

C----     If this is an ANGLE record, read in and store the restraint
          ELSE IF (IREC(1:5).EQ.'ANGLE') THEN

C----         Check whether the line contains a chain identifier
              INCHN = ' '
              IPOS = INDEX(IREC,'CHAIN')
              IF (IPOS.GT.0) THEN
                  INCHN = IREC(15:15)
                  TMPREC = IREC(1:8) // IREC(17:)
                  IREC = TMPREC
              ENDIF

C----         Get the residue ID
              RESDET = IREC(9:11) // IREC(13:17)

C----         Find the relevant residue number
              IRESID = 0
              DO 200, IRES = 1, NRES
                  IF (INCHN.EQ.VALSNO(IRES)(1:1) .AND.
     -                RESDET(4:8).EQ.VALSNO(IRES)(2:6) .AND.
     -                (RESDET(1:3).EQ.VALSNO(IRES)(7:9) .OR.
     -                 RESDET(1:3).EQ.'UNK')) THEN
                      IRESID = IRES
                  ENDIF
 200          CONTINUE

C----         If have located the relevant residue, then store the
C             restraint
              IF (IRESID.NE.0) THEN

C----             Read in the upper- and lower-bounds
                  READ(IREC,220,IOSTAT=IERR) TORTYP, UPPER, LOWER
CHECK v.3.4-->
C 220              FORMAT(16X,A4,1X,2F9.3)
 220              FORMAT(17X,A4,1X,2F9.3)
CHECK v.3.4<--
                  IF (IERR.EQ.0) THEN
                      ITORS = 0
                      IF (TORTYP.EQ.'PHI ') ITORS = 1
                      IF (TORTYP.EQ.'PSI ') ITORS = 2
                      IF (TORTYP.EQ.'CHI1') ITORS = 3
                      IF (TORTYP.EQ.'CHI2') ITORS = 4

C----                 If this is a valid torsion angle, then store
                      IF (ITORS.GT.0) THEN

CHECK v.3.4-->
C----                     Adjust upper-bound, if necessary
                          IF (UPPER.LT.LOWER) THEN
                              UPPER = UPPER + 360.0
                          ENDIF
CHECK v.3.4<--

C----                     Increment restraints count
                          ICONST = ICONST + 1
                          IF (ICONST.GT.MXRES) THEN
                              PRINT*, '*** Maximum no. of dihedral ',
     -                            'angle restraints exceeded ', MXRES
                              PRINT*, '*   Some will have been lost'

C----                     Store upper- and lower-bounds
                          ELSE
                              IF (ITORS.EQ.3 .OR. ITORS.EQ.4) THEN
                                  IF (LOWER.LT.UPPER .AND.
     -                                (LOWER.LE.0.0 .OR.
     -                                UPPER.LE.0.0)) THEN
                                      LOWER = LOWER + 360.0
                                      UPPER = UPPER + 360.0
                                  ENDIF
                              ENDIF
                              DIHCON(1,ITORS,IRESID) = LOWER
                              DIHCON(2,ITORS,IRESID) = UPPER
                              HAVANG = .TRUE.

C----                         Check through the models to count how many
C                             times this restraint is violated
                              CALL CVIOL(NFILE,ITORS,IRESID,LOWER,UPPER)
                          ENDIF
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF

C---- Loop back for next record
      GO TO 100

C---- End of file reached
 500  CONTINUE
      CLOSE(12)

C---- Total number of dihedral angle restraints
      ACONST = ICONST
      PRINT*, '*'
      PRINT*, '* Dihedral angle restraints read in: ', ACONST
      PRINT*, '*'

      GO TO 999

C---- Errors
900   CONTINUE
      PRINT*, '**** No torsion angle restraints found'
      GO TO 999

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C**************************************************************************
C
C  SUBROUTINE CVIOL  -  Count the number of times a given torsion angle
C                       restraint is violated in the models of interest
C
C----------------------------------------------------------------------+---

      SUBROUTINE CVIOL(NFILE,ITORS,IRESID,LOWER,UPPER)

      INCLUDE 'mplot.inc'

      INTEGER       IFILE, IRESID, ITORS, NFILE
      LOGICAL       OUTSID
      REAL          DIHVAL, LOWER, UPPER

C---- Loop through the models to count how many times the given
C     restraint is violated
      DO 400, IFILE = 1, NFILE

C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN

C----         Pick off the appropriate value
              IF (ITORS.EQ.1) THEN
                  DIHVAL = VALUE(LOCPHI,IRESID,IFILE) - 180.0
              ELSE IF (ITORS.EQ.2) THEN
                  DIHVAL = VALUE(LOCPSI,IRESID,IFILE) - 180.0
              ELSE IF (ITORS.EQ.3) THEN
                  DIHVAL = VALUE(LOCHI1,IRESID,IFILE)
              ELSE IF (ITORS.EQ.4) THEN
                  DIHVAL = VALUE(LOCHI2,IRESID,IFILE)
              ENDIF

C----         Check is value falls within restraint range
              IF (DIHVAL.GE.LOWER .AND. DIHVAL.LE.UPPER) THEN
                  OUTSID = .FALSE.
              ELSE
                  OUTSID = .TRUE.
              ENDIF

C----         If still outside, add 360 and try again
              IF (OUTSID) THEN
                  DIHVAL = DIHVAL + 360.0
                  IF (DIHVAL.GE.LOWER .AND. DIHVAL.LE.UPPER) THEN
                      OUTSID = .FALSE.
                  ENDIF
              ENDIF
                                      
C----         If the value is outside the restraint bounds increment
C             the number of restraint violations
              IF (OUTSID) THEN
                  DVIOL(ITORS,IRESID) = DVIOL(ITORS,IRESID) + 1
                  DVIOLM(ITORS,IRESID,IFILE) = 1.0
              ELSE
                  DVIOLM(ITORS,IRESID,IFILE) = 0.0
              ENDIF
          ENDIF
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4<--
C**************************************************************************
C     
C  SUBROUTINE FILKEY  -  Print out a key cross-referencing the model
C                        numbers to the corresponding filenames
C
C----------------------------------------------------------------------+---
      
      SUBROUTINE FILKEY(XSTART,YSTART,DX,DY,TBIG,TSMALL,NFILE)
      
      INCLUDE 'mplot.inc'
      
      CHARACTER*3   NUMBER
      INTEGER       IFILE, IPOS, NFILE
      REAL          DX, DY, TBIG, TSIZE, TSMALL, X, XSP, XSTART, Y,
     -              YSP, YSTART

C---- Initialise coordinate positions and text size
      X = XSTART
      Y = YSTART
      XSP = 2.0 * DX
CHECK v.3.4-->
C      IF (NFILE.LT.30) THEN
      IF (NMODEL.LT.30) THEN
CHECK v.3.4<--
          YSP = DY
      ELSE
          YSP = 0.5 * DY
      ENDIF
CHECK v.3.4-->
C      IF (NFILE.LT.10) THEN
      IF (TOPMOD.LT.10) THEN
CHECK v.3.4<--
          TSIZE = TBIG
      ELSE
          TSIZE = TSMALL
      ENDIF

C---- Print heading
      CALL PSTEXT(X - DX,Y + 2.0 * DY + YSP,TSIZE,'Files:')

C---- Loop through all the files in the ensemble
      DO 500, IFILE = 1, NFILE

CHECK v.3.4-->
C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----         Draw marker box
              CALL PSLWID(0.2)
              CALL PSHADE(1.0,0,RGB,MXCOLR,.FALSE.)
              CALL PSBBOX(X - DX,Y - DY,X - DX,Y + DY,
     -                    X + DX,Y + DY,X + DX,Y - DY)

C----         Form and print the model number inside the marker
              WRITE(NUMBER,110) IFILE
 110          FORMAT(I3)
              IF (NUMBER(2:2).EQ.' ') THEN
                  IPOS = 3
              ELSE IF (NUMBER(1:1).EQ.' ') THEN
                  IPOS = 2
              ELSE
                  IPOS = 1
              ENDIF
              CALL PSCTXT(X,Y,TSIZE,NUMBER(IPOS:))

C----         Print file name
              CALL PSTEXT(X + XSP,Y,TSIZE,
     -            FILID(IFILE)(1:LENID(IFILE)))

C----         Move y-position down for next file
              Y = Y - 2.0 * DY - YSP
CHECK v.3.4-->
          ENDIF
CHECK v.3.4<--
 500  CONTINUE
      
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C**************************************************************************
C
C  SUBROUTINE CALCG  -  Calculate overall model-by-model G-factors
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE CALCG(NFILE)

      INCLUDE 'mplot.inc'

CHECK v.3.4.3-->
C      INTEGER       IFILE, IRES, NFILE
      INTEGER       IDISTR, IFILE, IRES, NFILE, NSC
CHECK v.3.4.3<--
      LOGICAL       WANTED
CHECK v.3.4.3-->
      REAL          SC
CHECK v.3.4.3<--

C---- Loop through all the models in the ensemble
      DO 200, IFILE = 1, NFILE

C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN

C----         Loop through all the residue in the model
              DO 100, IRES = 1, NRES

C----             Update figures for calculating overall residue-by-residue
C                 averages and overall model-by-model averages
CHECK v.3.4.3-->
C                  SCOMOD(IRES,MXFILE + 1) = SCOMOD(IRES,MXFILE + 1)
C     -                + SCOMOD(IRES,IFILE)
C                  NUMSCO(IRES,MXFILE + 1) = NUMSCO(IRES,MXFILE + 1)
C     -                + NUMSCO(IRES,IFILE)
C                  SCOMOD(MXRES + 1,IFILE) = SCOMOD(MXRES + 1,IFILE)
C     -                + SCOMOD(IRES,IFILE)
C                  NUMSCO(MXRES + 1,IFILE) = NUMSCO(MXRES + 1,IFILE)
C     -                + NUMSCO(IRES,IFILE)
C                  SCOMOD(MXRES + 1,MXFILE + 1)
C     -                = SCOMOD(MXRES + 1,MXFILE + 1)
C     -                + SCOMOD(IRES,IFILE)
C                  NUMSCO(MXRES + 1,MXFILE + 1)
C     -                = NUMSCO(MXRES + 1,MXFILE + 1)
C     -                + NUMSCO(IRES,IFILE)

C----             Accumulate current residue's scores
                  SC = 0.0
                  NSC = 0
                  DO 80, IDISTR = 1, NDISTR
                      SC = SC + SCOMOD(IDISTR,IRES,IFILE)
                      NSC = NSC + NUMSCO(IDISTR,IRES,IFILE)
 80               CONTINUE

C----             Update overall scores
                  SCOMOD(NDISTR + 1,IRES,IFILE) = SC
                  NUMSCO(NDISTR + 1,IRES,IFILE) = NSC
                  SCOMOD(NDISTR + 1,IRES,MXFILE + 1)
     -                = SCOMOD(NDISTR + 1,IRES,MXFILE + 1)
     -                + SCOMOD(NDISTR + 1,IRES,IFILE)
                  NUMSCO(NDISTR + 1,IRES,MXFILE + 1)
     -                = NUMSCO(NDISTR + 1,IRES,MXFILE + 1)
     -                + NUMSCO(NDISTR + 1,IRES,IFILE)
                  SCOMOD(NDISTR + 1,MXRES + 1,IFILE)
     -                = SCOMOD(NDISTR + 1,MXRES + 1,IFILE)
     -                + SCOMOD(NDISTR + 1,IRES,IFILE)
                  NUMSCO(NDISTR + 1,MXRES + 1,IFILE)
     -                = NUMSCO(NDISTR + 1,MXRES + 1,IFILE)
     -                + NUMSCO(NDISTR + 1,IRES,IFILE)
                  SCOMOD(NDISTR + 1,MXRES + 1,MXFILE + 1)
     -                = SCOMOD(NDISTR + 1,MXRES + 1,MXFILE + 1)
     -                + SCOMOD(NDISTR + 1,IRES,IFILE)
                  NUMSCO(NDISTR + 1,MXRES + 1,MXFILE + 1)
     -                = NUMSCO(NDISTR + 1,MXRES + 1,MXFILE + 1)
     -                + NUMSCO(NDISTR + 1,IRES,IFILE)
CHECK v.3.4.3<--
 100          CONTINUE
          ENDIF
 200  CONTINUE

C---- Loop through all the data to calculate mean values
      DO 400, IFILE = 1, MXFILE + 1

C----     Process only if this is one of the selected models
          IF (IFILE.EQ.MXFILE + 1) THEN
              WANTED = .TRUE.
          ELSE IF (MWANT(IFILE)) THEN
              WANTED = .TRUE.
          ELSE
              WANTED = .FALSE.
          ENDIF
          IF (WANTED) THEN

C----         Loop through all the residues
              DO 300, IRES = 1, MXRES + 1

C----             Calculate mean G-factor value for this residue in
C                 this model
CHECK v.3.4.3-->
C                  IF (NUMSCO(IRES,IFILE).GT.0) THEN
C                      SCOMOD(IRES,IFILE) = SCOMOD(IRES,IFILE)
C     -                    / NUMSCO(IRES,IFILE)
                  IF (NUMSCO(NDISTR + 1,IRES,IFILE).GT.0) THEN
                      SCOMOD(NDISTR + 1,IRES,IFILE)
     -                    = SCOMOD(NDISTR + 1,IRES,IFILE)
     -                    / NUMSCO(NDISTR + 1,IRES,IFILE)
CHECK v.3.4.3<--
                  ENDIF
 300          CONTINUE
          ENDIF
 400  CONTINUE

C---- Store the model-by-model G-factors
      DO 450, IFILE = 1, NFILE

C----     Store this structure's overall G-factor
CHECK v.3.4.3-->
C          SVALUE(5,IFILE) = SCOMOD(MXRES + 1,IFILE)
          SVALUE(5,IFILE) = SCOMOD(NDISTR + 1,MXRES + 1,IFILE)
CHECK v.3.4.3<--
 450  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4<--
C**************************************************************************
C
C  SUBROUTINE PINS  -   Produce the detailed residue-by-residue information
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINS(PLTYPE,NFILE)

      INCLUDE 'mplot.inc'

      INTEGER       NFILE
      CHARACTER*1   BRKCH, CHNEND, CIS, DAMINO, INCHN, LSTBRK, LSTCHN,
     -              NXTCHN, NXTCIS, NXTSST, OLDCHN, PINCIS(MXPINS),
     -              PINSST(MXPINS)
      CHARACTER*2   PINCHN(MXPINS)
      CHARACTER*3   PINRES(MXPINS), RESDUE
      CHARACTER*5   PINSNO(MXPINS)
CHECK v.3.4.4-->
C      INTEGER       BGAP, FGAP, FPIN, I, ICOUNT(NGFACT + 1), IDISTR,
      INTEGER       BGAP, FGAP, FPIN, I, ICOUNT(NDISTR + 1), IDISTR,
CHECK v.3.4.4<--
     -              IFILE, IGAP, IGFACT, IPOS, IRES, LINE, LINEA, NGAP,
     -              NPIN, PLTYPE, RCOUNT, THEPIN
      LOGICAL       BRKPOS(MXPINS), FIRST, PAGEND, PINDBL(MXPINS),
     -              PINOPE
      REAL          AVERGE, CALVAL, CHI1, LSTCHX, LSTCHY, OMEGA,
     -              PINACC(MXPINS), PINCV(NDISTR,MXPINS),
     -              PINDAT(MXFILE,MXPINS,3), PINDEV(2,MXPINS),
     -              PINSCO(NGFACT + 1,MXPINS)

      DATA BGAP, FGAP / 2, 10 /

C---- Initialise variables
      FIRST = .TRUE.
      NXTCIS = ' '
      PLTSTD(PLTCH1) = LIMRES * (SDEVGM + SDEVGT + SDEVGP) / 3.0
      PLTSTD(PLTOME) = LIMRES * SDEVOM
      PLTSTD(PLTCAL) = LIMRES * SDEVDH
      DO 50, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          DO 10, IDISTR = 1, NDISTR
              PINCV(IDISTR,NPIN) = 999.9
 10       CONTINUE
          DO 20, IFILE = 1, MXFILE
              PINDAT(IFILE,NPIN,1) = 999.9
              PINDAT(IFILE,NPIN,2) = 999.9
              PINDAT(IFILE,NPIN,3) = 999.9
 20       CONTINUE
          PINDEV(1,NPIN) = 0.0
          PINDEV(2,NPIN) = 0.0
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 40, IGFACT = 1, NGFACT + 1
              PINSCO(IGFACT,NPIN) = 999.99
 40       CONTINUE
          PINDBL(NPIN) = .FALSE.
          PINSNO(NPIN) = ' '
 50   CONTINUE
      PINOPE = .FALSE.
CHECK v.3.4.4-->
      DO 60, IGFACT = 1, NDISTR + 1
          ICOUNT(IGFACT) = 0
          GFACTR(IGFACT) = 0.0
 60   CONTINUE
CHECK v.3.4.4<--

C---- Initialise variables
      BRKCH = ' '
      CHNEND = '>'
      FPIN = 0
      INCHN = ' '
      LINE = 0
      LINEA = 0
      LSTBRK = ' '
      LSTCHN = ' '
      NPIN = 0
      OLDCHN = ' '
      THEPIN = MXPINS
      IF (NRES.LT.MXPINS .AND. NRES.GT.2) THEPIN = NRES
      THEPIN = MXPINS

C---- Calculate maximum values

C---- Adjust maximum values, if necessary
      DO 80, I = 1, MXPLOT
          PINMAX(I) = 1.1 * PINMAX(I)
          IF (PINMAX(I).LT.1.0) THEN
              PINMAX(I) = 1.0
          ELSE IF (PINMAX(I).LT.1.5) THEN
              PINMAX(I) = 1.5
          ELSE IF (PINMAX(I).LT.2.0) THEN
              PINMAX(I) = 2.0
          ELSE IF (PINMAX(I).LT.5.0) THEN
              PINMAX(I) = 5.0
          ELSE IF (PINMAX(I).LT.10.0) THEN
              PINMAX(I) = 10.0
          ELSE IF (PINMAX(I).LT.15.0) THEN
              PINMAX(I) = 15.0
          ELSE IF (PINMAX(I).LT.20.0) THEN
              PINMAX(I) = 20.0
          ELSE IF (PINMAX(I).LT.30.0) THEN
              PINMAX(I) = 30.0
          ELSE IF (PINMAX(I).LT.40.0) THEN
              PINMAX(I) = 40.0
          ELSE IF (PINMAX(I).LT.50.0) THEN
              PINMAX(I) = 50.0
          ELSE IF (PINMAX(I).LT.100.0) THEN
              PINMAX(I) = 100.0
          ELSE IF (PINMAX(I).LT.125.0) THEN
              PINMAX(I) = 125.0
          ELSE IF (PINMAX(I).LT.150.0) THEN
              PINMAX(I) = 120.0
          ELSE IF (PINMAX(I).LT.200.0) THEN
              PINMAX(I) = 200.0
          ELSE IF (PINMAX(I).LT.500.0) THEN
              PINMAX(I) = 500.0
          ENDIF
 80   CONTINUE

C---- Calculate the average residue-by-residue and overall G-factors
      DO 200, IRES = 1, NRES
          AVERGE = 0.0
          RCOUNT = 0

C----     Calculate average for this residue
          DO 100, IGFACT = 1, NGFACT

C----         If this is a Chi-1 distrib, and the residue already
C             has a G-factor for the chi1-chi2 distrib, then discard
C             it
              IF (IGFACT.EQ.3 .AND. GFACT(2,IRES).LT.900.0)
     -            GFACT(3,IRES) = 999.9

C----         Accumulate averages
              IF (GFACT(IGFACT,IRES).LT.900.0) THEN
                  AVERGE = AVERGE + GFACT(IGFACT,IRES)
                  RCOUNT = RCOUNT + 1
                  ICOUNT(IGFACT) = ICOUNT(IGFACT) + 1
                  GFACTR(IGFACT) = GFACTR(IGFACT) + GFACT(IGFACT,IRES)
CHECK v.3.4.4-->
C                  ICOUNT(NGFACT + 1) = ICOUNT(NGFACT + 1) + 1
                  ICOUNT(NDISTR + 1) = ICOUNT(NDISTR + 1) + 1
CHECK v.3.4.4<--
CHECK v.3.4.3-->
C                  GFACTR(NGFACT + 1) = GFACTR(NGFACT + 1)
C     -                + GFACT(IGFACT,IRES)
CHECK v.3.4.3<--
CHECK v.3.4.4-->
                  GFACTR(NDISTR + 1) = GFACTR(NDISTR + 1)
     -                + GFACT(IGFACT,IRES)
CHECK v.3.4.4<--
              ENDIF
 100      CONTINUE

C----     Store the average G-factor score for this residue
          IF (RCOUNT.NE.0) AVERGE = AVERGE / RCOUNT
CHECK v.3.4.3-->
C          GFACT(NGFACT + 1,IRES) = AVERGE
          GFACT(NDISTR + 1,IRES) = AVERGE
CHECK v.3.4.3<--
 200  CONTINUE

C---- Calculate overall means
CHECK v.3.4.4-->
      ICOUNT(NGFACT + 1) = ICOUNT(NDISTR + 1)
      GFACTR(NGFACT + 1) = GFACTR(NDISTR + 1)
CHECK v.3.4.4<--
CHECK v.3.4.3-->
C      DO 300, IGFACT = 1, NGFACT + 1
CHECK v.3.4.4-->
C      DO 300, IGFACT = 1, NGFACT
      DO 300, IGFACT = 1, NGFACT + 1
CHECK v.3.4.4<--
CHECK v.3.4.3<--
          IF (ICOUNT(IGFACT).NE.0) THEN
              GFACTR(IGFACT) = GFACTR(IGFACT) / ICOUNT(IGFACT)
          ENDIF
 300  CONTINUE

C---- Loop through all the residues in the sequence to produce all the
C     pins plots
      DO 1000, IPOS = 1, NRES

C----     Get the pointer to the next residue
          IF (IPOS.EQ.1) THEN
              IRES = FSTRES
          ELSE
              IRES = NXTRES(IRES)
          ENDIF
          NPIN = NPIN + 1
          RESDUE = VALSNO(IRES)(7:9)
          IF (DOUBL(IRES)) PINDBL(NPIN) = .TRUE.

C----     Initialise cis-peptide and D-amino acid markers
          CIS = NXTCIS
          NXTCIS = ' '
          DAMINO = ' '

C----     Adjust all the values that might be plotted so that the values
C         stored are the absolute deviations from the ideals
          DO 500, IFILE = 1, NFILE

CHECK v.3.4-->
C----         Process only if this is one of the selected models
              IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----             Chi-1 (excl. PRO)
                  CHI1 = VALUE(LOCHI1,IRES,IFILE)
                  IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
                  IF (RESDUE.EQ.'PRO') CHI1 = 999.9
                  IF (CHI1.GE.0.0 .AND. CHI1.LE.120.0) THEN
                      CHI1 = ABS(CHI1 - GLOBGM)
                  ELSE IF (CHI1.GT.120.0 .AND. CHI1.LE.240.0) THEN
                      CHI1 = ABS(CHI1 - GLOBGT)
                  ELSE IF (CHI1.GT.240.0 .AND. CHI1.LE.360.0) THEN
                      CHI1 = ABS(CHI1 - GLOBGP)
                  ELSE
                      CHI1 = 999.9
                  ENDIF
                  VALUE(LOCHI1,IRES,IFILE) = CHI1

C----             Case of trans peptide (ie 315 > omega > 45) 
                  OMEGA = VALUE(LOCOME,IRES,IFILE)
                  IF (OMEGA.GE.45.0 .AND. OMEGA.LE.315.0) THEN
                      OMEGA = ABS(OMEGA - GLOBOM)

C----             Case of cis peptide (ie abs(omega) < 45) 
                  ELSE IF (ABS(OMEGA).LT.900.0) THEN
                      NXTCIS = 'c'
                  ELSE
                      OMEGA = 999.9
                  ENDIF
                  VALUE(LOCOME,IRES,IFILE) = OMEGA

C----             Alpha carbon chirality
                  CALVAL = VALUE(LOCZET,IRES,IFILE)
                  IF (CALVAL.LT.900.0) THEN
                      IF (CALVAL.LT.0) DAMINO = 'D'
                      CALVAL = ABS(CALVAL - GLOBDH)
                  ENDIF
                  VALUE(LOCZET,IRES,IFILE) = CALVAL
CHECK v.3.4-->
              ENDIF
CHECK v.3.4<--
 500      CONTINUE

C----     Move required values across into plot-arrays
          IF (PLTNUM(1).GT.0) THEN
              DO 550, IFILE = 1, NFILE
                  PINDAT(IFILE,NPIN,1) = VALUE(DATLOC(1),IRES,IFILE)
 550          CONTINUE
          ENDIF
          IF (PLTNUM(2).GT.0) THEN
              DO 600, IFILE = 1, NFILE
                  PINDAT(IFILE,NPIN,2) = VALUE(DATLOC(2),IRES,IFILE)
 600          CONTINUE
          ENDIF
          IF (PLTNUM(3).GT.0) THEN
              DO 650, IFILE = 1, NFILE
                  PINDAT(IFILE,NPIN,3) = VALUE(DATLOC(3),IRES,IFILE)
 650          CONTINUE
          ENDIF

C----     Transfer the plot details for this residue into the pin arrays
          PINACC(NPIN) = VALOOI(IRES)
          IF (CIS.EQ.'c' .AND. DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = 'X'
          ELSE IF (CIS.EQ.'c') THEN
              PINCIS(NPIN) = CIS
          ELSE IF (DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = DAMINO
          ENDIF
          DO 700, IDISTR = 1, NDISTR
              PINCV(IDISTR,NPIN) = CIRCVR(IDISTR,IRES)
 700      CONTINUE
          PINRES(NPIN) = RESDUE
          DO 750, IGFACT = 1, NGFACT + 1
CHECK v.3.4.3-->
              IF (IGFACT.EQ.NGFACT + 1) THEN
                  PINSCO(IGFACT,NPIN) = GFACT(NDISTR + 1,IRES)
              ELSE
CHECK v.3.4.3<--
                  PINSCO(IGFACT,NPIN) = GFACT(IGFACT,IRES)
CHECK v.3.4.3-->
              ENDIF
CHECK v.3.4.3<--
 750      CONTINUE
          PINSNO(NPIN) = VALSNO(IRES)(2:6)
          PINSST(NPIN) = CONSST(IRES)
          IF (NPIN.EQ.NRES) THEN
              NXTSST = '='
          ELSE
              NXTSST = CONSST(IRES + 1)
          ENDIF
          OLDCHN = INCHN
          INCHN = VALSNO(IRES)(1:1)
          CHNEND = ' '
          IF (IPOS.EQ.1) THEN
              CHNEND = '>'
              OLDCHN = INCHN
          ENDIF
          IF (IPOS.EQ.NRES) CHNEND = '<'
          PINCHN(NPIN) = INCHN // CHNEND
          NXTCHN = INCHN
CHECK v.3.4-->
          BRKCH = CHNBRK(IRES)
CHECK v.3.4<--

C----     Transfer the RMS deviation
          PINDEV(1,NPIN) = RMSALL(1,IRES)
          PINDEV(2,NPIN) = RMSALL(2,IRES)

C----     Write the data out to the output .edt file
          WRITE(13,760) VALSNO(IRES), (PINCV(IDISTR,NPIN),
     -        IDISTR = 1, NDISTR), PINDEV(1,NPIN), PINDEV(2,NPIN),
     -        (PINSCO(IGFACT,NPIN), IGFACT = 1, NGFACT + 1)
 760      FORMAT(A9,6(1X,F7.3),2(1X,F7.3),4(1X,F6.2))

C----     Determine whether at a chain-end or chain-start
          IF (NPIN.GT.0) THEN
              IF (OLDCHN.NE.NXTCHN) THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (OLDCHN.NE.LSTCHN) THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.'!') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.' ') THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
CHECK v.3.4-->
              ELSE IF (BRKCH.EQ.'x') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
CHECK v.3.4<--
              ENDIF
              LSTBRK = BRKCH
              LSTCHN = OLDCHN
          ENDIF

C----     If have a pageful of data, then produce the pinplot
          IF (NPIN.EQ.THEPIN) THEN
              IF (PLOTPN) THEN

C----             If current PostScript file is open, close it
                  IF (PINOPE) THEN
                      CALL PSENDP
                      IF (.NOT.COMBPS) THEN
                          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                      ENDIF
                  ENDIF

C----             Produce current page
                  CALL PINPLT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,PINRES,
     -                PINSST,PINCHN,PINSNO,BRKPOS,PINACC,
     -                PINSCO,PINCIS,PINCV,LSTCHX,LSTCHY,PLTYPE,
     -                FIRST,NFILE,PINDBL,NXTSST)
                  FIRST = .FALSE.
                  PINOPE = .TRUE.
              ENDIF
              FPIN = FPIN + THEPIN
              NPIN = 0
              CHNEND = ' '
          ENDIF

C----     Check whether this residue is the end of a chain
          IF (CHNEND.EQ.'<' .OR. CHNEND.EQ.'!') THEN

C----         Leave the appropriate number of blanks between the chains
              PAGEND = .FALSE.
              IF (CHNEND.EQ.'<') THEN
                  NGAP = FGAP
              ELSE
                  NGAP = BGAP
              ENDIF
              DO 800, IGAP = 1, NGAP

C----             Add blanks providing that haven't reached end of page
                  IF (.NOT.PAGEND .AND. IPOS.NE.NRES) THEN
                      NPIN = NPIN + 1
                      BRKPOS(NPIN) = .TRUE.

C----                 If have a pageful of data, then produce the pinplot
                      IF (NPIN.EQ.THEPIN) THEN
                          IF (PLOTPN) THEN

C----                         If current PostScript file is open, close it
                              IF (PINOPE) THEN
                                  CALL PSENDP
                                  IF (.NOT.COMBPS) THEN
                                      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,
     -                                    BBOXY2)
                                  ENDIF
                              ENDIF

C----                         Produce current page
                              CALL PINPLT(THEPIN,NPIN,FPIN,PINDAT,
     -                            PINDEV,PINRES,PINSST,PINCHN,PINSNO,
     -                            BRKPOS,PINACC,PINSCO,PINCIS,PINCV,
     -                            LSTCHX,LSTCHY,PLTYPE,FIRST,NFILE,
     -                            PINDBL,NXTSST)
                              FIRST = .FALSE.
                              PINOPE = .TRUE.
                          ENDIF
                          FPIN = FPIN + THEPIN
                          NPIN = 0
                          CHNEND = ' '
                          PAGEND = .TRUE.
                      ENDIF
                  ENDIF
 800          CONTINUE
          ENDIF
 1000 CONTINUE

C---- If any more data left to be printed, then produce the pinplot
      IF (PLOTPN .AND. NPIN.GT.0) THEN

C----      If current PostScript file is open, close it
           IF (PINOPE) THEN
               CALL PSENDP
               IF (.NOT.COMBPS) THEN
                   CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
               ENDIF
           ENDIF

C----     Produce current page
          CALL PINPLT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,PINRES,
     -        PINSST,PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,
     -        PINCV,LSTCHX,LSTCHY,PLTYPE,FIRST,NFILE,PINDBL,NXTSST)
          FIRST = .FALSE.
          PINOPE = .TRUE.
      ENDIF

C---- Plot the overall G-factors for the protein as a whole on the
C     PROCHECKer board
      IF (PLOTPN) THEN
          CALL PINGFS(LSTCHX,XGAP,LSTCHY,YCHQHT,GFACTR,NGFACT + 1,
CHECK v.3.4-->
C     -        INCOLR,MXCOLR,RGB,COLPLT(7,PLTYPE),COLPLT(8,PLTYPE))
     -        INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(7,PLTYPE),
     -        COLPLT(8,PLTYPE),MINSHD,VALLOW,VALUPP)
CHECK v.3.4<--
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINPLT  -  Print current page for pin plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINPLT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,PINRES,PINSST,
     -    PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,PINCV,LSTCHX,
     -    LSTCHY,PLTYPE,FIRST,NFILE,PINDBL,NXTSST)

      SAVE

      INCLUDE 'mplot.inc'

      REAL          DASCOY, DIALS, NOTEX1, NOTEX2, NOTEX3, NOTEY1,
     -              NOTEY2, RMSDVY, SECSTY, SEQRMY
      PARAMETER    (
     -              DASCOY = 214.0,
     -              DIALS  = 132.0,
     -              NOTEX1 =  89.0,
     -              NOTEX2 =  77.0,
     -              NOTEX3 = 152.0,
     -              NOTEY1 =  19.0,
     -              NOTEY2 =  27.0,
     -              RMSDVY = -73.0,
     -              SECSTY =   0.0,
     -              SEQRMY =  71.0
     -             )

      REAL          SIZLAB, TSIZE
      PARAMETER    (
     -              SIZLAB =  10.0,
     -              TSIZE  =  15.0
     -             )

      INTEGER       THEPIN, NFILE

      CHARACTER*1   A, NXTSST, PINCIS(THEPIN), PINSST(THEPIN), RCHAR
      CHARACTER*2   PAGENO, PINCHN(THEPIN)
      CHARACTER*3   CODE(20), PINRES(THEPIN)
      CHARACTER*5   PINSNO(THEPIN), TICLAB(MXPINS)
      CHARACTER*7   PAGE
      CHARACTER*11  CLABEL(NGFACT + 1), VLABEL(NDISTR)
      CHARACTER*20  AMINO1
      CHARACTER*26  LOWER
      CHARACTER*30  PLDESC, PLTYHD(MXPLOT)
      CHARACTER*55  PLTHED(MXPLOT)
      CHARACTER*60  PTITLE
      CHARACTER*100 IREC 
      CHARACTER*120 TEXT
      INTEGER       FPIN, ICODE, ICONS, IDIST, IDISTR, IFILE, IGRAPH,
     -              IPIN, IRGRAF, N, NPAGE, NPIN, NSTD, PLOTNO,
     -              PLTHLN(MXPLOT), PLTYLN(MXPLOT), PLTYPE,
     -              TICLEN(MXPINS), VINDEX(MXRCON)
      LOGICAL       BRKPOS(MXPINS), DUPLIC, FIRST, PINDBL(MXPINS),
     -              TICPOS(MXPINS)
      REAL          LASTYP, LSTCHX, LSTCHY, PINACC(THEPIN),
     -              PINCV(NDISTR,THEPIN), PINDAT(MXFILE,MXPINS,3),
     -              PINDEV(2,THEPIN), PINSCO(NGFACT + 1,THEPIN),
     -              SCALEX, VVALUE(MXRCON), X, XCENTR, Y, YBOT, YDIFF,
     -              YP

      DATA  A      / 'A' /
      DATA  AMINO1 / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CLABEL /
     -               'Phi-psi',
     -               'Chi1-chi2',
     -               'Chi1 only',
     -               'Overall' /

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /
      DATA  NPAGE  / 0 /
      DATA  PLDESC / 'Residue properties plot' /

      DATA  PLTHED / 
     -    'x. Absolute deviation from mean Chi-1 value (excl. Pro)',
     -    'x. Absolute deviation from mean of omega torsion',
     -    'x. C-alpha chirality: abs. deviation of zeta torsion'
     -            /

      DATA  PLTHLN /  55, 48, 52 /

      DATA  PLTYHD /
     -    'Chi-1 abs. mean dev.',
     -    'Omega abs. mean dev.',
     -    'Zeta abs. mean dev.'
     -            /

      DATA  PLTYLN /  20, 20, 19 /

      DATA  PTITLE / 'Residue properties plot' /

      DATA  VLABEL /
     -               'Phi',
     -               'Psi',
     -               'Chi1',
     -               'Chi2',
     -               'Phi-psi',
     -               'Chi1-chi2' /

C---- Initialise variables
      DUPLIC = .FALSE.
      XCENTR = XPORIG + XPWID / 2.0
      YP = YPORIG + 3.0 * YPWID + 2.0 * YPSEP
      SCALEX = XPWID / THEPIN
      DO 50, ICONS = 1, MXRCON
          VVALUE(ICONS) = 0.0
          VINDEX(ICONS) = ICONS
 50   CONTINUE

C---- Open new PostScript file
      IF (.NOT.COMBPS .OR. FIRST) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,'residprop',WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(PLTYPE),PTITLE,
C     -        NPAGE + 1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,
     -        NPAGE + 1)
CHECK v.3.4<--
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
CHECK v.3.4-->
C     -    INCOLR(PLTYPE),COLPLT(1,PLTYPE),NPAGE + 1,PLABEL)
     -    INCOLR(PLTYPE),COLPLT(1,PLTYPE),NPAGE + 1,PLABEL, RSELEC)
CHECK v.3.4<--
      PLDESC = ' '
      CALL PSLWID(0.1)

C---- Main graph heading
      CALL PSCTXT(XCENTR,YP + 65.0,30.0,'Residue properties')
      CALL PSCTXT(XCENTR,YP + 36.0,25.0,TITLE(1:TLEN))

C---- Loop through the three graphs to be plotted (only two used)
      IRGRAF = 0
      NSTD = 0
      DO 100, IGRAPH = 1, 3

C----     Determine position on page
          YP = YPORIG + (3 - IGRAPH) * (YPWID + YPSEP)
          PLOTNO = PLTNUM(IGRAPH)
          IF (PLOTNO.GT.0) THEN

C----         Plot the graph box and axes
              IRGRAF = IRGRAF + 1
              PLTHED(PLOTNO)(1:1) = LOWER(IRGRAF:IRGRAF)
              CALL PINGRF(XPORIG,YP,XPWID,YPWID,BSHADE(PLTYPE),
     -            PINMAX(PLOTNO),FPIN,FPIN + THEPIN,PLTHED(PLOTNO),
     -            PLTHLN(PLOTNO),PLTYHD(PLOTNO),PLTYLN(PLOTNO),
     -            INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(2,PLTYPE),.FALSE.)

C----         Print the residue numbers along the x-axis
              CALL PINRNO(XPORIG,XPORIG + XPWID,YP,PINSNO,
     -            MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)

C----         Plot the ensemble data points on the graph
              CALL PINPTS(NPIN,NFILE,PINDAT(1,1,IGRAPH),XPORIG,YP,
     -            XPWID,YPWID,SCALEX,YPWID / PINMAX(PLOTNO),
     -            PLTSTD(PLOTNO),MXFILE,MXPINS,PHIGHT,
CHECK v.3.4-->
C     -            0.7 * DIARAD,.TRUE.,.FALSE.,.FALSE.)
     -            0.7 * DIARAD,.TRUE.,.FALSE.,.FALSE.,MWANT,NMODEL,
     -            TOPMOD)
CHECK v.3.4<--

              IF (PLTSTD(PLOTNO).NE.999.9) NSTD = NSTD + 1
              LASTYP = YP
          ENDIF
 100  CONTINUE

C---- Print number of deviations residues are highlighted by
      IF (NSTD.GT.0) THEN
          X = XPORIG + XPWID - NOTEX1
          YP = LASTYP - NOTEY1
          CALL PSTEXT(X,YP,8.0,
     -            'Dashed line corresponds to')
          X = XPORIG + XPWID - NOTEX2
          YP = LASTYP - NOTEY2
          WRITE(IREC,120) LIMRES
 120      FORMAT(F4.1,' st. devs. from ideal')
          CALL PSTEXT(X,YP,8.0,IREC(1:50))
          YP = YP - (NOTEY2 - NOTEY1)
      ELSE
          YP = LASTYP - NOTEY1
      ENDIF

C---- Print note explaining the model numbers on the plot
CHECK v.3.4-->
C      IF (NFILE.GT.1) THEN
      IF (NMODEL.GT.1) THEN
CHECK v.3.4<--
          X = XPORIG + XPWID - NOTEX3
          CALL PSTEXT(X,YP,8.0,
     -        'Numbers indicate models with highest deviation')
      ENDIF

C---- Print note explaining mean position and error bars
CHECK v.3.4-->
C      IF (NFILE.GT.2) THEN
      IF (NMODEL.GT.2) THEN
CHECK v.3.4<--
          X = XPORIG
          YP = LASTYP - NOTEY1
          CALL PSTEXT(X,YP,8.0,
     -        'Mean values indicated by circles')
          YP = LASTYP - NOTEY2
          CALL PSTEXT(X,YP,8.0,
     -        'Error bars show one standard deviation either side')
      ENDIF

C---- Show the overall RMS deviations for main-chain and sidechain atoms
C     in each residue
      IRGRAF = IRGRAF + 1
      Y = YPORIG - RMSDVY
CHECK v.3.2.1-->
C      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
C     -    '. RMS deviations: main-chain (black) and side-chain (grey)')
CHECK v.3.4-->
C      IF (NFILE.EQ.2) THEN
      IF (NMODEL.EQ.2) THEN
CHECK v.3.4<--
          CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -        '. Pairwise RMS deviations: main-chain (black) and si' //
     -        'de-chain (grey)')
      ELSE
          CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -        '. RMS devs from mean coords: main-chain (black) and ' //
     -        'side-chain (grey)')
      ENDIF
CHECK v.3.2.1<--
      Y = Y - 40.0
      IF (HAVRMS) THEN
          CALL PSLWID(0.0)
          CALL DVPLOT(XPORIG,SCALEX,Y,PINDEV,THEPIN,NPIN,
     -        MXCOLR,RGB,PINSST,PINDMX)
      ENDIF

C---- Add ticks at appropriate positions
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,BRKPOS,
     -    .FALSE.)

C---- Print the tick labels
      X = XPORIG + XGAP / 2.0
      Y = Y - TSIZE / 2.0
      DO 200, IPIN = 1, NPIN
          IF (TICPOS(IPIN)) THEN
              CALL PSCTXT(X,Y,SIZLAB,TICLAB(IPIN)(1:TICLEN(IPIN)))
          ENDIF
          X = X + XGAP
 200  CONTINUE

C---- Print the "wiring diagram" showing the secondary structure, with
C     background shading giving a measure of the accessibility
      IRGRAF = IRGRAF + 1
      Y = YPORIG - SECSTY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Secondary structure & average estimated accessibility')
      Y = Y - 18.0
      CALL PSLWID(0.0)
      IF (SHOWAC) THEN
CHECK v.3.5.3-->
C          CALL ACCSHD(THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
          CALL ACCSHD(MXPINS,THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
CHECK v.3.5.3<--
CHECK v.3.4-->
C     -        SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(5,PLTYPE),
C     -        COLPLT(6,PLTYPE))
     -        SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(6,PLTYPE),
     -        COLPLT(5,PLTYPE))
CHECK v.3.4<--
      ENDIF
CHECK v.3.5.3-->
C      CALL SSPLOT(THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRES,PINCHN,
      CALL SSPLOT(MXPINS,THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRES,PINCHN,
CHECK v.3.5.3<--
     -    SHOWAC,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(9,PLTYPE),
     -    COLPLT(5,PLTYPE),COLPLT(6,PLTYPE),.TRUE.,NXTSST)

C---- Print the residue codes
      IRGRAF = IRGRAF + 1
      Y = YPORIG - SEQRMY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Sequence & average estimated accessibilities')

C---- Print the legend explaining the accessibility icons
      X = 350.0
CHECK v.3.4-->
C      CALL ACDIAL(X,Y,DIARAD,90.0,INCOLR,MXCOLR,RGB,COLPLT(8,PLTYPE))
      CALL ACDIAL(X,Y,DIARAD,90.0,INCOLR(PLTYPE),MXCOLR,RGB,
     -    COLPLT(8,PLTYPE))
CHECK v.3.4<--
      X = 410.0
CHECK v.3.4-->
C      CALL ACDIAL(X,Y,DIARAD,10.0,INCOLR,MXCOLR,RGB,COLPLT(8,PLTYPE))
      CALL ACDIAL(X,Y,DIARAD,10.0,INCOLR(PLTYPE),MXCOLR,RGB,
     -    COLPLT(8,PLTYPE))
CHECK v.3.4<--
      X = 358.0
      CALL PSTEXT(X,Y,8.0,'Accessible')
      X = 418.0
      CALL PSTEXT(X,Y,8.0,'Buried')

C---- Show the accessibility dials
      Y = Y - 10.0
      CALL PINACD(XPORIG,SCALEX,Y,DIARAD,PINACC,THEPIN,NPIN,
     -    INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(8,PLTYPE),PINSST)

C---- Loop through the residues and print single-letter or three-letter
C     residue codes
      Y = Y - 20.0
      DO 400, IPIN = 1, NPIN
          X = XPORIG + (IPIN - 0.5) * SCALEX

C----     Find single-letter code for this residue
          ICODE = 0
          DO 300, N = 1, 20
              IF (PINRES(IPIN).EQ.CODE(N)) THEN
                  ICODE = N
                  GO TO 350
              ENDIF
 300      CONTINUE

C----     If not one of the standard 20, then print full 3-letter code
 350      CONTINUE
          IF (ICODE.EQ.0) THEN
              CALL PSCTXT(X,Y,8.0,PINRES(IPIN)(1:1))
              RCHAR = PINRES(IPIN)(2:2)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 6.0,8.0,RCHAR)
              RCHAR = PINRES(IPIN)(3:3)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 12.0,8.0,RCHAR)

C----     Otherwise, print the single-letter code
          ELSE
              RCHAR = AMINO1(ICODE:ICODE)
              CALL PSCTXT(X,Y,8.0,RCHAR)
          ENDIF

C----     Mark this residue if different residue types exist in the
C         different models
          IF (PINDBL(IPIN)) THEN
              CALL PSCSHD(0.0)
              CALL PSCIRC(X,Y + 10.0,1.8)
              CALL PSCSHD(0.0)
              CALL PSCIRC(X,YPORIG - RMSDVY - 40.0 + 3.0,1.5)
              DUPLIC = .TRUE.
          ENDIF
 400  CONTINUE

C---- Add ticks at appropriate positions
      YDIFF = SEQRMY + 24.0
      CALL PINTIC(XPORIG,YPORIG,YDIFF,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.FALSE.)

C---- If there have been any "duplicate" residues, print explanatory text
      IF (DUPLIC) THEN
          Y = Y - 18.0
          CALL PSCSHD(0.0)
          CALL PSCIRC(XPORIG,Y,1.8)
          TEXT = 'signifies different residue-types at this position' //
     -        ' in the different structures (shown side by side)'
          CALL PSTEXT(XPORIG + 8.0,Y,8.0,TEXT(1:101))
          Y = YPORIG - RMSDVY - 40.0 - 18.0
          CALL PSCSHD(0.0)
          CALL PSCIRC(XPORIG,Y,1.5)
          CALL PSTEXT(XPORIG + 8.0,Y,8.0,TEXT(1:101))
      ENDIF

C---- Show the circular variance dials
      IRGRAF = IRGRAF + 1
      Y = YPORIG - DIALS
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Circular variances')
      Y = Y - 10.0
      LSTCHY = Y
      CALL PINCIR(XPORIG,SCALEX,DIARAD * 2.6,Y,DIARAD,PINCV,THEPIN,
     -    NPIN,NDISTR,VLABEL,INCOLR(PLTYPE),MXCOLR,RGB,
     -    COLPLT(10,PLTYPE),PINSST)

C---- Show the chequer-board of log-odds scores
      IRGRAF = IRGRAF + 1
      Y = YPORIG - DASCOY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. G-factors')
      Y = Y - 12.0
      LSTCHY = Y
      CALL PINCHQ(XPORIG,SCALEX,Y,YCHQHT,PINSCO,THEPIN,NPIN,
     -    NGFACT + 1,CLABEL,INCOLR(PLTYPE),MXCOLR,RGB,
CHECK v.3.4-->
C     -    COLPLT(7,PLTYPE),COLPLT(8,PLTYPE),YBOT,PINSST,PINCIS,LSTCHX)
     -    COLPLT(7,PLTYPE),COLPLT(8,PLTYPE),YBOT,PINSST,PINCIS,LSTCHX,
     -    MINSHD,VALLOW,VALUPP)
CHECK v.3.4<--

C---- Add ticks at appropriate positions
      CALL PINTIC(XPORIG,YBOT,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.FALSE.)

C---- Print the tick labels
      X = XPORIG + XGAP / 2.0
      Y = YBOT - TSIZE / 2.0
      DO 700, IPIN = 1, NPIN
          IF (TICPOS(IPIN)) THEN
              CALL PSCTXT(X,Y,SIZLAB,TICLAB(IPIN)(1:TICLEN(IPIN)))
          ENDIF
          X = X + XGAP
 700  CONTINUE

C---- Print the page number on the plot
      NPAGE = NPAGE + 1
      WRITE(PAGENO,'(I2)') NPAGE
      PAGE = 'Page ' // PAGENO      
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

C---- Print program name in top left-hand corner
      IF (NMR) THEN
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-NMR')
      ELSE
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-COMP')
      ENDIF

C---- Re-initalise arrays
      DO 850, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          DO 820, IDISTR = 1, NDISTR
              PINCV(IDISTR,NPIN) = 999.9
 820      CONTINUE
          DO 830, IFILE = 1, MXFILE
              PINDAT(IFILE,NPIN,1) = 999.9
              PINDAT(IFILE,NPIN,2) = 999.9
              PINDAT(IFILE,NPIN,3) = 999.9
 830      CONTINUE
          PINDEV(1,NPIN) = 0.0
          PINDEV(2,NPIN) = 0.0
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 840, IDIST = 1, NGFACT + 1
              PINSCO(IDIST,NPIN) = 999.99
 840      CONTINUE
          PINDBL(NPIN) = .FALSE.
          PINSNO(NPIN) = ' '
 850  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C Routines PINVIO, PINVPT transferred to vplot.f
C Routines PINTIC, PINRNO, DHELIX transferred to ps.f
CHECK v.3.4<--
C**************************************************************************
C
C  SUBROUTINE PINGRF  -  Print current graph for pins plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINGRF(XPORIG,YP,XPWID,YPWID,BSHADE,YMAX,FPIN,
     -    LPIN,IREC,LIREC,JREC,LJREC,INCOLR,MXCOLR,RGB,COLOUR,SMALL)

      CHARACTER*110 IREC, JREC
      INTEGER       COLOUR, FPIN, INTRL, LPIN, LIREC, LJREC, MXCOLR
      LOGICAL       BSHADE, INCOLR, SMALL
      REAL          RGB(3,MXCOLR), SCALEY, XCENTR, XP, XPORIG, XPWID,
     -              YCENTR, YMAX, YP, YPWID
 
C---- Draw box and axis labels
      XP = XPORIG
      IF (BSHADE) THEN
          CALL PSHADE(0.996,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUBOX(XP,YP,XP,YP + YPWID,XP + XPWID,YP + YPWID,
     -        XP + XPWID,YP)
      ENDIF
      XCENTR = XPORIG + XPWID / 2.0
      YCENTR = YP + YPWID / 2.0
      IF (YMAX.EQ.0.0) YMAX = 1.0
      SCALEY = YPWID / YMAX
      INTRL = 0
      IF (YMAX.LE.3.0) INTRL = 1
      CALL AXES(XP,XP + XPWID,YP,YP + YPWID,0,5,REAL(FPIN),
     -    REAL(LPIN),0.0,YMAX,10.0,0,INTRL,15.0,.TRUE.,.TRUE.,
     -    .FALSE.,.FALSE.,.FALSE.)

C---- Sub-heading and x-axis title
      IF (SMALL) THEN
          CALL PSCTXT(XCENTR,YP + YPWID + 8.0,12.0,IREC(1:LIREC))
      ELSE
          CALL PSCTXT(XCENTR,YP + YPWID + 10.0,15.0,IREC(1:LIREC))
          CALL PSCTXT(XCENTR,YP - 20.0,10.0,'Residue number')
      ENDIF

C---- y-axis headings
      CALL PSRCTX(XPORIG - 28.0,YP + YPWID / 2.0,10.0,JREC(1:LJREC))

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE ACCSHD  -  Shade in the background of the secondary
C                        structure "wiring diagram" to give an indication
C                        of the relative accessibility
C
C----------------------------------------------------------------------+--- 

CHECK v.3.5.3-->
C      SUBROUTINE ACCSHD(THEPIN,NPIN,PINACC,PINSST,XP,YP,DX,
      SUBROUTINE ACCSHD(MXPINS,THEPIN,NPIN,PINACC,PINSST,XP,YP,DX,
CHECK v.3.5.3<--
     -    SSSIZE,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)

      SAVE

CHECK v.3.5.3-->
C      INTEGER       MXCOLR, NPIN, THEPIN
C      CHARACTER*1   PINSST(THEPIN), SECSTR
      INTEGER       MXCOLR, MXPINS, NPIN, THEPIN
      CHARACTER*1   PINSST(MXPINS), SECSTR
CHECK v.3.5.3<--
CHECK v.3.4-->
C      INTEGER       ISTRUC, IPIN, IRES, LSTRUC, MAXCOL, MINCOL
      INTEGER       IPIN, IRES, MAXCOL, MINCOL
CHECK v.3.4<--
      LOGICAL       BLANK, INCOLR
CHECK v.3.5.3-->
C      REAL          DX, HEIGHT, MINHT, PINACC(THEPIN), RGB(3,MXCOLR),
      REAL          DX, HEIGHT, MINHT, PINACC(MXPINS), RGB(3,MXCOLR),
CHECK v.3.5.3<--
     -              SHADE, SSSIZE, X, XP, X1, X2, Y, YDIFF, YP, Y1, Y2

CHECK v.3.4-->
C      DATA IRES,LSTRUC   / 0, 0 /
      DATA IRES   / 0 /
CHECK v.3.4<--

C---- Initialise values
      HEIGHT = SSSIZE * 2.3
      MINHT = HEIGHT
      X = XP
      Y = YP

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)
          IF (SECSTR.EQ.'=') THEN
              BLANK = .TRUE.
          ELSE
              BLANK = .FALSE.
              IRES = IRES + 1
          ENDIF

C----     If not off the end of a chain, draw a shaded patch according to
C         the accessibility
          IF (.NOT.BLANK) THEN
              X1 = X
              X2 = X + DX
              YDIFF = (HEIGHT - MINHT) * (1.0 - PINACC(IPIN) / 100.0)
              Y1 = Y - MINHT - YDIFF
              Y2 = Y + MINHT + YDIFF
              SHADE = PINACC(IPIN) / 100.0
              IF (SHADE.LT.0.0) SHADE = 0.0
              IF (SHADE.GT.1.0) SHADE = 1.0
              CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          ENDIF

C----     Increment x-position
          X = X + DX

CHECK v.3.4-->
C----     Save current structure
C          LSTRUC = ISTRUC
CHECK v.3.4<--
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SSPLOT  -  Draw the secondary structure "wiring diagram"
C
C----------------------------------------------------------------------+--- 

CHECK v.3.5.3-->
C      SUBROUTINE SSPLOT(THEPIN,NPIN,PINSST,XP,YP,DX,NRESID,PINCHN,
C     -    SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLOUR,MINACC,MAXACC,SHOWKY,
C     -    NXTSST)
      SUBROUTINE SSPLOT(MXPINS,THEPIN,NPIN,PINSST,XP,YP,DX,NRESID,
     -    PINCHN,SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLOUR,MINACC,MAXACC,
     -    SHOWKY,NXTSST)
CHECK v.3.5.3<--

      SAVE

      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

      REAL          ARRWID, COIWID, THICK, THIN
      PARAMETER    (
     -              ARRWID = 1.8,
     -              COIWID = 0.25,
     -              THICK  = 0.4,
     -              THIN   = 0.2
     -             )

CHECK v.3.5.3-->
C      INTEGER       MXCOLR, NPIN, THEPIN
C      CHARACTER*1   NXTSST, NXTSTR, PINSST(THEPIN), SECSTR
      INTEGER       MXCOLR, MXPINS, NPIN, THEPIN
      CHARACTER*1   NXTSST, NXTSTR, PINSST(MXPINS), SECSTR
CHECK v.3.5.3<--
      CHARACTER*2   PINCHN(THEPIN)
      INTEGER       COLOUR, FIRSTH, ISTRUC, IPIN, IRES, LENRUN, LSTRUC,
     -              MAXACC, MINACC, NRESID, SSLEN
      LOGICAL       INCOLR, SHOWAC, SHOWKY
      REAL          DX, HEIGHT, HWIDTH, RGB(3,MXCOLR), SSSIZE, X, XP,
     -              X1, X2, Y, YP, Y1, Y2


C---- Initialise values
      HEIGHT = SSSIZE * 1.5
      HWIDTH = SSSIZE * 1.5
      X = XP
      Y = YP
      LENRUN = 0
      IRES = 0
      LSTRUC = 0
      CALL PSLWID(THIN)

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     If this is the start of a chain, draw chain-start
          IF (PINCHN(IPIN)(2:2).EQ.'>' .AND.
     -        PINCHN(IPIN)(1:1).NE.' ') THEN
              CALL PSLINE(X,Y - SSSIZE * 0.6,X,Y + SSSIZE * 0.6)

C----         Print the chain identifier
              CALL PSTEXT(X - 10.0,Y,10.0,PINCHN(IPIN)(1:1))
          ENDIF

C----     If this is the end of a chain, draw chain-end
          IF (PINCHN(IPIN)(2:2).EQ.'<') THEN
              CALL PSLINE(X + DX,Y - SSSIZE * 0.6,X + DX,
     -            Y + SSSIZE * 0.6)
          ENDIF

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)
          IF (IPIN.LT.NPIN) THEN
              NXTSTR = PINSST(IPIN + 1)
          ELSE
              NXTSTR = NXTSST
          ENDIF
          IF (SECSTR.NE.'=') IRES = IRES + 1
          IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'G') THEN
              ISTRUC = HELIX
          ELSE IF (SECSTR.EQ.'E') THEN
              ISTRUC = STRAND
          ELSE IF (SECSTR.EQ.'=') THEN
              ISTRUC = BLANK
          ELSE
              ISTRUC = COIL
          ENDIF

C----     If coil, then draw a horizontal bar
          IF (ISTRUC.EQ.COIL) THEN

C----         Draw the current fragment of the coil
              X1 = X
              X2 = X + DX
              Y1 = Y - SSSIZE * COIWID
              Y2 = Y + SSSIZE * COIWID
              CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
              CALL PSLINE(X1,Y1,X2,Y1)
              CALL PSLINE(X1,Y2,X2,Y2)

C----         If this is the start of the coil, then start box
              IF (LSTRUC.NE.COIL) THEN
                  CALL PSLINE(X,Y1,X,Y2)
              ENDIF

C----         If this is the last residue of the coil, draw its end
              IF (NXTSTR.EQ.'E' .OR. NXTSTR.EQ.'H' .OR.
     -            NXTSTR.EQ.'G' .OR. IRES.EQ.NRESID) THEN
                  CALL PSLINE(X2,Y1,X2,Y2)
              ENDIF
              X = X + DX

C----     Else if it's a strand, draw a horizontal box
          ELSE IF (ISTRUC.EQ.STRAND) THEN
              
C----         If this is the last residue of the strand, draw the arrow-head
              IF (NXTSTR.NE.'E' .OR. IRES.EQ.NRESID) THEN
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - ARRWID * SSSIZE
                  Y2 = Y + ARRWID * SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
                  CALL PSLINE(X,Y2,X,Y + SSSIZE)
                  CALL PSLINE(X,Y1,X,Y - SSSIZE)
                  CALL PSLINE(X,Y2,X + DX,Y)
                  CALL PSLINE(X,Y1,X + DX,Y)
                  X = X + DX

C----         Otherwise, draw the current fragment of the strand
              ELSE
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - SSSIZE
                  Y2 = Y + SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X,Y - SSSIZE,X + DX,Y - SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
                  CALL PSLINE(X,Y + SSSIZE,X + DX,Y + SSSIZE)
                  X = X + DX
              ENDIF
                          
C----         If this is the start of the strand, then start box
              IF (LSTRUC.NE.STRAND) THEN
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X1,Y - SSSIZE,X1,Y + SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
              ENDIF

C----     Else if it's a helix, draw a sawtooth
          ELSE IF (ISTRUC.EQ.HELIX) THEN

C----         Increment count of helix residues in current helix
              LENRUN = LENRUN + 1
              IF (LENRUN.EQ.1) FIRSTH = IRES

C----         If at end of the helix, draw it
              IF (IRES.EQ.NRESID .OR. IPIN.EQ.NPIN .OR.
     -            (NXTSTR.NE.'H' .AND. NXTSTR.NE.'G')) THEN
                  CALL DHELIX(LENRUN,X,Y,FIRSTH,DX,HWIDTH,HEIGHT,
     -                SHOWAC,INCOLR,MXCOLR,RGB,COLOUR)
                  LENRUN = 0
              ENDIF
          ELSE
              X = X + DX
          ENDIF                          

C----     Save current structure
          LSTRUC = ISTRUC
 400  CONTINUE

C---- Show key to wiring diagram
      IF (SHOWKY) THEN
          X = XP
          Y = YP - 21.0
          CALL PSTEXT(X,Y,10.0,'Key:-')

C----     Helix
          X = XP + 27.0
          CALL DHELIX(4,X,Y,1,DX,HWIDTH,HEIGHT,SHOWAC,INCOLR,MXCOLR,
     -        RGB,COLOUR)
          X = X + 3.0
          CALL PSTEXT(X,Y,10.0,'Helix')

C----     Strand
          X = XP + 83.0
          X1 = X
          SSLEN = 2
          X2 = X + SSLEN * DX
          Y1 = Y - SSSIZE
          Y2 = Y + SSSIZE
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          IF (.NOT.SHOWAC) CALL PSLWID(THICK)
          CALL PSLINE(X1,Y1,X1,Y2)
          CALL PSLINE(X,Y - SSSIZE,X + SSLEN * DX,Y - SSSIZE)
          IF (.NOT.SHOWAC) CALL PSLWID(THIN)
          CALL PSLINE(X,Y + SSSIZE,X + SSLEN * DX,Y + SSSIZE)
          X = X + SSLEN * DX
          X1 = X
          X2 = X + DX
          Y1 = Y - ARRWID * SSSIZE
          Y2 = Y + ARRWID * SSSIZE
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
          CALL PSLINE(X,Y2,X,Y + SSSIZE)
          CALL PSLINE(X,Y1,X,Y - SSSIZE)
          CALL PSLINE(X,Y2,X + DX,Y)
          CALL PSLINE(X,Y1,X + DX,Y)
          X = X + DX + 4.0
          CALL PSTEXT(X,Y,10.0,'Beta strand')

C----     Coil
          X = XP + 161.0
          X1 = X
          SSLEN = 3
          X2 = X1 + SSLEN * DX
          Y1 = Y - SSSIZE * COIWID
          Y2 = Y + SSSIZE * COIWID
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          CALL PSLINE(X1,Y1,X2,Y1)
          CALL PSLINE(X1,Y2,X2,Y2)
          CALL PSLINE(X1,Y1,X1,Y2)
          CALL PSLINE(X2,Y1,X2,Y2)
          X = X + SSLEN * DX + 3.0
          CALL PSTEXT(X,Y,10.0,'Random coil')

C----     Accessibility shading
          IF (SHOWAC) THEN
              X = XP + 248.0
              Y1 = Y + 2.5
              Y2 = Y - 2.5
              IF (INCOLR) THEN
                  CALL PSTEXT(X,Y,8.0,'Accessibility shading:')
                  X1 = X + 80.0
                  X2 = X1 + 5.0
                  CALL PSHADE(0.0,MINACC,RGB,MXCOLR,INCOLR)
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                  X = X2 + 7.0
                  CALL PSTEXT(X,Y,8.0,'Buried')
                  X1 = X + 34.0
                  X2 = X1 + 5.0
                  CALL PSHADE(0.0,MAXACC,RGB,MXCOLR,INCOLR)
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                  X = X2 + 7.0
                  CALL PSTEXT(X,Y,8.0,'Accessible')
              ELSE
                  CALL PSTEXT(X,Y,8.0,'Accessibility shading: Black=' //
     -                'buried, White=accessible')
              ENDIF
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINCHQ  -  Print the chequer-board (the PROCHECKer board)
C                        of log-odds scores
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINCHQ(XPORIG,XGAP,YP,YHT,PINSCO,THEPIN,NPIN,NDISTR,
     -    CLABEL,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL,YBOT,PINSST,PINCIS,
CHECK v.3.4-->
C     -    LSTCHX)
     -    LSTCHX,MINSHD,VALLOW,VALUPP)
CHECK v.3.4<--

      SAVE

      INTEGER       MXCOLR, NDISTR, THEPIN
      REAL          MINSHD, VALLOW, VALUPP
CHECK v.3.4-->
C      PARAMETER    (
C     -              MINSHD =  0.995,
C     -              VALLOW =  0.00,
C     -              VALUPP = -3.00
C     -             )
CHECK v.3.4<--

      CHARACTER*1   PINCIS(THEPIN), PINSST(THEPIN), SECSTR
      CHARACTER*11  CLABEL(NDISTR)
      CHARACTER*100 STRING
      INTEGER       IDISTR, IPIN, MAXCOL, MINCOL, NBOTH, NCIS, NDAM,
     -              NPIN, SLEN
      LOGICAL       INCOLR
      REAL          LSTCHX, PINSCO(NDISTR,THEPIN), RGB(3,MXCOLR),
     -              SHADE, VALUE, X1, X2, XDIFF, XGAP, XL, XPORIG, XR,
     -              Y1, Y2, YBOT, YHT, YP
 
C---- Initialise values
      NBOTH = 0
      NCIS = 0
      NDAM = 0
      XDIFF = (XGAP - YHT) / 2.0
      X1 = XPORIG - 35.0
      Y1 = YP - YHT / 2.0

C---- Print the row headings
      DO 100, IDISTR = 1, NDISTR
          CALL PSTEXT(X1,Y1,6.0,CLABEL(IDISTR))
          Y1 = Y1 - YHT
          IF (IDISTR.EQ.NDISTR - 1) Y1 = Y1 - YHT * 1.5
 100  CONTINUE

C---- Reinitialise
      X1 = XPORIG

C---- Lop through the residues to be processed
      DO 800, IPIN = 1, NPIN
          X2 = X1 + XGAP
          XL = X1 + XDIFF
          XR = X2 - XDIFF
          Y1 = YP

C----     Process if not within a chain-break
          SECSTR = PINSST(IPIN)
          IF (SECSTR.NE.'=') THEN

C----         If this is a cis-peptide or a D-amino acid, plot a marker
C             accordingly
              IF (PINCIS(IPIN).NE.' ') THEN
                  CALL PSCTXT((X1 + X2) / 2.0,Y1 + YHT * 0.75,6.0,
     -                PINCIS(IPIN))
                  IF (PINCIS(IPIN).EQ.'c') NCIS = NCIS + 1
                  IF (PINCIS(IPIN).EQ.'D') NDAM = NDAM + 1
                  IF (PINCIS(IPIN).EQ.'X') NBOTH = NBOTH + 1
              ENDIF

C----         Loop through the different distribution types
              DO 300, IDISTR = 1, NDISTR

C----             Calculate y-extent of current box and its shade
                  Y2 = Y1 - YHT
                  VALUE = PINSCO(IDISTR,IPIN)
                  IF (VALUE.GT.999.0) THEN
                      SHADE = 1.0
                  ELSE
                      IF (VALUE.GT.VALLOW) THEN
                          SHADE = MINSHD
                      ELSE IF (VALUE.LE.VALUPP) THEN
                          SHADE = 0.0
                      ELSE
                          SHADE = MINSHD
     -                        - MINSHD * (VALUE - VALLOW)
     -                        / (VALUPP - VALLOW)
                      ENDIF
                  ENDIF

C----             Plot the box
                  IF (VALUE.LT.900.0) THEN
                      CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,MINCOL,
     -                    MAXCOL)
                      CALL PSBBOX(XL,Y1,XR,Y1,XR,Y2,XL,Y2)
                  ENDIF

C----             Increment y-value for next block
                  Y1 = Y2
                  IF (IDISTR.EQ.NDISTR - 1) Y1 = Y1 - YHT * 1.5
 300          CONTINUE


C----         If this is a cis-peptide or a D-amino acid, plot a marker
C             accordingly
              IF (PINCIS(IPIN).NE.' ') THEN
                  CALL PSCTXT((X1 + X2) / 2.0,Y1 + YHT * 1.75,6.0,
     -                PINCIS(IPIN))
              ENDIF
          ENDIF

C----     Increment x-value for next residue
          X1 = X2
 800  CONTINUE

C---- Return the last x- and y-value
      LSTCHX = X2
      YBOT = Y2

C---- If any cis-peptides or D-amino acids, print key at bottom of page
      STRING = ' '
      SLEN = 0
      IF (NCIS.GT.0) THEN
          STRING = 'c = cis-peptide'
          SLEN = 15
      ENDIF
      IF (NDAM.GT.0) THEN
          STRING = STRING(1:SLEN) // '    ' // 'D = D-amino acid'
          SLEN = SLEN + 20
      ENDIF
      IF (NBOTH.GT.0) THEN
          STRING = STRING(1:SLEN) // '    ' //
     -        'X = cis-peptide & D-amino acid'
          SLEN = SLEN + 34
      ENDIF
      IF (SLEN.GT.0) THEN
          CALL PSTEXT(XPORIG,YBOT - 22.0,8.0,STRING(1:SLEN))
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINCIR  -  Print the circular variance dials for each of the
C                        ensemble distributions
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINCIR(XPORIG,XGAP,YGAP,YP,RADIUS,PINCV,THEPIN,NPIN,
     -    NDISTR,VLABEL,INCOLR,MXCOLR,RGB,DIACOL,PINSST)

      SAVE

      INTEGER       MXCOLR, NDISTR, THEPIN

      CHARACTER*1   PINSST(THEPIN), SECSTR
      CHARACTER*11  VLABEL(NDISTR)
      INTEGER       IDISTR, IPIN, DIACOL, NPIN
      LOGICAL       INCOLR
      REAL          ANGBEG, ANGEND, CIRVAR, PINCV(NDISTR,THEPIN),
     -              RADIUS, RGB(3,MXCOLR), X1, XGAP, XPORIG, Y1, YGAP,
     -              YP
 
C---- Initialise values
      X1 = XPORIG - 35.0
      Y1 = YP - RADIUS

C---- Print the row headings
      DO 100, IDISTR = 1, NDISTR
          CALL PSTEXT(X1,Y1,6.0,VLABEL(IDISTR))
          Y1 = Y1 - YGAP
 100  CONTINUE

C---- Reinitialise
      X1 = XPORIG + RADIUS

C---- Lop through the residues to be processed
      DO 800, IPIN = 1, NPIN
          Y1 = YP - RADIUS

C----     Process if not within a chain-break
          SECSTR = PINSST(IPIN)
          IF (SECSTR.NE.'=') THEN

C----         Loop through the different distribution types
              DO 300, IDISTR = 1, NDISTR

C----             Get the circular variance
                  CIRVAR = PINCV(IDISTR,IPIN)

C----             Plot the circular variance dial
                  IF (CIRVAR.LT.900.0) THEN
                      ANGBEG = 90.0 - CIRVAR * 360.0
                      IF (ANGBEG.LT.0.0) ANGBEG = ANGBEG + 360.0
                      ANGEND = 90.0
                      CALL PSLWID(0.05)
                      IF (INCOLR) THEN
                          CALL PSCCOL(RGB(1,DIACOL),RGB(2,DIACOL),
     -                        RGB(3,DIACOL))
                      ELSE
                          CALL PSCSHD(1.0)
                      ENDIF
                      CALL PSCIRC(X1,Y1,RADIUS)
                      CALL PSLWID(0.0)
                      CALL PSCSHD(0.0)
                      CALL PSPCIR(X1,Y1,RADIUS,ANGBEG,ANGEND)
                      CALL PSLWID(0.1)
                  ENDIF

C----             Increment y-value for next block
                  Y1 = Y1 - YGAP
 300          CONTINUE
          ENDIF

C----     Increment x-value for next residue
          X1 = X1 + XGAP
 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINACD  -  Print schematic dials showing the residue's
C                        main-chain accessibility
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINACD(XPORIG,XGAP,YP,RADIUS,PINACC,THEPIN,NPIN,
     -    INCOLR,MXCOLR,RGB,DIACOL,PINSST)

      SAVE

      INTEGER       MXCOLR, THEPIN

      CHARACTER*1   PINSST(THEPIN), SECSTR
      INTEGER       IPIN, DIACOL, NPIN
      LOGICAL       INCOLR
      REAL          PINACC(THEPIN), RADIUS, RGB(3,MXCOLR),
     -              X, XGAP, XPORIG, Y, YP

C---- Initialise values
      X = XPORIG + RADIUS
      Y = YP - RADIUS

C---- Lop through the residues to be processed
      DO 800, IPIN = 1, NPIN

C----     Process if not within a chain-break
          SECSTR = PINSST(IPIN)
          IF (SECSTR.NE.'=') THEN

C----         Plot the accessibility icon
              CALL ACDIAL(X,Y,RADIUS,PINACC(IPIN),INCOLR,MXCOLR,
     -            RGB,DIACOL)
          ENDIF

C----     Increment x-value for next residue
          X = X + XGAP
 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE ACDIAL  -  Plot a schematic dial showing the residue's
C                        main-chain accessibility
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE ACDIAL(X,Y,RADIUS,PINACC,INCOLR,MXCOLR,RGB,DIACOL)

      SAVE

      INTEGER       MXCOLR

      INTEGER       DIACOL
      LOGICAL       INCOLR
      REAL          ACCESS, ANGBEG, ANGDIF, ANGEND, ANGLE,
     -              CRAD, MAXCRD, MINCRD, PI, PINACC, RADDEG, RADIUS,
     -              RGB(3,MXCOLR), SPRAD, X, XC, X1, X2, Y, YC, Y1, Y2

      PARAMETER    (ANGDIF = 30.0)
      PARAMETER    (PI = 3.141592654, RADDEG = 180.0 / PI)

C---- Initialise values
      MINCRD = 0.15 * RADIUS
      MAXCRD = 0.6 * RADIUS
      SPRAD = RADIUS

C---- Convert accessibility to degree range
      ACCESS = 360.0 * (1.0 - (PINACC / 100.0))

C---- Plot the spokes
      ANGBEG = 0.0
 100  CONTINUE
          ANGLE = (ANGBEG + 90.0) / RADDEG
          XC = SPRAD * COS(ANGLE)
          YC = SPRAD * SIN(ANGLE)
          X1 = X - XC
          X2 = X + XC
          Y1 = Y - YC
          Y2 = Y + YC
          CALL PSLINE(X1,Y1,X2,Y2)
          ANGBEG = ANGBEG + ANGDIF
      IF (ANGBEG.LT.360.0) GO TO 100

C---- Plot the accessibility dial
      ANGBEG = 270.0 - ACCESS / 2.0
      IF (ANGBEG.LT.0.0) ANGBEG = ANGBEG + 360.0
      ANGEND = 270.0 + ACCESS / 2.0
      IF (ANGEND.GT.360.0) ANGEND = ANGEND - 360.0
      CALL PSLWID(0.05)
      IF (INCOLR) THEN
          CALL PSCCOL(RGB(1,DIACOL),RGB(2,DIACOL),RGB(3,DIACOL))
      ELSE
          CALL PSCSHD(1.0)
      ENDIF
      CALL PSPCIR(X,Y,RADIUS,ANGBEG,ANGEND)

C---- Plot the core of the dial
      CALL PSCSHD(0.0)
      CRAD = MINCRD + (MAXCRD - MINCRD) * (PINACC / 100.0)
      CALL PSCIRC(X,Y,CRAD)

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C Routine CNPLOT transferred to vplot.f
CHECK v.3.4<--
C**************************************************************************
C
C  SUBROUTINE DVPLOT  -  Plot the residue-by-residue main-chain and
C                        side-chain RMS deviations
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE DVPLOT(XPORIG,XGAP,YP,PINDEV,THEPIN,NPIN,MXCOLR,RGB,
     -    PINSST,PINDMX)

      SAVE

      REAL          DEVHT
      PARAMETER    (
     -              DEVHT  = 25.0
     -             )

      INTEGER       MXCOLR, THEPIN

      CHARACTER*1   PINSST(THEPIN), SECSTR
      CHARACTER*5   CNUMB
      INTEGER       IPIN, ITIK, NPIN, NTIK
      REAL          MAXDEV, PINDEV(2,THEPIN), PINDMX, RGB(3,MXCOLR), X,
     -              XGAP, XPORIG, X1, X2, Y, YP, Y1, Y2

C---- Initialise values
      CALL PSLWID(0.1)
      X = XPORIG
      Y = YP

C---- Calculate maximum scale
      IF (PINDMX.LE.0.5) THEN
          MAXDEV = 0.5
          NTIK = 5
      ELSE IF (PINDMX.LE.1.0) THEN
          MAXDEV = 1.0
          NTIK = 2
      ELSE IF (PINDMX.LE.2.0) THEN
          MAXDEV = 2.0
          NTIK = 2
      ELSE IF (PINDMX.LE.3.0) THEN
          MAXDEV = 3.0
          NTIK = 3
      ELSE IF (PINDMX.LE.4.0) THEN
          MAXDEV = 4
          NTIK = 4
      ELSE IF (PINDMX.LE.5.0) THEN
          MAXDEV = 5
          NTIK = 5
      ELSE IF (PINDMX.LE.10.0) THEN
          MAXDEV = 10
          NTIK = 2
      ELSE IF (PINDMX.LE.15.0) THEN
          MAXDEV = 15
          NTIK = 3
      ELSE IF (PINDMX.LE.20.0) THEN
          MAXDEV = 20
          NTIK = 4
      ELSE IF (PINDMX.LE.50.0) THEN
          MAXDEV = 50
          NTIK = 5
      ELSE
          MAXDEV = 100
          NTIK = 2
      ENDIF

C---- Draw the scale on the left-hand side
      Y1 = YP
      Y2 = YP + DEVHT
      CALL PSLINE(X,Y1,X,Y2)
      X1 = X - XGAP * 0.1
      X2 = X
      CALL PSLINE(X1,Y1,X2,Y1)
      CALL PSLINE(X1,Y2,X2,Y2)
      DO 5, ITIK = 1, NTIK - 1
          Y1 = YP + ITIK * (DEVHT / NTIK)
          CALL PSLINE(X1,Y1,X2,Y1)
 5    CONTINUE

C---- Print the numbers on the scale
      WRITE(CNUMB,10) 0.0
 10   FORMAT(F5.1)
      X1 = X - 3.0 * XGAP
      CALL PSTEXT(X1,YP,8.0,CNUMB)
      WRITE(CNUMB,10) MAXDEV
      CALL PSTEXT(X1,Y2,8.0,CNUMB)

C---- Lop through the residues to be processed
      DO 800, IPIN = 1, NPIN

C----     Process if not within a chain-break
          SECSTR = PINSST(IPIN)
          IF (SECSTR.NE.'=') THEN

C----         Plot the main-chain RMS deviation
              X1 = X + XGAP / 10.0
              X2 = X + XGAP / 2.0
              Y = YP + DEVHT * (PINDEV(1,IPIN) / MAXDEV)
              CALL PSHADE(0.0,0,RGB,MXCOLR,.FALSE.)
              CALL PSBBOX(X1,YP,X2,YP,X2,Y,X1,Y)

C----         Plot the side-chain RMS deviation
              X1 = X2
              X2 = X + XGAP * (9.0 / 10.0)
              Y = YP + DEVHT * (PINDEV(2,IPIN) / MAXDEV)
              CALL PSHADE(0.5,0,RGB,MXCOLR,.FALSE.)
              CALL PSBBOX(X1,YP,X2,YP,X2,Y,X1,Y)
          ENDIF

C----     Increment x-value for next residue
          X = X + XGAP
 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINGFS  -  Print the overall G-factors on the chequer-board
C                        for the protein as a whole
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINGFS(XSTART,XGAP,YSTART,YHT,GFACTR,NGFACT,INCOLR,
CHECK v.3.4-->
C     -    MXCOLR,RGB,MINCOL,MAXCOL)
     -    MXCOLR,RGB,MINCOL,MAXCOL,MINSHD,VALLOW,VALUPP)
CHECK v.3.4<--

      SAVE

      CHARACTER*7   CNUMB
      INTEGER       MXCOLR
      REAL          MINSHD, VALLOW, VALUPP
CHECK v.3.4-->
C      PARAMETER    (
C     -              MINSHD =  0.995,
C     -              VALLOW =  0.00,
C     -              VALUPP = -2.50
C     -             )
CHECK v.3.4<--

      INTEGER       IGFACT, MAXCOL, MINCOL, NGFACT
      LOGICAL       INCOLR
      REAL          GFACTR(NGFACT), RGB(3,MXCOLR), SHADE, VALUE, X1,
     -              X2, XDIFF, XGAP, XSTART, Y1, Y2, YHT, YSTART
 
C---- Initialise values
      X1 = XSTART + XGAP
      X2 = X1 + XGAP
      XDIFF = (XGAP - YHT) / 2.0
      X1 = X1 + XDIFF
      X2 = X2 - XDIFF
      Y1 = YSTART

C---- Print column heading
      CALL PSCTXT((X1 + X2) / 2.0,Y1 + YHT * 0.75,6.0,'Ave')

C---- Loop through the different distribution types
      DO 300, IGFACT = 1, NGFACT

C----     Calculate y-extent of current box and its shade
          Y2 = Y1 - YHT
          VALUE = GFACTR(IGFACT)
          IF (VALUE.GT.999.0) THEN
              SHADE = 1.0
          ELSE
              IF (VALUE.GT.VALLOW) THEN
                  SHADE = MINSHD
              ELSE IF (VALUE.LE.VALUPP) THEN
                  SHADE = 0.0
              ELSE
                  SHADE = MINSHD
     -                - MINSHD * (VALUE - VALLOW)
     -                / (VALUPP - VALLOW)
              ENDIF
          ENDIF

C----     Plot the box
          IF (VALUE.GT.999.0) THEN
              CALL PSHADE(SHADE,1,RGB,MXCOLR,.FALSE.)
          ELSE
              CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,MINCOL,
     -            MAXCOL)
          ENDIF
          CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)

C----     Print the G-factor value to the right of the box
          IF (VALUE.LT.999.0) THEN
              WRITE(CNUMB,200) VALUE
 200          FORMAT(F7.2)
              CALL PSTEXT(X2,(Y1 + Y2) / 2.0,6.0,CNUMB)
          ENDIF

C----     Increment y-value for next block
          Y1 = Y2
          IF (IGFACT.EQ.NGFACT - 1) Y1 = Y1 - YHT * 1.5
 300  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINPTS  -  Print pins plot data points
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINPTS(NPIN,NFILE,PINDAT,XP,YP,XPWID,YPWID,SCALEX,
     -    SCALEY,STDNUM,MXFILE,MXPINS,PHIGHT,RADIUS,DOMEAN,NOZERO,
CHECK v.3.4-->
C     -    DOCIRC)
     -    DOCIRC,MWANT,NMODEL,TOPMOD)
CHECK v.3.4<--

      CHARACTER*3   NUMBER
      INTEGER       IFILE, IPIN, IPOS, MODMAX, MXFILE, MXPINS, NCOUNT,
CHECK v.3.4-->
C     -              NFILE, NPIN
     -              NFILE, NMODEL, NPIN, TOPMOD
CHECK v.3.4<--
CHECK v.3.4-->
C      LOGICAL       DOCIRC, DOMEAN, NOZERO
      LOGICAL       DOCIRC, DOMEAN, MWANT(MXFILE), NOZERO
CHECK v.3.4<--
      REAL          MEAN, PHIGHT, PINDAT(MXFILE,MXPINS), RADIUS,
     -              SCALEX, SCALEY, STDEV, STDNUM, TSIZE, VALMAX,
     -              VALUE, X, XP, XPWID, X1, X2, YCALC, YMAX,
     -              YP, YPWID, Y, Y1, Y2
 
C---- Initialise variables
      X = XP + SCALEX / 2.0
      CALL PSLWID(0.1)

C---- Print dashed line at cut-off level
      YCALC = SCALEY * STDNUM
      IF (YCALC.GT.0.0 .AND. YCALC.LT.YPWID) THEN
          Y = YP + YCALC
          CALL PSDASH(2)
          CALL PSLINE(XP,Y,XP + XPWID,Y)
          CALL PSDASH(0)
      ENDIF

C---- Loop through the residues across the page
      DO 500, IPIN = 1, NPIN

C----     Initialise variables for calculating residue means and st. dev.
          MEAN = 0.0
          STDEV = 0.0
          NCOUNT = 0
          VALMAX = 0.0
          MODMAX = 0

C----     Loop through the different values for this residue
          DO 100, IFILE = 1, NFILE

CHECK v.3.4-->
C----         Process only if this is one of the selected models
              IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----             Process this point if it is a valid value
                  VALUE = PINDAT(IFILE,IPIN)
                  IF (VALUE.LT.900.0 .AND.
     -                (VALUE.GT.0.0 .OR. .NOT.NOZERO)) THEN
                      YCALC = SCALEY * VALUE
                      IF (YCALC.GT.YPWID) YCALC = YPWID
                      Y = YP + YCALC
                      IF (VALUE.GT.VALMAX) THEN
                          VALMAX = VALUE
                          MODMAX = IFILE
                          YMAX = Y
                      ENDIF

C----                 Plot the point
                      X1 = X - PHIGHT / 2.0
                      X2 = X + PHIGHT / 2.0
                      Y1 = Y - PHIGHT / 2.0
                      Y2 = Y + PHIGHT / 2.0

C----                 Set colour of point-marker according to whether it
C                     is in the range for highlighting or not
                      IF (VALUE.GT.STDNUM) THEN
                      ELSE
                      ENDIF

C----                 Plot appropriate point-marker
                      IF (DOCIRC) THEN
                          CALL PSOCIR(X,Y,RADIUS)
                      ELSE
                          CALL PSLINE(X1,Y1,X2,Y2)
                          CALL PSLINE(X1,Y2,X2,Y1)
                      ENDIF

C----                 Increment accumulators for calc of mean value
                      MEAN = MEAN + VALUE
                      NCOUNT = NCOUNT + 1
                  ENDIF
CHECK v.3.4-->
              ENDIF
CHECK v.3.4<--
 100      CONTINUE

C----     Calculate and plot the mean value
          IF (DOMEAN .AND. NCOUNT.NE.0) THEN
              MEAN = MEAN / REAL(NCOUNT)
              YCALC = SCALEY * MEAN
              IF (YCALC.GT.0.0 .AND. YCALC.LT.YPWID) THEN
                  Y = YP + YCALC
CHECK v.3.4-->
C                  IF (NFILE.GT.1) CALL PSOCIR(X,Y,RADIUS)
                  IF (NMODEL.GT.1) CALL PSOCIR(X,Y,RADIUS)
CHECK v.3.4<--
              ENDIF
          ENDIF

C----     Loop through the ensemble points a second time to calculate
C         the standard deviation
          IF (DOMEAN) THEN
              DO 300, IFILE = 1, NFILE

CHECK v.3.4-->
C----             Process only if this is one of the selected models
                  IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----                 Process this point if it is a valid value
                      VALUE = PINDAT(IFILE,IPIN)
                      IF (VALUE.LT.900.0) THEN

C----                     Increment accumulators for calc of st. dev.
                          STDEV = STDEV
     -                        + (MEAN - VALUE) * (MEAN - VALUE)
                      ENDIF
CHECK v.3.4-->
                  ENDIF
CHECK v.3.4<--
 300          CONTINUE
          ENDIF

C----     Calculate the standard deviation and plot error bars to indicate
C         its extent
          IF (DOMEAN .AND. NCOUNT.GT.2) THEN
              STDEV = SQRT(STDEV / REAL(NCOUNT))

C----         Plot marker one st. dev above mean
              YCALC = SCALEY * (MEAN + STDEV)
              IF (YCALC.GT.0.0 .AND. YCALC.LT.YPWID) THEN
                  Y = YP + YCALC
                  X1 = X - PHIGHT
                  X2 = X + PHIGHT
                  CALL PSLINE(X1,Y,X2,Y)
              ENDIF
              Y1 = Y
              IF (YCALC.GT.YPWID) Y1 = YP + YPWID

C----         Plot marker one st. dev below mean
              YCALC = SCALEY * (MEAN - STDEV)
              IF (YCALC.GT.0.0 .AND. YCALC.LT.YPWID) THEN
                  Y = YP + YCALC
                  X1 = X - PHIGHT
                  X2 = X + PHIGHT
                  CALL PSLINE(X1,Y,X2,Y)
              ENDIF
              Y2 = Y
              IF (YCALC.LT.0.0) Y2 = YP

C----         Plot the line joining the two
              CALL PSLINE(X,Y1,X,Y2)
          ENDIF

C----     Print the model number with the highest value
CHECK v.3.4-->
C          IF (MODMAX.NE.0 .AND. NFILE.GT.1) THEN
          IF (MODMAX.NE.0 .AND. NMODEL.GT.1) THEN
CHECK v.3.4<--
              WRITE(NUMBER,60) MODMAX
 60           FORMAT(I3)
              IPOS = 1
              IF (MODMAX.LT.100) IPOS = 2
              IF (MODMAX.LT.10) IPOS = 3
              TSIZE = 8.0
CHECK v.3.4-->
C              IF (NFILE.GT.9) TSIZE = 6.0
              IF (TOPMOD.GT.9) TSIZE = 6.0
CHECK v.3.4<--
              CALL PSCTXT(X,YMAX + 8.0,TSIZE,NUMBER(IPOS:))
          ENDIF

C----     Increment x-value for next point to be plotted
          X = X + SCALEX
 500  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4-->
C Routines MODELG, MODPLT, MODPTS, MODCHQ, MODGFS, PINBOX transferred
C to vplot.f
CHECK v.3.4<--
C**************************************************************************
C
C  SUBROUTINE MODLSS  -  Plot the model-by-model secondary structure
C                        wiring diagrams
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE MODLSS(PLTYPE,NFILE)

      INCLUDE 'mplot.inc'

      INTEGER       NPPAGE
      PARAMETER    (NPPAGE = 7)

      CHARACTER*1   BRKCH, CHNEND, CIS(MXFILE), DAMINO(MXFILE), INCHN,
     -              LSTBRK, LSTCHN, NXTCHN, NXTCIS(MXFILE),
     -              NXTSST(MXFILE), OLDCHN, PINCIS(MXPINS,MXFILE),
     -              PINSST(MXPINS,MXFILE)
      CHARACTER*2   PINCHN(MXPINS,MXFILE)
      CHARACTER*3   PINRES(MXPINS,MXFILE), RESDUE
      CHARACTER*5   PINSNO(MXPINS)
      CHARACTER*6   SNOKEY
      INTEGER       BGAP, FEND, FGAP, FPIN, FSTART, IFILE, IGAP, IPOS,
     -              IRES, JPOS, JPOSFM, JPOSTO, JRES, LINE, LINEA,
CHECK v.3.4.3-->
C     -              NFILE, NGAP, NPAGES, NPIN, ONPAGE, PLTYPE, THEPIN
     -              NFILE, NGAP, NGOT, NPAGES, NPIN, ONPAGE, PLTYPE,
     -              THEPIN
CHECK v.3.4.3<--
      LOGICAL       BREAK(MXPINS), BRKPOS(MXPINS,MXFILE), FIRST, LASTPG,
     -              LOOPON, PAGEND, PINDBL(MXPINS), PINOPE
      REAL          CALVAL, OMEGA, PINACC(MXPINS,MXFILE)

      DATA BGAP, FGAP / 2, 10 /

C---- Initialise variables
      DO 50, NPIN = 1, MXPINS
          BREAK(NPIN) = .FALSE.
          DO 40, IFILE = 1, MXFILE
              BRKPOS(NPIN,IFILE) = .FALSE.
              NXTSST(IFILE) = '='
              PINACC(NPIN,IFILE) = 0.0
              PINCIS(NPIN,IFILE) = ' '
              PINCHN(NPIN,IFILE) = ' '
              PINRES(NPIN,IFILE) = ' '
              PINSST(NPIN,IFILE) = '='
 40       CONTINUE
          PINDBL(NPIN) = .FALSE.
          PINSNO(NPIN) = ' '
 50   CONTINUE
      BRKCH = ' '
      CHNEND = '>'
      PINOPE = .FALSE.
CHECK v.3.4.3-->
      FEND = 0
CHECK v.3.4.3<--
      FIRST = .TRUE.
      INCHN = ' '
      LINE = 0
      LINEA = 0
      LSTBRK = ' '
      LSTCHN = ' '
      OLDCHN = ' '
      THEPIN = MXPINS
      IF (NRES.LT.MXPINS .AND. NRES.GT.2) THEPIN = NRES
      THEPIN = MXPINS

C---- Loop through all the models in the ensemble
      DO 200, IFILE = 1, NFILE

C----     Initialise the cis-peptide markers
          NXTCIS(IFILE) = ' '
 200  CONTINUE

C---- Calculate how many pages will be required given the number of
C     models that can go on each page
CHECK v.3.4-->
C      NPAGES = NFILE / NPPAGE + 1
C      IF ((NPAGES - 1) * NPPAGE.EQ.NFILE) NPAGES = NPAGES - 1
      NPAGES = NMODEL / NPPAGE + 1
      IF ((NPAGES - 1) * NPPAGE.EQ.NMODEL) NPAGES = NPAGES - 1
CHECK v.3.4<--

C---- Loop through all the pages to be done
      DO 1000, ONPAGE = 1, NPAGES

C----     Initialise to the start of the sequence
          FPIN = 0
          NPIN = 0
          LASTPG = .FALSE.

C----     Calculate start- and end-file numbers
CHECK v.3.4.3-->
C          FSTART = NPPAGE * (ONPAGE - 1) + 1
C          FEND = FSTART + NPPAGE - 1
CCHECK v.3.4-->
CC          IF (FEND.GT.NFILE) FEND = NFILE
C          IF (FEND.GT.NMODEL) FEND = NMODEL
CCHECK v.3.4<--
          NGOT = 0
          FSTART = 0
          DO 250, IFILE = FEND + 1, NFILE
              IF (MWANT(IFILE) .AND. NGOT.LT.NPPAGE) THEN
                  IF (FSTART.EQ.0) FSTART = IFILE
                  FEND = IFILE
                  NGOT = NGOT + 1
              ENDIF
 250      CONTINUE
CHECK v.3.4.3<--

C----     Loop through all the residues in the sequence to produce all
C         the pins plots
          IPOS = 0
 300      CONTINUE

C----         Increment starting residue position
              IPOS = IPOS + 1

C----         Get the pointer to the starting residue
              IF (IPOS.EQ.1) THEN
                  IRES = FSTRES
              ELSE
                  IRES = NXTRES(IRES)
              ENDIF

C----         Retrieve the residue number
              SNOKEY = VALSNO(IRES)(1:6)
              JPOSFM = IPOS
              JPOSTO = IPOS
              JPOS = IPOS
              JRES = IRES
              LOOPON = .TRUE.

C----         Determine how many residues share the same residue number
              IF (IPOS.LT.NRES) THEN
 400              CONTINUE
                      JPOS = JPOS + 1

C----                 Get the pointer to this residue
                      JRES = NXTRES(JRES)

C----                 If this has the same residue number as the
C                     starting-residue, check next one, too
                      IF (VALSNO(JRES)(1:6).EQ.SNOKEY) THEN
                          JPOSTO = JPOS
                      ELSE
                          LOOPON = .FALSE.
                      ENDIF
                  IF (LOOPON .AND. JPOS.LT.NRES) GO TO 400
              ENDIF

C----         Increment IPOS, if necessary
              IPOS = IPOS + JPOSTO - JPOSFM

C----         Prepare data for current residue-position
              NPIN = NPIN + 1
              PINDBL(NPIN) = DOUBL(IRES)
              OLDCHN = INCHN
              INCHN = VALSNO(IRES)(1:1)
              CHNEND = ' '
              IF (IPOS.EQ.1) THEN
                  CHNEND = '>'
                  OLDCHN = INCHN
              ENDIF
              IF (IPOS.EQ.NRES) CHNEND = '<'
              NXTCHN = INCHN
CHECK v.3.4-->
              BRKCH = CHNBRK(IRES)
CHECK v.3.4<--

C----         Determine whether at a chain-end or chain-start
              IF (NPIN.GT.0) THEN
                  IF (OLDCHN.NE.NXTCHN) THEN
                      CHNEND = '<'
                  ELSE IF (OLDCHN.NE.LSTCHN) THEN
                      CHNEND = '>'
                  ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.'!') THEN
                      CHNEND = '<'
                  ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.' ') THEN
                      CHNEND = '>'
CHECK v.3.4-->
                  ELSE IF (BRKCH.EQ.'x') THEN
C                      CHNEND = '<'
C                      PINCHN(NPIN)(2:2) = CHNEND
                      CHNEND = '!'
CHECK v.3.4<--
                  ENDIF
                  LSTBRK = BRKCH
                  LSTCHN = OLDCHN
              ENDIF

C----         Loop over the residue(s) corresponding to this residue
C             position
              DO 700, JPOS = JPOSFM, JPOSTO

C----             Get the pointer to this residue
                  IF (JPOS.GT.JPOSFM) THEN
                      IRES = NXTRES(IRES)
                  ENDIF
                  RESDUE = VALSNO(IRES)(7:9)

C----             Loop over the current page's models
                  DO 600, IFILE = FSTART, FEND

CHECK v.3.4.3-->
                      IF (MWANT(IFILE)) THEN
CHECK v.3.4.3<--

C----                     Process only if this residue is actually present
C                         in this model
                          IF (RESMOD(IRES,IFILE)) THEN

C----                         Check whether we have a cis-peptide or
C                             D-amino acid in this model

C----                         Initialise cis-peptide and D-amino acid
C                             markers
                              CIS(IFILE) = NXTCIS(IFILE)
                              NXTCIS(IFILE) = ' '
                              DAMINO(IFILE) = ' '

C----                         Check for cis peptide (ie abs(omega) < 45) 
                              OMEGA = VALUE(LOCOME,IRES,IFILE)
                              IF (ABS(OMEGA).LT.900.0 .AND.
     -                            (OMEGA.LT.45.0 .OR. OMEGA.GT.315.0))
     -                             THEN
                                  NXTCIS(IFILE) = 'c'
                              ENDIF

C----                         Alpha carbon chirality
                              CALVAL = VALUE(LOCZET,IRES,IFILE)
                              IF (CALVAL.LT.900.0) THEN
                                  IF (CALVAL.LT.0) DAMINO(IFILE) = 'D'
                              ENDIF

C----                         Transfer into plot array
                              IF (CIS(IFILE).EQ.'c' .AND.
     -                            DAMINO(IFILE).EQ.'D') THEN
                                  PINCIS(IFILE,NPIN) = 'X'
                              ELSE IF (CIS(IFILE).EQ.'c') THEN
                                  PINCIS(IFILE,NPIN) = CIS(IFILE)
                              ELSE IF (DAMINO(IFILE).EQ.'D') THEN
                                  PINCIS(IFILE,NPIN) = DAMINO(IFILE)
                              ENDIF

C----                         Transfer the plot details for this residue
C                             into the plot arrays
                              PINACC(NPIN,IFILE) = SAVOOI(IRES,IFILE)
                              PINRES(NPIN,IFILE) = RESDUE
                              PINSNO(NPIN) = VALSNO(IRES)(2:6)
                              PINCHN(NPIN,IFILE) = VALSNO(IRES)(1:1)
                              PINCHN(NPIN,IFILE)(2:2) = CHNEND
                              PINSST(NPIN,IFILE) = STOSST(IRES,IFILE)
                              NXTSST(IFILE) = '='
                          ENDIF
CHECK v.3.4.3-->
                      ENDIF
CHECK v.3.4.3<--
 600              CONTINUE
 700          CONTINUE

C----         If have a pageful of data, then produce the pinplot
              IF (NPIN.EQ.THEPIN) THEN
                  IF (PLOTSS) THEN

C----                 If current PostScript file is open, close it
                      IF (PINOPE) THEN
                          CALL PSENDP
                          IF (.NOT.COMBPS) THEN
                              CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                          ENDIF
                      ENDIF

C----                 Produce current page
                      IF (IPOS.GE.NRES) LASTPG = .TRUE.
                      CALL MSSPLT(THEPIN,NPIN,FPIN,PINRES,PINSST,
     -                    PINCHN,PINSNO,BRKPOS,PINACC,PINCIS,PLTYPE,
     -                    FSTART,FEND,FIRST,PINDBL,NXTSST)
                      FIRST = .FALSE.
                      PINOPE = .TRUE.
                  ENDIF
                  FPIN = FPIN + THEPIN
                  NPIN = 0
                  CHNEND = ' '
              ENDIF

C----         Check whether this residue is the end of a chain
              IF (CHNEND.EQ.'<' .OR. CHNEND.EQ.'!') THEN

C----             Leave the appropriate number of blanks between the chains
                  PAGEND = .FALSE.
                  IF (CHNEND.EQ.'<') THEN
                      NGAP = FGAP
                  ELSE
                      NGAP = BGAP
                  ENDIF
                  DO 800, IGAP = 1, NGAP

C----                 Add blanks providing that haven't reached end of
C                     page
                      IF (.NOT.PAGEND .AND. IPOS.NE.NRES) THEN
                          NPIN = NPIN + 1
                          BREAK(NPIN) = .TRUE.
                          DO 750, IFILE = FSTART, FEND
                              BRKPOS(NPIN,IFILE) = .TRUE.
 750                      CONTINUE

C----                     If have a pageful of data, then produce the
C                         pinplot
                          IF (NPIN.EQ.THEPIN) THEN
                              IF (PLOTSS) THEN

C----                             If current PostScript file is open,
C                                 close it
                                  IF (PINOPE) THEN
                                      CALL PSENDP
                                      IF (.NOT.COMBPS) THEN
                                          CALL PSCLOS(BBOXX1,BBOXX2,
     -                                        BBOXY1,BBOXY2)
                                      ENDIF
                                  ENDIF

C----                             Produce current page
                                  IF (IPOS.GE.NRES) LASTPG = .TRUE.
                                  CALL MSSPLT(THEPIN,NPIN,FPIN,PINRES,
     -                                PINSST,PINCHN,PINSNO,BRKPOS,
     -                                PINACC,PINCIS,PLTYPE,FSTART,FEND,
     -                                FIRST,PINDBL,NXTSST)
                                  FIRST = .FALSE.
                                  PINOPE = .TRUE.
                              ENDIF
                              FPIN = FPIN + THEPIN
                              NPIN = 0
                              CHNEND = ' '
                              PAGEND = .TRUE.
                          ENDIF
                      ENDIF
 800              CONTINUE
              ENDIF

C----     Loop back for next residue
          IF (IPOS.LT.NRES) GO TO 300

C----     If any more data left to be printed, then produce the pinplot
          IF (PLOTSS .AND. NPIN.GT.0) THEN

C----          If current PostScript file is open, close it
               IF (PINOPE) THEN
                   CALL PSENDP
                   IF (.NOT.COMBPS) THEN
                       CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                   ENDIF
               ENDIF

C----         Produce current page
              LASTPG = .TRUE.
              CALL MSSPLT(THEPIN,NPIN,FPIN,PINRES,
     -            PINSST,PINCHN,PINSNO,BRKPOS,PINACC,PINCIS,
     -            PLTYPE,FSTART,FEND,FIRST,PINDBL,NXTSST)
              FIRST = .FALSE.
              PINOPE = .TRUE.
          ENDIF
 1000 CONTINUE

C---- Close the current PostScript file
      IF (PINOPE) THEN
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE MSSPLT  -  Print current page for model-by-model
C                        secondary structure diagrams
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE MSSPLT(THEPIN,NPIN,FPIN,PINRES,PINSST,PINCHN,PINSNO,
     -    BRKPOS,PINACC,PINCIS,PLTYPE,FSTART,FEND,FIRST,PINDBL,NXTSST)

      SAVE

      INCLUDE 'mplot.inc'

      REAL          YTOP
      PARAMETER    (
     -              YTOP   = 680.0
     -             )

      REAL          SIZLAB, TSIZE
      PARAMETER    (
     -              SIZLAB =  10.0,
     -              TSIZE  =  15.0
     -             )

      INTEGER       THEPIN

      CHARACTER*1   A, NXTSST(MXFILE), PINCIS(MXPINS,MXFILE),
     -              PINSST(MXPINS,MXFILE), RCHAR
      CHARACTER*2   PAGENO, PINCHN(MXPINS,MXFILE)
      CHARACTER*3   CODE(20), PINRES(MXPINS,MXFILE)
      CHARACTER*5   PINSNO(THEPIN), TICLAB(MXPINS)
      CHARACTER*7   PAGE
      CHARACTER*18  CLABEL
      CHARACTER*20  AMINO1
      CHARACTER*26  LOWER
      CHARACTER*30  PLDESC
      CHARACTER*60  PTITLE
      CHARACTER*80  TEXT
      INTEGER       FPIN, FSTART, FEND, ICODE, IFILE, IPIN, N,
     -              NPAGE, NPIN, PLTYPE, TICLEN(MXPINS)
      LOGICAL       BRKPOS(MXPINS,MXFILE), DUPLIC, FIRST,
     -              PINDBL(MXPINS), TICPOS(MXPINS)
      REAL          PINACC(MXPINS,MXFILE), SCALEX, X, XCENTR, Y, YP,
     -              YWIDTH

      DATA  A      / 'A' /
      DATA  AMINO1 / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /
      DATA  NPAGE  / 0 /
      DATA  PLDESC / 'Model secondary structures' /

      DATA  PTITLE / 'Model secondary structures' /


C---- Initialise variables
      DUPLIC = .FALSE.
      XCENTR = XPORIG + XPWID / 2.0
      YP = YTOP
      YWIDTH = 55.0
      SCALEX = XPWID / THEPIN

C---- Open new PostScript file
      IF (.NOT.COMBPS .OR. FIRST) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,'modelsecs',WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(PLTYPE),PTITLE,
C     -        NPAGE + 1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,
     -        NPAGE + 1)
CHECK v.3.4<--
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,
CHECK v.3.4-->
C     -    RGB,INCOLR(PLTYPE),COLPLT(1,PLTYPE),NPAGE + 1,PLABEL)
     -    RGB,INCOLR(PLTYPE),COLPLT(1,PLTYPE),NPAGE + 1,PLABEL,RSELEC)
CHECK v.3.4<--
      PLDESC = ' '
      CALL PSLWID(0.1)

C---- Main graph heading
      CALL PSCTXT(XCENTR,YP + 65.0,30.0,'Model secondary structures')
      CALL PSCTXT(XCENTR,YP + 36.0,25.0,TITLE(1:TLEN))

C---- Loop through all the models on this page
      DO 1000, IFILE = FSTART, FEND

CHECK v.3.4.3-->
C----     Print only if current model is wanted
          IF (MWANT(IFILE)) THEN
CHECK v.3.4.3<--

C----         Print the model number
              Y = YP
              WRITE(CLABEL,110) IFILE, FILID(IFILE)(1:LENID(IFILE))
 110          FORMAT('Model',I3,'. ',A8)
              IF (ENSEMB) THEN
                  CALL PSTEXT(XPORIG,Y + 8.0,12.0,CLABEL)
              ELSE
                  CALL PSTEXT(XPORIG,Y + 8.0,12.0,CLABEL(1:9))
              ENDIF

C----         Print the "wiring diagram" showing the secondary structure,
C             with background shading giving a measure of the accessibility
              Y = Y - 18.0
              CALL PSLWID(0.0)
              IF (SHOWSA) THEN
CHECK v.3.5.3-->
C                  CALL ACCSHD(THEPIN,NPIN,PINACC(1,IFILE),
                  CALL ACCSHD(MXPINS,THEPIN,NPIN,PINACC(1,IFILE),
CHECK v.3.5.3<--
     -                PINSST(1,IFILE),
CHECK v.3.4-->
C     -            XPORIG,Y,SCALEX,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,
C     -            COLPLT(2,PLTYPE),COLPLT(3,PLTYPE))
     -                XPORIG,Y,SCALEX,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,
     -                COLPLT(3,PLTYPE),COLPLT(2,PLTYPE))
CHECK v.3.4<--
              ENDIF
CHECK v.3.5.3-->
C              CALL SSPLOT(THEPIN,NPIN,PINSST(1,IFILE),XPORIG,Y,SCALEX,
C     -            NRES,PINCHN,SHOWSA,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,
C     -            COLPLT(4,PLTYPE),COLPLT(2,PLTYPE),COLPLT(3,PLTYPE),
C     -            .FALSE.,NXTSST(IFILE))
              CALL SSPLOT(MXPINS,THEPIN,NPIN,PINSST(1,IFILE),XPORIG,Y,
     -            SCALEX,NRES,PINCHN,SHOWSA,SSSIZE,INCOLR(PLTYPE),
     -            MXCOLR,RGB,COLPLT(4,PLTYPE),COLPLT(2,PLTYPE),
     -            COLPLT(3,PLTYPE),.FALSE.,NXTSST(IFILE))
CHECK v.3.5.3<--

C----         Print the residue numbers
              CALL PINRNO(XPORIG,XPORIG + XPWID,Y - 9.2,PINSNO,
     -            MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)

C----         Print the sequence
              Y = Y - 34.0
              DO 600, IPIN = 1, NPIN
                  X = XPORIG + (IPIN - 0.5) * SCALEX

C----             Find single-letter code for this residue
                  ICODE = 0
                  DO 300, N = 1, 20
                      IF (PINRES(IPIN,IFILE).EQ.CODE(N)) THEN
                          ICODE = N
                          GO TO 350
                      ENDIF
 300              CONTINUE

C----             If not one of the standard 20, then print full 3-letter
C                 code
 350              CONTINUE
                  IF (ICODE.EQ.0) THEN
                      CALL PSCTXT(X,Y,8.0,PINRES(IPIN,IFILE)(1:1))
                      RCHAR = PINRES(IPIN,IFILE)(2:2)
                      N = ICHAR(RCHAR) - ICHAR(A) + 1
                      IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
                      CALL PSCTXT(X,Y - 6.0,8.0,RCHAR)
                      RCHAR = PINRES(IPIN,IFILE)(3:3)
                      N = ICHAR(RCHAR) - ICHAR(A) + 1
                      IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
                      CALL PSCTXT(X,Y - 12.0,8.0,RCHAR)

C----             Otherwise, print the single-letter code
                  ELSE
                      RCHAR = AMINO1(ICODE:ICODE)
                      CALL PSCTXT(X,Y,8.0,RCHAR)
                  ENDIF

C----             Mark this residue if different residue types exist
C                 in the different models
                  IF (PINDBL(IPIN)) THEN
                      CALL PSCSHD(0.0)
                      CALL PSCIRC(X,Y + 10.0,1.8)
                      DUPLIC = .TRUE.
                  ENDIF
 600          CONTINUE

C----         Add ticks at appropriate positions below line
              CALL PINTIC(XPORIG,Y + 6.0,0.0,XPWID,MXPINS,NPIN,-2.0,
     -            TICPOS,BRKPOS(1,IFILE),.FALSE.)

C----         Increment y-value
              YP = YP - (YWIDTH + 35.0)
CHECK v.3.4.3-->
          ENDIF
CHECK v.3.4.3<--
 1000 CONTINUE

C---- If there have been any "duplicate" residues, print explanatory text
      IF (DUPLIC) THEN
          Y = Y - 32.0
          CALL PSCSHD(0.0)
          CALL PSCIRC(XPORIG,Y,1.8)
          TEXT = 'signifies different residue-types at this position' //
     -        ' in the different structures'
          CALL PSTEXT(XPORIG + 8.0,Y,8.0,TEXT(1:80))
      ENDIF

C---- Print the page number on the plot
      NPAGE = NPAGE + 1
      WRITE(PAGENO,'(I2)') NPAGE
      PAGE = 'Page ' // PAGENO      
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

C---- Print program name in top left-hand corner
      IF (NMR) THEN
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-NMR')
      ELSE
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-COMP')
      ENDIF

C---- Re-initalise arrays
      DO 850, NPIN = 1, MXPINS
          DO 840, IFILE = 1, MXFILE
              BRKPOS(NPIN,IFILE) = .FALSE.
              NXTSST(IFILE) = '='
              PINACC(NPIN,IFILE) = 0.0
              PINCIS(NPIN,IFILE) = ' '
              PINCHN(NPIN,IFILE) = ' '
              PINRES(NPIN,IFILE) = ' '
              PINSST(NPIN,IFILE) = '='
 840      CONTINUE
          PINDBL(NPIN) = .FALSE.
          PINSNO(NPIN) = ' '
 850  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C  SUBROUTINE RANGES  -  Calculate the x-axis range
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE RANGES(NFILE)
      SUBROUTINE RANGES
CHECK v.3.4.3<--

      INCLUDE 'mplot.inc'

CHECK v.3.4.3-->
C      INTEGER       IADD, NFILE
      INTEGER       IADD
CHECK v.3.4.3<--
      REAL          CALC, DIFF, TOPX

C---- If only one file, then do the plot as in pplot.f
CHECK v.3.4-->
C      IF (NFILE.EQ.1 .OR. NMR) THEN
      IF (NMODEL.EQ.1 .OR. NMR) THEN
CHECK v.3.4<--
          INTRLX = 1
          MINX = RSTART
          MAXX = REND
          GAPX = 0.5
          NTICKX = 7
          XVALUE(1) = RESOL(1)

C---- Otherwise, determine the upper and lower bounds for the x-axis and
C     the number of ticks required
      ELSE

C----     If no user-supplied numbers found in mplot.in then are using
C         line-counts
          IF (NFOUND.EQ.0) THEN
              INTRLX = 0
              MINX = 0.0
CHECK v.3.4-->
C              MAXX = NFILE + 1.0
              MAXX = TOPMOD + 1.0
CHECK v.3.4<--

C----         If only a small number of files, have tick for each
CHECK v.3.4-->
C              IF (NFILE.LT.9) THEN
              IF (TOPMOD.LT.9) THEN
CHECK v.3.4<--
                  GAPX = 1.0
CHECK v.3.4-->
C                  NTICKX = NFILE + 2
                  NTICKX = TOPMOD + 2
CHECK v.3.4<--

C----         Otherwise, have 6, 5 or 4 ticks
              ELSE
                  NTICKX = 6
                  GAPX = INT(MAXX / (NTICKX - 1)) + 1
                  IF (MOD(INT(MAXX),NTICKX - 1).EQ.0) GAPX = GAPX - 1

C----             Determine whether 5 or 4 ticks might be better
                  TOPX = GAPX * 5
                  DIFF = TOPX - MAXX
                  TOPX = GAPX * 4
                  IF (TOPX - MAXX.GE.0 .AND. TOPX - MAXX.LT.DIFF) THEN
                      DIFF = TOPX - MAXX
                      NTICKX = 5
                  ENDIF
                  TOPX = GAPX * 3
                  IF (TOPX - MAXX.GE.0 .AND. TOPX - MAXX.LT.DIFF) THEN
                      DIFF = TOPX - MAXX
                      NTICKX = 4
                  ENDIF
                  MAXX = GAPX * (NTICKX - 1)
              ENDIF

C----     Otherwise, use the maximum and minimum values supplied
          ELSE

C----         If both maximum and minimum values are between -1.0 and 1.0,
C             set default bounds
              IF (ABS(MINX).LE.1.0 .AND. ABS(MAXX).LE.1.0) THEN
                  INTRLX = 1
                  IF (MINX.LT.0.0) MINX = -1.0
                  IF (MINX.GE.0.0) MINX =  0.0
                  IF (MAXX.LT.0.0) MAXX =  0.0
                  IF (MAXX.GE.0.0) MAXX =  1.0
                  NTICKX = 6

C----         Otherwise, determine a suitable gap-size
              ELSE
                  GAPX = INT(0.5 + (MAXX - MINX) / 5.0)
                  IF (GAPX.EQ.0.0) THEN
                      GAPX = 1.0
                  ELSE
                      GAPX = 1.0 / GAPX
                  ENDIF

C----             Calculate the next maximum and minimum x-values based on
C                 no. of ticks
                  IF (MINX.LT.0.0) THEN
                      IADD = 1
                  ELSE
                      IADD = 0
                  ENDIF
                  CALC = MINX
                  MINX = (INT(MINX * GAPX) - IADD) / GAPX
                  IF (CALC - MINX.EQ.1.0 / GAPX) THEN
                      MINX = MINX + 1.0 / GAPX
                  ENDIF
                  CALC = MAXX
                  IF (MAXX.GT.0.0) THEN
                      IADD = 1
                  ELSE
                      IADD = 0
                  ENDIF
                  MAXX = (INT(MAXX * GAPX) + IADD) / GAPX
                  IF (MAXX - CALC.EQ.1.0 / GAPX) THEN
                      MAXX = MAXX - 1.0 / GAPX
                  ENDIF
                  NTICKX = (MAXX - MINX) * GAPX + 1

C----             Determine whether gap between ticks is an integral amount
                  GAPX = 1.0 / GAPX
                  DIFF = GAPX - INT(GAPX)
                  IF (ABS(DIFF).GT.1.0E-06) INTRLX = 1
              ENDIF
          ENDIF
      ENDIF

      RETURN
      END

C----------------------------------------------------------------------+--- 
C**************************************************************************
C
C  SUBROUTINE QUALIT  -  Perform all the quality-assessment plots
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE QUALIT(NFILE,PLTYPE)

      INCLUDE 'mplot.inc'

      CHARACTER*3   NUMBER
      CHARACTER*9   PLHAND
      CHARACTER*10  NAME
CHECK v.3.3-->
      CHARACTER*19  CTITLE
CHECK v.3.3<--
      CHARACTER*21  GTITLE
      CHARACTER*30  DE(NQUALP), PLDESC
      CHARACTER*50  GSTIT(NQUALP), IREC, YAXIS(NQUALP)
      CHARACTER*60  PTITLE
      INTEGER       ICOLR, IFILE, IGRAPH, INTRLY(NQUALP), IPOS, IQUALP,
     -              JGRAPH, NFILE, NGRAPH, NGAPY(NQUALP), NPOINT,
CHECK v.3.4-->
C     -              PLTYPE, TITLEN(NQUALP), TLENTH
     -              PLTYPE, TITLEN(NQUALP), TLENTH, YLEN(NQUALP)
CHECK v.3.4<--
      LOGICAL       DOGRAF
CHECK v.3.3-->
C      REAL          CO(3,NQUALP), CWIDTH, MAXSVL, MEAN, RESNEA(NQUALP),
C     -              SCALEX, SHADE, TSIZE, X, XCENTR, XL, XR, X1, X2, Y,
C     -              YABOVE, YB(NQUALP), YHT, YL, YLEN(NQUALP),
C     -              YLOWER(NQUALP), YR, YUPPER(NQUALP), Y1, Y2
      REAL          CO(3,NQUALP), CWIDTH, KEYPSX, KEYPSY, MAXSVL, MEAN,
     -              MKSZ, RESNEA(NQUALP), SCALEX, SHADE, TSIZE, X,
     -              XCENTR, XL, XR, X1, X2, Y, YABOVE, YB(NQUALP), YHT,
CHECK v.3.4-->
C     -              YL, YLEN(NQUALP), YLOWER(NQUALP), YR, YTOP,
C     -              YUPPER(NQUALP), Y1, Y2
     -              YL, YLOWER(NQUALP), YR, YTOP,
     -              YUPPER(NQUALP), Y1, Y2
CHECK v.3.4<--

      PARAMETER    (MKSZ = 3.0)
CHECK v.3.3<--

      DATA  CO     / 84.2, 11.2, -5.7,
     -               0.35,  0.23, 0.0,
     -               2.85,  7.66, 0.0,
CHECK v.3.3-->
C     -                9.6,  5.4,  0.0 /
     -                9.6,  5.4,  0.0,
     -               0.43, -0.41, 0.0 /
CHECK v.3.3<--
      DATA CWIDTH / 4.0 /
      DATA DE     / 'a. %-tage residues in A, B, L ',
     -              'b. H-bond energy st dev       ',
     -              'c. Chi-1 pooled st dev        ',
CHECK v.3.3-->
C     -              'd. Chi-2 trans st dev         ' /
     -              'd. Chi-2 trans st dev         ',
CHECK v.3.4.3-->
C     -              'e. Overall G-factor           ' /
     -              'e. Dihedral angles G-factor    ' /
CHECK v.3.4.3<--
CHECK v.3.3<--
      DATA GSTIT  / 'a. Ramachandran plot quality assessment         ',
     -              'b. Hydrogen bond energies                       ',
     -              'c. Chi-1 pooled standard deviations             ',
CHECK v.3.3-->
C     -              'd. Standard deviation of Chi-2 trans angle      '/
     -              'd. Standard deviation of Chi-2 trans angle      ',
CHECK v.3.4.3-->
C     -              'e. Overall G-factor                             '/
     -              'e. Dihedral angles G-factor                     ' /
CHECK v.3.4.3<--
      DATA CTITLE / 'Property comparison' /
CHECK v.3.3<--
      DATA GTITLE / 'Equivalent resolution' /
CHECK v.3.3-->
C      DATA NGAPY  /     5,    8,    5,    5 /
C      DATA INTRLY /     0,    1,    0,    0 /
C      DATA TITLEN /    39,   25,   34,   42 /
      DATA NGAPY  /     5,    8,    5,    5,   7 /
      DATA INTRLY /     0,    1,    0,    0,   1 /
CHECK v.3.4.3-->
C      DATA TITLEN /    39,   25,   34,   42,  19 /
      DATA TITLEN /    39,   25,   34,   42,  27 /
CHECK v.3.4.3<--
CHECK v.3.3<--
      DATA YAXIS  / '%-tage of residues in most favoured regions     ',
     -              'Standard deviation (kcal/mol)                   ',
     -              'Standard deviation (degrees)                    ',
CHECK v.3.3-->
C     -              'Standard deviation (degrees)                    '/
C      DATA YB     /  10.0,  0.2,  4.85, 5.0 /
     -              'Standard deviation (degrees)                    ',
     -              'G-factor                                        '/
      DATA YB     /  10.0,  0.2,  4.85, 5.0, 0.3 /
CHECK v.3.3<--
      DATA YHT    /  10.0 /
CHECK v.3.3-->
C      DATA YLEN   /    43,   29,   28,   28 /
C      DATA YLOWER /   0.0,  0.0,  0.0,  0.0 /
C      DATA YUPPER / 100.0,  2.0, 50.0, 50.0 /
      DATA YLEN   /    43,   29,   28,   28,    8 /
      DATA YLOWER /   0.0,  0.0,  0.0,  0.0, -2.5 /
      DATA YUPPER / 100.0,  2.0, 50.0, 50.0,  1.0 /
CHECK v.3.3<--


C---- Initialise variables
      DO 20, IQUALP = 1, NQUALP
          COEFF(1,IQUALP) = CO(1,IQUALP)
          COEFF(2,IQUALP) = CO(2,IQUALP)
          COEFF(3,IQUALP) = CO(3,IQUALP)
          DESC(IQUALP) = DE(IQUALP)
          YBAND(IQUALP) = YB(IQUALP)
 20   CONTINUE

C---- Plot the Quality Plots, if required
      IF (PLOTQY) THEN

C----     Initialise plot headings
CHECK v.3.3-->
C          PLDESC = 'Equivalent resolution'
C          PLHAND = 'equivresl'
	   IF (NMR) THEN
              PLDESC = 'Equivalent resolution'
              PLHAND = 'equivresl'
              YTOP = YORIGN
	   ELSE
              PLDESC = 'Residue property comparison'
              PLHAND = 'proptycmp'
              YTOP = YORIGN - 50.0
           ENDIF
CHECK v.3.3<--
          PTITLE = PLDESC

C----     Open new PostScript file
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,PLHAND,WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(PLTYPE),PTITLE,1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,1)
CHECK v.3.4<--
          CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
CHECK v.3.4-->
C     -        INCOLR(PLTYPE),COLPLT(1,PLTYPE),1,PLABEL)
     -        INCOLR(PLTYPE),COLPLT(1,PLTYPE),1,PLABEL,RSELEC)
CHECK v.3.4<--

C----     Initialise variables
          NGRAPH = 0
          XCENTR = XORIGN + XMWID + XSEP / 2.0
CHECK v.3.3-->
C          YL = YORIGN + 3.0 * YMWID + 2.0 * YSEP
          YL = YTOP + 3.0 * YMWID + 2.0 * YSEP
CHECK v.3.3<--
          SCALEX = XMWID / (MAXX - MINX)
          CALL PSLWID(0.1)

C----     Main graph heading
CHECK v.3.3-->
C          CALL PSCTXT(XCENTR,YL + 56.0,30.0,GTITLE)
          IF (NMR) THEN
              CALL PSCTXT(XCENTR,YL + 56.0,30.0,GTITLE)
          ELSE
CHECK v.3.4.3-->
C              CALL PSCTXT(XCENTR,YL + 56.0,30.0,CTITLE)
              CALL PSCTXT(XCENTR,YL + 86.0,30.0,CTITLE)
CHECK v.3.4.3<--
          ENDIF
CHECK v.3.3<--
CHECK v.3.4.3-->
C          CALL PSCTXT(XCENTR,YL + 26.0,25.0,TITLE(1:TLEN))
          IF (NMR) THEN
              CALL PSCTXT(XCENTR,YL + 26.0,25.0,TITLE(1:TLEN))
          ELSE
              CALL PSCTXT(XCENTR,YL + 56.0,25.0,TITLE(1:TLEN))
          ENDIF
CHECK v.3.4.3<--

C----     Print program name in top left-hand corner
          IF (NMR) THEN
              CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,
     -            'PROCHECK-NMR')
          ELSE
              CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,
     -            'PROCHECK-COMP')
          ENDIF

C----     Plot the axes
          DO 500, IGRAPH = 1, 3
CHECK v.3.3-->
C              YL = YORIGN + (3 - IGRAPH) * (YMWID + YSEP)
              YL = YTOP + (3 - IGRAPH) * (YMWID + YSEP)
CHECK v.3.3<--
              YR = YL + YMWID
              DO 400, JGRAPH = 1, 2
                  NGRAPH = NGRAPH + 1
                  XL = XORIGN + (JGRAPH - 1) * (XMWID + XSEP)
                  XR = XL + XMWID

C----             If one of the graphs, then do the plot
                  DOGRAF = .TRUE.
CHECK v.3.3-->
C                  IF (IGRAPH.EQ.3) DOGRAF = .FALSE.
                  IF (IGRAPH.EQ.3 .AND. JGRAPH.EQ.2) DOGRAF = .FALSE.
CHECK v.3.3<--
                  IF (DOGRAF) THEN

C----                 Calculate the ensemble mean value, so that can get
C                     an approximate value for the equivalent resolution
                      MEAN = 0.0
                      NPOINT = 0
                      MAXSVL = 0.0
                      DO 100, IFILE = 1, NFILE

CHECK v.3.4-->
C----                     Process only if this is one of the selected models
                          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

                              IF (SVALUE(NGRAPH,IFILE).LT.900.0) THEN
                                  MEAN = MEAN + SVALUE(NGRAPH,IFILE)
                                  NPOINT = NPOINT + 1
                                  MAXSVL = MAX(SVALUE(NGRAPH,IFILE),
     -                                MAXSVL)
                              ENDIF

C----                     For NMR, set a nominal resolution
C                         to be 2.5 Angstroms
CHECK v.3.3-->
C                          IF (ENSEMB .OR. NMR) THEN
                              IF (NMR) THEN
CHECK v.3.3<--
                                  XVALUE(IFILE) = 2.5
CHECK v.3.3-->
                              ELSE
                                  XVALUE(IFILE) = IFILE
                              ENDIF
CHECK v.3.3<--
CHECK v.3.4-->
                          ENDIF
CHECK v.3.4<--
 100                  CONTINUE
                      IF (NPOINT.GT.0) THEN
                          MEAN = MEAN / REAL(NPOINT)
                      ENDIF
                      STATVL(NGRAPH) = MEAN

C----                 Write out background shade for the plot
                      CALL PSLWID(0.1)
                      IF (BSHADE(PLTYPE)) THEN
                          SHADE = 0.95
                          CALL PSHADE(SHADE,COLPLT(2,PLTYPE),RGB,
     -                        MXCOLR,INCOLR(PLTYPE))
                          CALL PSUBOX(XL,YL,XL,YR,XR,YR,XR,YL)
                      ENDIF

C----                 Adjust upper y-bound if maximum point off end
C                     of scale
 50                   CONTINUE
                          IF (MAXSVL.GT.YUPPER(NGRAPH)) THEN
                              YUPPER(NGRAPH) = 2.0 * YUPPER(NGRAPH)
                              GO TO 50
                          ENDIF

C----                 Draw axes
                      CALL AXES(XL,XR,YL,YR,NTICKX - 1,
     -                    NGAPY(NGRAPH),MINX,MAXX,YLOWER(NGRAPH),
     -                    YUPPER(NGRAPH),10.0,INTRLX,INTRLY(NGRAPH),
     -                    15.0,.TRUE.,.TRUE.,.TRUE.,.FALSE.,.FALSE.)

C----                 Graph heading and x-axis title
                      CALL PSCTXT((XL + XR) / 2.0,YL + YMWID + 8.0,
     -                    10.0,GSTIT(NGRAPH)(1:TITLEN(NGRAPH)))
CHECK v.3.4-->
C                      IF (NFILE.EQ.1 .OR. NMR) THEN
                      IF (NMODEL.EQ.1 .OR. NMR) THEN
CHECK v.3.4<--
                          CALL PSCTXT((XL + XR) / 2.0,YL - 16.0,
     -                        10.0,'Resolution (Angstroms)')
                      ENDIF

C----                 y-axis title
                      CALL PSRCTX(XL - 30.0,(YL + YR) / 2.0,10.0,
     -                    YAXIS(NGRAPH)(1:YLEN(NGRAPH)))

C----                 Draw the shaded band representing acceptable
C                     values
                      CALL CURSHD(0.0,COEFF(3,NGRAPH),
     -                    COEFF(2,NGRAPH),COEFF(1,NGRAPH),
     -                    YLOWER(NGRAPH),YUPPER(NGRAPH),
     -                    YBAND(NGRAPH),XL,XR,YL,YR,MINX,MAXX,
CHECK v.3.4.3-->
C     -                    RESMIN,NFILE,RGAP,INCOLR(PLTYPE),MXCOLR,
     -                    RESMIN,RGAP,INCOLR(PLTYPE),MXCOLR,
CHECK v.3.4.3<--
     -                    RGB,COLPLT(3,PLTYPE),NMR,MEAN,
CHECK v.3.4-->
C     -                    RESNEA(NGRAPH))
     -                    RESNEA(NGRAPH),NMODEL)
CHECK v.3.4<--

C----                 Loop through all the points corresponding to be
C                     plotted
                      DO 300, IFILE = 1, NFILE

CHECK v.3.4-->
C----                     Process only if this is one of the selected models
                          IF (MWANT(IFILE)) THEN
CHECK v.3.4<--

C----                         Plot only valid values
                              IF (SVALUE(NGRAPH,IFILE).LT.900.0) THEN

C----                             For NMR, use the nearest-resolution
                                  IF (NMR) XVALUE(IFILE)
     -                                = RESNEA(NGRAPH)

C----                             Calculate coordinates of the point
                                  X = XL + SCALEX
     -                                 * (XVALUE(IFILE) - MINX)
                                  Y = YL + (YR - YL)
     -                                 * (SVALUE(NGRAPH,IFILE)
     -                                 - YLOWER(NGRAPH))
     -                                 / (YUPPER(NGRAPH)
     -                                 - YLOWER(NGRAPH))
                                  YABOVE = (YR - YL) * (YUPPER(NGRAPH)
     -                                 - SVALUE(NGRAPH,IFILE))
     -                                 / (YUPPER(NGRAPH)
     -                                 - YLOWER(NGRAPH))

C----                             Plot the point
                                  X1 = X - MSIZE
                                  X2 = X + MSIZE
                                  Y1 = Y - MSIZE
                                  Y2 = Y + MSIZE
CXXX                                  CALL PSLINE(X1,Y1,X2,Y2)
CXXX                                  CALL PSLINE(X2,Y1,X1,Y2)

C----                             Plot clear or filled box depending on
C                                 whether more than one model
                                  ICOLR = 1
CHECK v.3.4-->
C                                  IF (NFILE.GT.1) THEN
                                  IF (NMODEL.GT.1) THEN
CHECK v.3.4<--
                                      CALL PSLWID(0.2)
                                      SHADE = 1.0
                                  ELSE
                                      SHADE = 0.0
                                      CALL PSLWID(0.1)
                                  ENDIF
                                  CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,
     -                                .FALSE.)
                                  CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----                             Label point with its model number
CHECK v.3.4-->
C                                  IF (NFILE.GT.1) THEN
                                  IF (NMODEL.GT.1) THEN
CHECK v.3.4<--
                                      WRITE(NUMBER,110) IFILE
 110                                  FORMAT(I3)
                                      IF (NUMBER(2:2).EQ.' ') THEN
                                          IPOS = 3
                                      ELSE IF (NUMBER(1:1).EQ.' ') THEN
                                          IPOS = 2
                                              ELSE
                                          IPOS = 1
                                      ENDIF
CHECK v.3.4-->
C                                      IF (NFILE.LT.10) THEN
                                      IF (TOPMOD.LT.10) THEN
CHECK v.3.4<--
                                          TSIZE = 6.0
                                      ELSE
                                          TSIZE = 4.0
                                      ENDIF
                                      CALL PSCTXT(X,Y,TSIZE,
     -                                    NUMBER(IPOS:))
                                  ENDIF

C----                             If the point has a label, print that
                                  IF (MKNAME(IFILE).NE.' ') THEN

C----                                 Determine label length
                                      NAME = MKNAME(IFILE)
                                      TLENTH = 0
                                      IPOS = 11
 200                                  CONTINUE
                                          IPOS = IPOS - 1
                                          IF (NAME(IPOS:IPOS).NE.' ')
     -                                         THEN
                                              TLENTH = IPOS
                                          ENDIF
                                      IF (TLENTH.EQ.0 .AND. IPOS.GT.1)
     -                                    GO TO 200

C----                                 Print the label
                                      IF (NLABEL.LT.8) THEN
                                          CALL PSCTXT(X,Y+YHT,8.0,
     -                                        NAME(1:TLENTH))
                                      ELSE
                                          IF (TLENTH * CWIDTH.GT.YABOVE)
     -                                        THEN
                                              CALL PSRTXT(X+HWIDX,
     -                                            Y-YHT/2.0-TLENTH
     -                                            *CWIDTH,
     -                                            8.0,NAME(1:TLENTH))
                                          ELSE
                                              CALL PSRTXT(X+HWIDX,
     -                                            Y+YHT/2.5,8.0,
     -                                            NAME(1:TLENTH))
                                          ENDIF
                                      ENDIF
                                  ENDIF
                              ENDIF
CHECK v.3.4-->
                          ENDIF
CHECK v.3.4<--
 300                  CONTINUE

C----                 Plot the mean position
CHECK v.3.3-->
                      IF (NMR) THEN
CHECK v.3.3<--
                          Y = YL + (YR - YL)
     -                         * (MEAN - YLOWER(NGRAPH))
     -                         / (YUPPER(NGRAPH) - YLOWER(NGRAPH))
                          CALL PSOCIR(X,Y,1.5 * DIARAD)
CHECK v.3.3-->
                      ENDIF
CHECK v.3.3<--

C----             Otherwise, if box on bottom right, draw it
                  ELSE IF (IGRAPH.EQ.3 .AND. JGRAPH.EQ.2) THEN
                      CALL PSLWID(0.6)
                      CALL PSHADE(1.0,0,RGB,MXCOLR,.FALSE.)
                      CALL PSBBOX(XL,YL,XL,YR,XR,YR,XR,YL)
                      TSIZE = 25.0
                      IF (TLEN.GT.10) TSIZE = TSIZE * 10.0 / TLEN
                      CALL PSCTXT((XL + XR) / 2.0,
     -                     YL + (YR - YL) * 0.6,TSIZE,TITLE(1:TLEN))
                      IF (.NOT.NMR) THEN
CHECK v.3.4.3-->
C                          WRITE(IREC,340) RESMIN
C 340                      FORMAT('Resolution ',F4.2,'A')
C                          CALL PSCTXT((XL + XR) / 2.0,
C     -                         YL + (YR - YL) * 0.4,12.0,IREC(1:16))
                          CALL PSCTXT((XL + XR) / 2.0,
     -                         YL + (YR - YL) * 0.4,12.0,
     -                         'Shaded bars are for')
                          WRITE(IREC,340) RESMIN
 340                      FORMAT('resolution of ',F4.2,'A')
                          CALL PSCTXT((XL + XR) / 2.0,
     -                         YL + (YR - YL) * 0.4 - 12.0,12.0,
     -                         IREC(1:19))
CHECK v.3.4.3<--
                      ENDIF
                  ENDIF
 400          CONTINUE
 500      CONTINUE

C----     Print the statistics at the bottom of the page, as in
C         pplot.f, if all files have the same resolution
CHECK v.3.3-->
C          CALL QSTAT(RESNEA,NFILE)
          IF (NMR) CALL QSTAT(RESNEA,NFILE)
CHECK v.3.3<--

CHECK v.3.3-->
C----     Print key for model numbers
          IF (ENSEMB) THEN
              KEYPSX = XORIGN + 2 * XMWID + XSEP + 6.0 * MKSZ
              KEYPSY = YTOP + 3.0 * YMWID + 2.0 * YSEP - MKSZ
              CALL FILKEY(KEYPSX,KEYPSY,MKSZ,MKSZ,8.0,5.0,NFILE)
          ENDIF
CHECK v.3.3<--

C----     Close the PostScript file
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CURSHD  -  Shade in the 'expected' regions with resolution
C                        for the main-chain and side-chain plots
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE CURSHD(A3,A2,A1,C,VMIN,VMAX,VDIFF,XPOS1,XPOS2,YPOS1,
CHECK v.3.4.3-->
C     -    YPOS2,MINX,MAXX,RESOL,NFILE,RGAP,INCOLR,MXCOLR,RGB,COLOUR,
     -    YPOS2,MINX,MAXX,RESOL,RGAP,INCOLR,MXCOLR,RGB,COLOUR,
CHECK v.3.4.3<--
CHECK v.3.4-->
C     -    NMR,MEAN,RESNEA)
     -    NMR,MEAN,RESNEA,NMODEL)
CHECK v.3.4<--

CHECK v.3.4-->
C      INTEGER       COLOUR, CURRNT, IRESOL, LAST, MXCOLR, NFILE, NRESOL
CHECK v.3.4.3-->
C      INTEGER       COLOUR, CURRNT, IRESOL, LAST, MXCOLR, NFILE, NMODEL,
C     -              NRESOL
      INTEGER       COLOUR, CURRNT, IRESOL, LAST, MXCOLR, NMODEL, NRESOL
CHECK v.3.4.3<--
CHECK v.3.4<--
      LOGICAL       INCOLR, NMR
      REAL          A1, A2, A3, C, DX, MAXX, MEAN, MINDIF, MINX, RESNEA,
     -              RESOL, RGAP, RGB(3,MXCOLR), VBOT, VDIFF, VMAX, VMID,
     -              VMIN, VTOP, X(2), XPOS1, XPOS2, XSCALE, XVALUE,
     -              YBOT(2), YDIFF, YMID(2), YPOS1, YPOS2, YTOP(2),
     -              YSCALE

C---- Determine the number of resolution steps required, and initialise
CHECK v.3.4-->
C      IF (NFILE.EQ.1 .OR. NMR) THEN
      IF (NMODEL.EQ.1 .OR. NMR) THEN
CHECK v.3.4<--
          NRESOL = (MAXX - MINX) / RGAP + 1
          RESOL = MINX
          MINDIF = 999.9
          DX = RGAP
      ELSE
          NRESOL = 2
          DX = MAXX - MINX
      ENDIF
      XVALUE = MINX
      CURRNT = 1
      LAST = 2
      XSCALE = (XPOS2 - XPOS1) / (MAXX - MINX)
      YSCALE = (YPOS2 - YPOS1) / (VMAX - VMIN)

C---- Loop through the resolution steps
      DO 200, IRESOL = 1, NRESOL

C----     Calculate current x-value in PostScript coordinates
          X(CURRNT) = XPOS1 + XSCALE * (XVALUE - MINX)

C----     Calculate the three y-values
          VMID = A3 * RESOL * RESOL * RESOL
     -        + A2 * RESOL * RESOL
     -        + A1 * RESOL + C
          VBOT = VMID - VDIFF
          VTOP = VMID + VDIFF

C----     For NMR, find the closest mid-value to the ensemble mean
          IF (NMR) THEN
              YDIFF = ABS(MEAN - VMID)
              IF (YDIFF.LT.MINDIF) THEN
                  RESNEA = XVALUE
                  MINDIF = YDIFF
              ENDIF
          ENDIF

C----     Make sure no line is off graph
          VBOT = MAX(VMIN,VBOT)
          VMID = MAX(VMIN,VMID)
          VTOP = MAX(VMIN,VTOP)
          VBOT = MIN(VMAX,VBOT)
          VMID = MIN(VMAX,VMID)
          VTOP = MIN(VMAX,VTOP)

C----     Convert into PostScript coordinates
          YBOT(CURRNT) = YPOS1 + YSCALE * (VBOT - VMIN)
          YMID(CURRNT) = YPOS1 + YSCALE * (VMID - VMIN)
          YTOP(CURRNT) = YPOS1 + YSCALE * (VTOP - VMIN)

C----     If this is not the first point, draw shaded region and line segments
          IF (IRESOL.GT.1) THEN

C----         Draw the shaded region
              CALL PSHADE(0.5,COLOUR,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(X(LAST),YBOT(LAST),X(LAST),YTOP(LAST),
     -            X(CURRNT),YTOP(CURRNT),X(CURRNT),YBOT(CURRNT))

C----         Draw the three line segments
              CALL PSLINE(X(LAST),YBOT(LAST),X(CURRNT),YBOT(CURRNT))
              CALL PSLINE(X(LAST),YMID(LAST),X(CURRNT),YMID(CURRNT))
              CALL PSLINE(X(LAST),YTOP(LAST),X(CURRNT),YTOP(CURRNT))
          ENDIF

C----     Increment resolution value and swap storage pointers
          XVALUE = XVALUE + DX
CHECK v.3.4-->
C          IF (NFILE.EQ.1 .OR. NMR) RESOL = XVALUE
          IF (NMODEL.EQ.1 .OR. NMR) RESOL = XVALUE
CHECK v.3.4<--
          CURRNT = 3 - CURRNT
          LAST = 3 - LAST
200   CONTINUE

C---- If the shaded region is a horizontal line, then return nearest
C     resolution as 2.5 Angstroms
      IF (NMR .AND. A1.EQ.0.0 .AND. A2.EQ.0.0) THEN
          RESNEA = 2.5
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE QSTAT  -  Print the overall statistics on the main-chain
C                       and side-chain parameters plots
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE QSTAT(RESNEA,NFILE)

      SAVE

      INCLUDE 'mplot.inc'

      CHARACTER*7   INOUT
      CHARACTER*130 IREC
      INTEGER       IGRAPH, NFILE, NGRAPH
      LOGICAL       FIRST, REVERS
      REAL          BANDS, CMPVAL, RESNEA(NQUALP), SAVEY, XCENTR, XPOS1,
     -              XPOS2, XPOS3, XPOS4, XPOS5, XPOS6, XSTART, Y, YGAP

      DATA  FIRST / .TRUE. /
      DATA  XSTART, YGAP / -20.0, 9.0 /
      DATA  XPOS1, XPOS2, XPOS3, XPOS4, XPOS5, XPOS6
     -    / 135.0, 177.0, 220.0, 256.0, 301.0, 323.0 /

C---- Initialise variables
      XCENTR = XORIGN + XMWID + XSEP / 2.0
      IF (FIRST) THEN
          XSTART = XORIGN + XSTART
          XPOS1 = XORIGN + XPOS1
          XPOS2 = XORIGN + XPOS2
          XPOS3 = XORIGN + XPOS3
          XPOS4 = XORIGN + XPOS4
          XPOS5 = XORIGN + XPOS5
          XPOS6 = XORIGN + XPOS6
          FIRST = .FALSE.
      ENDIF
      Y = YORIGN - 40.0

C---- Print statistics
      IF (PLSTAT.EQ.1) THEN
          IREC = 'Plot statistics (Average of structures)'
          CALL PSCTXT(XCENTR,Y,12.0,IREC(1:39))
      ELSE IF (PLSTAT.EQ.2) THEN
          WRITE(IREC,20) AVESTR
 20       FORMAT('Plot statistics (Average structure: No.',I3,')')
          CALL PSCTXT(XCENTR,Y,12.0,IREC(1:43))
      ELSE IF (PLSTAT.EQ.3) THEN
          WRITE(IREC,40) ENASTR
 40       FORMAT('Plot statistics (Energy-minimized structure: No.',
     -        I3,')')
          CALL PSCTXT(XCENTR,Y,12.0,IREC(1:52))
      ELSE IF (PLSTAT.EQ.4) THEN
          WRITE(IREC,60) ASTSTR
 60       FORMAT('Plot statistics (Structure no.',I3,')')
          CALL PSCTXT(XCENTR,Y,12.0,IREC(1:34))
      ELSE
          IREC = 'Plot statistics (Average of structures)'
          CALL PSCTXT(XCENTR,Y,12.0,IREC(1:15))
      ENDIF
      Y = Y - 1.5 * YGAP

C---- Column headings
      SAVEY = Y
      WRITE(IREC,80)
 80   FORMAT(
     -    '                                           Mean')
      CALL QPUT(XSTART,XPOS1,XPOS2,XPOS3,XPOS4,XPOS5,XPOS6,Y,YGAP,
     -    IREC)
      Y = SAVEY
      CALL PSCTXT((XPOS3 + XPOS4) / 2.0,Y,9.0,'Comparison values')
      CALL PSCTXT(XPOS5,Y,9.0,'No. of')
      Y = Y - YGAP
      WRITE(IREC,100)
 100  FORMAT(
     -    '                                No. of   parameter  Typic',
     -    'al   Band    band widths          ')
      CALL QPUT(XSTART,XPOS1,XPOS2,XPOS3,XPOS4,XPOS5,XPOS6,Y,YGAP,
     -    IREC)
      WRITE(IREC,120)
 120  FORMAT(
     -    'Stereochemical parameter       data pts    value     valu',
     -    'e    width    from mean           ')
      CALL QPUT(XSTART,XPOS1,XPOS2,XPOS3,XPOS4,XPOS5,XPOS6,Y,YGAP,
     -    IREC)
      Y = Y - YGAP / 2.0
      CALL PSLWID(0.2)
      CALL PSLINE(XSTART,Y + 0.5 * YGAP,XPOS6,Y + 0.5 * YGAP)
      Y = Y - YGAP / 2.0

C---- Initialise graph start
      NGRAPH = 0

C---- Loop through the graphs on this plot
      DO 500, IGRAPH = 1, 4
          NGRAPH = NGRAPH + 1
          IF (NGRAPH.EQ.1) THEN
              REVERS = .TRUE.
          ELSE
              REVERS = .FALSE.
          ENDIF
          CALL BANDIS(0.0,COEFF(3,NGRAPH),COEFF(2,NGRAPH),
     -        COEFF(1,NGRAPH),RESMIN,STATVL(NGRAPH),CMPVAL,
     -        YBAND(NGRAPH),BANDS,INOUT,REVERS)
          IF (COEFF(2,NGRAPH).EQ.0.0 .AND.
     -        COEFF(3,NGRAPH).EQ.0.0) THEN
              WRITE(IREC,220) DESC(NGRAPH), NFILE, STATVL(NGRAPH),
     -            CMPVAL, YBAND(NGRAPH), BANDS, INOUT
 220          FORMAT(A30,I6,4X,F8.1,2X,F8.1,F8.1,3X,F8.1,4X,A)
          ELSE
              WRITE(IREC,240) DESC(NGRAPH), NFILE, STATVL(NGRAPH),
     -            CMPVAL, YBAND(NGRAPH), RESNEA(NGRAPH)
 240          FORMAT(A30,I6,4X,F8.1,2X,F8.1,F8.1,3X,'       -',
     -            4X,'Equiv.resolution: ',F8.1)
          ENDIF
          CALL QPUT(XSTART,XPOS1,XPOS2,XPOS3,XPOS4,XPOS5,XPOS6,
     -        Y,YGAP,IREC)
 500  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE QPUT  -  Print statistics line for stereochemical quality
C                      plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE QPUT(XSTART,X1,X2,X3,X4,X5,X6,Y,YGAP,IREC)

      CHARACTER*(*) IREC
      REAL          XSTART, X1, X2, X3, X4, X5, X6, Y, YGAP

C---- Print the text and numbers
      CALL PSTEXT(XSTART,Y,9.0,IREC(1:30))
      CALL PSCTXT(X1,Y,9.0,IREC(31:40))
      CALL PSCTXT(X2,Y,9.0,IREC(41:51))
      CALL PSCTXT(X3,Y,9.0,IREC(52:60))
      CALL PSCTXT(X4,Y,9.0,IREC(61:68))
      CALL PSCTXT(X5,Y,9.0,IREC(69:81))
      CALL PSTEXT(X6,Y,9.0,IREC(82:118))

C---- Increment y-value
      Y = Y - YGAP

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE BANDIS  -  Calculate number of band-widths current
C                        stereochemical parameter is from the expected
C                        value
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE BANDIS(A3,A2,A1,C,X,Y,CMPVAL,BWIDTH,BANDS,
     -    INOUT,REVERS)

      INCLUDE 'mplot.inc'

      CHARACTER*7   INOUT
      LOGICAL       REVERS
      REAL          A1, A2, A3, BANDS, BWIDTH, C, CMPVAL, DIFF,
     -              X, Y


C---- Calculate the comparison value, difference, and number of bands
C     difference
      CMPVAL = A3 * X * X * X
     -    + A2 * X * X
     -    + A1 * X + C
      DIFF = Y - CMPVAL
      BANDS = DIFF / BWIDTH
      IF (REVERS) BANDS = -1.0 * BANDS
      IF (BANDS.GT.1.0) INOUT = 'WORSE'
      IF (BANDS.LE.1.0) INOUT = 'Inside'
      IF (BANDS.EQ.0.0) INOUT = 'Inside'
      IF (BANDS.LT.0.0) INOUT = 'Inside'
      IF (BANDS.LT.-1.0) INOUT = 'BETTER'
      IF (REVERS) BANDS = -1.0 * BANDS

      RETURN
      END

C--------------------------------------------------------------------------
