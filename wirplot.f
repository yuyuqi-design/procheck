C**************************************************************************
C
C  WIRPLOT.FOR  -  Wiring-diagram plot of secondary structure and estimated
C                  accessibility from a given .rin file (created by running
C                  CLEAN and SECSTR from the PROCHECK suite)
C
C--------------------------------------------------------------------------
C
C Compilation and linking (on unix)
C -----------------------
C
C f77 -u -C -c wirplot.f
C f77 -u -C -c ps.f
C f77 -o wirplot wirplot.o ps.o
C
C Compiling under g77:-
C
C f77 -Wimplicit -fbounds-check -c wirplot.f
C
C Compilation and linking (on VAX VMS)
C -----------------------
C
C FORT WIRPLOT
C FORT PS
C LINK WIRPLOT, PS
C
C Note: For stand-alone use, NOPRNT should be set to .FALSE. and
C       the CALL GETPTH line should be commented out.
C
C--------------------------------------------------------------------------
C
C
C Files
C -----
C
C  1 <filename>.rin   - File generated by program SECSTR, containing the
C                       residue-by-residue information on the given
C                       structure, including Kabsch & Sander secondary
C                       structure assignments
C  2 <brcode>_<type>.html - PROMOTIF data files, one for each type of
C                       data on the given PDB code
C  2 <brcode>_con.dat - List of residues involved in H-bonds and non-bonded
C                       contacts with ligand(s)
C  2 introns.dat      - File containing intron positions
C  2 <filename>       - Name of PDB file
C  3 cath.domains     - Domain definitions for all the PDB files
C  7 sites<chain-ID>.html - Output HTML file describing the active sites
C                       and residues involved
C 11 <filename>_nn.ps - Output PostScript files, numbered nn = 01, 02, ...
C                       with the last-used number being picked up from
C                       the ps.number file
C
C--------------------------------------------------------------------------
C
C Subroutine calling tree
C -----------------------
C
C   MAIN  --> GETFIL  --> GETNAM
C         --> GETPTH  --> GETPAR  --> GETDET  --> INTERP
C                                             --> EXPTOK  --> LOCTOK
C                                             --> STORTK
C                                 --> GETVAL
C         --> INITS   --> CHNCOL
C         --> OPNRIN
C         --> GETOOI
C         --> REARIN
C         --> PRCSST
C         --> REARES  --> OPNPDB
C                     --> CHKMET
C         --> GETPRM
C         --> CHKPRM
C         --> GETDOM  --> EXTDOM  --> GETTOK
C                                 --> FORMRS
C         --> GETSIT
C         --> GETCON
C         --> GETINT
C         --> PLTSST  --> PSTART  --> PSNAME
C                                 --> PSOPEN
C                                 --> PSPAGE
C                                 --> PSCTXT
C                                 --> PSLWID
C                     --> SECPLT  --> ACCSHD  --> PSCALE
C                                             --> PSUBOX
C                                 --> PSLWID
C                                 --> SSDRAW  --> PSLWID
C                                             --> PSLINE
C                                             --> PSTEXT
C                                             --> PSHADE
C                                             --> PSUBOX
C                                             --> PSUTRI
C                                             --> DHELIX  --> PSHADE
C                                                         --> PSUBOX
C                                                         --> PSLWID
C                                 --> PSCOLB
C                                 --> PSTEXT
C                                 --> PSSAVE
C                                 --> PSTXTG
C                                 --> PSREST
C                                 --> PSLINE
C                                 --> PSARC
C                                 --> SITCOL
C                                 --> PSHADE
C                                 --> PSTRIA
C                                 --> PSCISS
C                                 --> DOMCOL
C                                 --> PSCTXT
C                                 --> PSDASH
C                                 --> PINTIC  --> PSLWID
C                                             --> PSLINE
C                                 --> PINRNO
C                                 --> PSCCOL
C                                 --> PSCIRC
C                     --> SITKEY  --> PSLWID
C                                 --> PSTEXT
C                                 --> SITCOL
C                                 --> PSHADE
C                                 --> PSTRIA
C                     --> INTKEY  --> PSLWID
C                                 --> PSCISS
C                     --> SSKEY   --> PSLWID
C                                 --> PSTEXT
C                                 --> DHELIX  --> PSHADE
C                                             --> PSUBOX
C                                             --> PSLWID
C                                 --> PSHADE
C                                 --> PSUBOX
C                                 --> PSUTRI
C                                 --> PSLINE
C                                 --> PSBBOX
C                     --> JOINCS
C                     --> CONVRT
C                     --> PSPEND
C                     --> PSCLOS
C         --> WRSITE  --> SITCOL
C
C--------------------------------------------------------------------------



      PROGRAM wirplot

      INCLUDE 'wirplot.inc'

      CHARACTER*(FILEN) DOMFIL, PDBDIR(MAXPDB), PDBPRE(MAXPDB),
     -              PDBSUF(MAXPDB), PRODIR
      INTEGER       LENSTR
      LOGICAL       HAVRIN, SHWACC, SHWDET


C---- Initialise variables
      CGIRUN = .FALSE.
      IFAIL = .FALSE.
      NOPRNT = .TRUE.
      SHWACC = .FALSE.
      SHWDET = .FALSE.

C---- Read in the code of the Brookhaven file
      CALL GETFIL
      IF (IFAIL) GO TO 990

C---- Get the paths to the files that may be required
      CALL GETPTH(PDBDIR,PDBPRE,PDBSUF,PRODIR,DOMFIL)

C---- Set path to directory where WWW files are stored and to CATH domains
C     file
      FILPS = 'wirplot'
      FLEN = LENSTR(FILPS)

C---- Initialise variables
      CALL INITS

C---- Open the .rin file
      CALL OPNRIN(HAVRIN)

C---- If have the .rin file, then pick up all the relevant information
      IF (HAVRIN) THEN

C----     If not writing for the WWW page, pick up the Ooi numbers for
C         estimating the residue accessibilities
          IF (.NOT.WFORM) THEN
              CALL GETOOI
              IF (IFAIL) GO TO 990
          ENDIF

C----     Read through the .rin file and store all the required residue
C         details
          CALL REARIN

C----     Process the secondary structure elements
          CALL PRCSST
          IF (IFAIL) GO TO 990

C---- Otherwise, if no .rin file, need to get the residue sequence from
C     the PDB file
      ELSE

C----     Read in the residue sequence from the PDB file
          CALL REARES(PDBDIR,PDBPRE,PDBSUF)
          IF (IFAIL) GO TO 990
      ENDIF

C---- Get any PROMOTIF data that might be there
      CALL GETPRM(BRCODE,CHAIN,PRODIR,NDATA,RANGE,DTYPE,DATINF,
     -    MXDATA,RESSEQ,NRESID)

C---- Determine whether PROMOTIF data is to be used
      CALL CHKPRM

C---- Locate the domains information for the current chain
      IF (DOMFIL.NE.' ') THEN
          CALL GETDOM(DOMFIL,RESSEQ,RESDOM,NRESID,BRCODE,CHAIN,NDOM,
     -        HAVDOM,SHWDET)
      ENDIF

C---- Pick up the any SITE records from the original PDB file
      CALL GETSIT(CHAIN,PDBFIL,RESSEQ,RESNAM,RESCHN,
     -    RESITE,SITNAM,MXSITE,MXRES,NRESID,HAVSIT,NSITE,SUSED,
     -    NUSED,WFORM,CGIRUN)

C---- Pick up the contacts this chain makes with any ligands
      CALL GETCON(BRCODE,CHAIN,PRODIR,RESSEQ,RESNAM,RESCHN,RESDNA,
     -    RESLIG,RESMET,NRESID,HAVCON,WFORM,CGIRUN)

C---- Pick up the this chain's intron positions
COUT      CALL GETINT(BRCODE,CHAIN,PRODIR,RESSEQ,RESNAM,RESINT,MXRES,
COUT     -    NRESID,HAVINT,WFORM)

C---- Set parameters for this type of plot
      IPLOT = 0
      NHELIX = 0
      NSTRND = 0
      SHOWAC = .FALSE.
      NPAGE = 0
      NPINS = MXPIN2
      SHOWKY = .FALSE.
      XPWID = XPWID2

C---- Plot the secondary structure
      CALL PLTSST

C---- Write out the active site details, if relevant
      IF (WFORM .AND. NUSED.GT.0) THEN
          CALL WRSITE(BRCODE,CHAIN,PRODIR,PDBFIL,SITNAM,MXSITE,NSITE,
     -        SUSED,NUSED)
      ENDIF

990   CONTINUE
      IF (IFAIL) THEN
          PRINT*, '*** Program wirplot terminated with error'
      ELSE
          PRINT*, '*'
          PRINT*, '* Program complete'
      ENDIF
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETFIL  -  Read in the filename and chain ID
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETFIL

      INCLUDE 'wirplot.inc'

      CHARACTER*1   YESNO
      INTEGER       LINE
      LOGICAL       IERROR

C---- Initialise variables
      LINE = 0

C---- Accept name of original .pdb file holding the structure
      IF (.NOT.NOPRNT) THEN
          PRINT*, 'Enter filename containing coordinates of structure'
      ENDIF
      READ(*,110) PDBFIL
 110  FORMAT(A)

C---- Peel off directory path and extension
      CALL GETNAM(PDBFIL,ISTART,IEND,IERROR)
      IF (IERROR) GO TO 990

C---- Form names of other files that will be required in default directory
      FILRIN = PDBFIL(ISTART:IEND) // '.rin'
      FILRSA = PDBFIL(ISTART:IEND) // '.rsa'

C---- Get the PDB code
      ILEN = IEND - ISTART + 1
      IF (ILEN.GT.4) THEN
          ILEN = 4
          ISTART = IEND - 3
      ENDIF
      BLEN = ILEN
      BRCODE = PDBFIL(ISTART:IEND)
      CHAIN = ' '

C---- Get the chain letter, if required
      IF (.NOT.NOPRNT) THEN
          PRINT*, 'Enter required chain-ID (leave blank for all)'
      ENDIF
      READ(*,110) CHAIN

C---- Get whether plot required for WWW pages (internal use only)
      IF (.NOT.NOPRNT) THEN
          PRINT*, 'Is plot required for WWW pages? (Y/N) or (C)GI run?'
      ENDIF
      READ(*,110) YESNO
      IF (YESNO.EQ.'C' .OR. YESNO.EQ.'c') CGIRUN = .TRUE.
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          WFORM = .TRUE.
      ELSE
          WFORM = .FALSE.
      ENDIF
      IF (WFORM .OR. CGIRUN) THEN
          NPINS = MXPINW
          SSSIZE = SSSIZW
          XPORIG = XPORW
          XPWID = XPWIDW
      ELSE
          NPINS = MXPINS
          SSSIZE = SSSIZ
          XPORIG = XPORG
          XPWID = XPWIDE
      ENDIF

C---- Get the file-number
C      PRINT*, 'Enter file-number for output PostScript file'
C      READ*, INPLOT
C      IF (INPLOT.GT.0) THEN
C          IPLOT = INPLOT - 1
C      ELSE
          IPLOT = 0
C      ENDIF

      GO TO 999

C---- Fatal errors
990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETPTH  -  Get the paths to the files that may be required
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETPTH(PDBDIR,PDBPRE,PDBSUF,PRODIR,DOMFIL)

      INCLUDE 'wirplot.inc'

      CHARACTER*1   CH, USCORE
      CHARACTER*20  KEY
      CHARACTER*(FILEN) DOMFIL, FILNAM, PDBDIR(MAXPDB), PDBPRE(MAXPDB),
     -              PDBSUF(MAXPDB), PRODIR
      INTEGER       IPDB, IPOS, LENSTR

C---- Get all the possible PDB directory pathnames
      DO 200, IPDB = 1, MAXPDB

C----     Get the append-character
          CH = ' '
          USCORE = ' '
          IF (IPDB.GT.1) THEN
              IPOS = LENSTR(KEY) + 1
              CH = CHAR(ICHAR('A') + IPDB - 2)
              USCORE = '_'
          ENDIF

C----     Locate PDB_PREFIX parameter
          KEY = 'PDB_PREFIX' // USCORE // CH
          CALL GETPAR(KEY,PDBPRE(IPDB),FILEN)

C----     Locate PDB_SUFFIX parameter
          KEY = 'PDB_SUFFIX' // USCORE // CH
          CALL GETPAR(KEY,PDBSUF(IPDB),FILEN)

C----     Locate PDB_DIR parameter
          KEY = 'PDB_DIR' // USCORE // CH
          CALL GETPAR(KEY,PDBDIR(IPDB),FILEN)
 200  CONTINUE

C---- Locate PDBSUM_REAL_DIR parameter
      CALL GETPAR('PDBSUM_REAL_DIR',PRODIR,FILEN)

C---- Locate PROSITE_FILE parameter
      CALL GETPAR('PROSITE_FILE',FILNAM,FILEN)

C---- Locate DOMALL_FILE parameter
      CALL GETPAR('DOMALL_FILE',DOMFIL,FILEN)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETPAR  -  Get the required file parameter
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETPAR(KEY,FILNAM,FILEN)

      SAVE

      INTEGER       MAXPAR, STRLEN
      PARAMETER    (MAXPAR = 500, STRLEN = 256)

      CHARACTER*(*) KEY, FILNAM
      CHARACTER*(STRLEN) TOKNAM(MAXPAR), TOKVAL(MAXPAR)
      INTEGER       FILEN, NTOKEN
      LOGICAL       FIRST, HAVCAT, IFAIL

      DATA FIRST   / .TRUE. /
      DATA HAVCAT  / .FALSE. /

C---- Initialise variables
      FILNAM = ' '
      IFAIL = .FALSE.

C---- If this is the first call, then read in all the parameters from
C     the CATHPARAM file
      IF (FIRST) THEN

C----     Reset the flag
          FIRST = .FALSE.

C----     Read in all the parameters from the CATHPARAM file
          CALL GETDET(NTOKEN,TOKNAM,TOKVAL,STRLEN,MAXPAR,IFAIL)
          IF (IFAIL) GO TO 999

C----     Set flag indicating that we have the CATHPARAM file
          HAVCAT = .TRUE.
      ENDIF

C---- Get the value corresponding to the given token
      IF (HAVCAT) THEN
          CALL GETVAL(KEY,FILNAM,FILEN,NTOKEN,TOKNAM,TOKVAL,STRLEN,
     -        MAXPAR)
      ENDIF

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETDET  -  Read in all the parameters from the CATHPARAM file
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETDET(NTOKEN,TOKNAM,TOKVAL,STRLEN,MAXPAR,IFAIL)

      INTEGER       LINLEN, MAXNAM
      PARAMETER    (LINLEN = 1000,MAXNAM = 7)

      INTEGER       MAXPAR, STRLEN

      CHARACTER*1   TOKNAM(STRLEN,MAXPAR), TOKVAL(STRLEN,MAXPAR)
      CHARACTER*100 PARNAM(MAXNAM)
      CHARACTER*(LINLEN) IREC
      INTEGER       IFILE, LEN, LENSTR, LINE, NTOKEN
      LOGICAL       HAVFIL, IFAIL

      DATA PARNAM /
     -    './param/CATHPARAM',
     -    '../cath/param/CATHPARAM',
     -    '../cath/param/CATHPARAM',
     -    'CATHPARAM',
     -    '/nfs/httpd/cgi-bin/cath/param/CATHPARAM',
     -    '/usr/local/httpd/cgi-bin/cath/param/CATHPARAM',
     -    '/ebi/research/thornton/www/databases/cgi-bin/param/CATHPARAM'
     -   /

C---- Initialise variables
      HAVFIL = .FALSE.
      LINE = 0
      NTOKEN = 0

C---- Loop while trying to locate the CATHPARAM file
      DO 300, IFILE = 1, MAXNAM

C----     Open the parameter file
          OPEN(UNIT=1, FILE=PARNAM(IFILE), STATUS='OLD',
     -        FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -        READONLY,
     -        ERR=300)

C----     File opened
          HAVFIL = .TRUE.
          GO TO 500
 300  CONTINUE

C---- If file not found, display error message
      IF (.NOT.HAVFIL) THEN
C          PRINT*, '*** ERROR. CATHPARAM file not found'
          IFAIL = .TRUE.
          GO TO 999
      ENDIF

C---- Read through the file, storing all the tokens and their translations
 500  CONTINUE

C----     Read in the next line from the file
          READ(1,520,END=800,ERR=800) IREC
 520      FORMAT(A)

C----     Get the line-length
          LEN = LENSTR(IREC)

C----     Process if line is not blank and is not a comment line
          IF (LEN.GT.1 .AND. IREC(1:1).NE.'#') THEN

C----         Interpret and expand the tokens on this line
              CALL INTERP(IREC,LEN,TOKNAM,TOKVAL,MAXPAR,STRLEN,NTOKEN)

C----         Expand token value if it is a compound name involving a
C             prior token value
              CALL EXPTOK(TOKNAM,TOKVAL,MAXPAR,STRLEN,NTOKEN)
          ENDIF

C---- Loop back for next record in file
      GO TO 500

C---- End of file reached
 800  CONTINUE

C---- Close the file
      CLOSE(1)

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE INTERP  -  Interpret and expand the tokens on this line
C
C----------------------------------------------------------------------+---

      SUBROUTINE INTERP(IREC,LEN,TOKNAM,TOKVAL,MAXPAR,STRLEN,NTOKEN)

      INTEGER       MAXPAR, STRLEN

      CHARACTER*1   CH, TABCH, TOKNAM(STRLEN,MAXPAR),
     -              TOKVAL(STRLEN,MAXPAR)
      CHARACTER*(*) IREC
      INTEGER       I, IPOS, LEN, LENNAM, LENVAL, NTOKEN, OUTPOS, STATE
      LOGICAL       DONE, HAVTOK, INNAME, SAVECH

C---- Initialise variables
      DONE = .FALSE.
      HAVTOK = .FALSE.
      INNAME = .TRUE.
      LENNAM = 0
      LENVAL = 0
      OUTPOS = 0
      STATE = 0
      TABCH = CHAR(9)

C---- Loop through all the characters in the line
      DO 1000, IPOS = 1, LEN

C----     Get the character at this position
          CH = IREC(IPOS:IPOS)
          SAVECH = .FALSE.

C----     Process according to current state

C----     State 0: Looking for first non-blank character
          IF (STATE.EQ.0) THEN

C----         If non-blank, then initialise and switch state
              IF (CH.NE.' ' .AND. CH.NE.TABCH) THEN

C----             Initialise for token or token-string
                  OUTPOS = 0
                  SAVECH = .TRUE.
                  STATE = 1

              ENDIF

C----     State 1: Adding characters to current string
          ELSE IF (STATE.EQ.1) THEN

C----         If non-blank, then add to current string
              IF (CH.NE.' ' .AND. CH.NE.TABCH) THEN
                  SAVECH = .TRUE.

C----         Otherwise, have reached end of current token
	      ELSE

C----             Terminate string and switch state
                  CH = ' '
                  IF (HAVTOK) THEN
                      DONE = .TRUE.
                  ELSE
                      STATE = 2
                  ENDIF
                  SAVECH = .FALSE.
              ENDIF

C----     State 2: Looking for equals sign
          ELSE IF (STATE.EQ.2) THEN

C----         If this is an equals sign, the switch state
              IF (CH.EQ.'=') THEN
                  STATE = 0
                  INNAME = .FALSE.
              ENDIF
          ENDIF

C----     If saving character, then do so
          IF (SAVECH) THEN

C----         If this is the first character of the name, then
C             increment token-count
              IF (INNAME .AND. OUTPOS.EQ.0) THEN

C----             Increment token count
                  NTOKEN = NTOKEN + 1

C----             Check that maximum not exceeded
                  IF (NTOKEN.GT.MAXPAR) THEN
                      NTOKEN = MAXPAR
                  ENDIF

C----             Initialise token name and value
                  DO 300, I = 1, STRLEN
                      TOKNAM(I,NTOKEN) = ' '
                      TOKVAL(I,NTOKEN) = ' '
 300              CONTINUE
              ENDIF

C----         Increment character position
              OUTPOS = OUTPOS + 1

C----         Check that not off end of string
              IF (OUTPOS.GT.STRLEN) THEN
                  OUTPOS = STRLEN
              ENDIF

C----         Save in token name or token value
              IF (INNAME) THEN
                  TOKNAM(OUTPOS,NTOKEN) = CH
                  LENNAM = OUTPOS
              ELSE
                  TOKVAL(OUTPOS,NTOKEN) = CH
                  LENVAL = OUTPOS
                  HAVTOK = .TRUE.
              ENDIF
          ENDIF

C----     If done, then end here
          IF (DONE) GO TO 999
 1000 CONTINUE

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE EXPTOK  -  Expand token value if it is a compound name
C                        involving a prior token value
C
C----------------------------------------------------------------------+---

      SUBROUTINE EXPTOK(TOKNAM,TOKVAL,MAXPAR,STRLEN,NTOKEN)

      INTEGER       MAXLEN
      PARAMETER    (MAXLEN = 1000)

      INTEGER       MAXPAR, STRLEN

      CHARACTER*1   CH, TOKNAM(STRLEN,MAXPAR), TOKVAL(STRLEN,MAXPAR)
      CHARACTER*(MAXLEN) STRING, TMPSTR, TOKSUB
      INTEGER       I, IEND, IPOS, ISTART, LEN, LENSTR, LENSUB, LENTOK,
     -              NTOKEN

C---- Extract the current token
      STRING = ' '
      LEN = STRLEN
      DO 100, IPOS = 1, STRLEN

C----     Get current character
          CH = TOKVAL(IPOS,NTOKEN)

C----     If not a space, copy across to string
          IF (CH.NE.' ') THEN
              STRING(IPOS:IPOS) = CH
              LEN = IPOS

C----     Otherwise, stop here
          ELSE
              GO TO 200
          ENDIF
 100  CONTINUE

C---- Loop until all token expansion complete
 200  CONTINUE

C----     Check whether expansion is required
          IPOS = INDEX(STRING,'$(')

C----     If no more expansion required, jump out of loop
          IF (IPOS.EQ.0) GO TO 999

C----     Find the token-string to be substituted
          ISTART = IPOS
          TMPSTR = STRING(IPOS:)
          IEND = IPOS + INDEX(TMPSTR,')') - 1

C----     If have valid start- and end-values, perform the substitution
          IF (ISTART.GT.0 .AND. IEND.GT.0) THEN

C----         Get the length of token-name to be looked up
              LENTOK = IEND - ISTART - 2

C----         Splice out the token-name to be substituted
              TOKSUB = TMPSTR(3:LENTOK + 2)

C----         Locate the token and replace its name by its value
              CALL LOCTOK(TOKSUB,LENTOK,TOKNAM,TOKVAL,MAXPAR,STRLEN,
     -            NTOKEN,TMPSTR,LENSUB)

C----         Splice together the new token value
              IF (ISTART.GT.1) THEN
                  TOKSUB = STRING(1:ISTART - 1) // TMPSTR(1:LENSUB) //
     -                STRING(IEND + 1:)
              ELSE
                  TOKSUB = TMPSTR(1:LENSUB) // STRING(IEND + 1:)
              ENDIF
              LEN = LENSTR(TOKSUB)

C----         Initialise token value
              DO 300, I = 1, STRLEN
                  TOKVAL(I,NTOKEN) = ' '
 300          CONTINUE

C----         Store the updated token value
              DO 400, I = 1, LEN
                  TOKVAL(I,NTOKEN) = TOKSUB(I:I)
 400          CONTINUE

C----         Store new string version
              STRING = TOKSUB
          ENDIF

C---- Loop back
      GO TO 200

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE LOCTOK  -  Locate the token and replace its name by its value
C
C----------------------------------------------------------------------+---

      SUBROUTINE LOCTOK(TOKSUB,LENTOK,TOKNAM,TOKVAL,MAXPAR,STRLEN,
     -    NTOKEN,TMPSTR,LEN)

      INTEGER       MAXPAR, STRLEN

      CHARACTER*(*) TMPSTR, TOKSUB
      CHARACTER*1   CH, TOKNAM(STRLEN,MAXPAR), TOKVAL(STRLEN,MAXPAR)
      INTEGER       IPOS, ITOKEN, LEN, LENTOK, NTOKEN
      LOGICAL       DONE

C---- Initialise variables
      DONE = .FALSE.
      LEN = 0
      TMPSTR = ' '

C---- Loop through all the tokens until get a match
      DO 800, ITOKEN = 1, NTOKEN

C----     Extract the current token name
          TMPSTR = ' '
          LEN = STRLEN
          DO 100, IPOS = 1, STRLEN

C----         Get current character
              CH = TOKNAM(IPOS,ITOKEN)

C----         If not a space, copy across to string
              IF (CH.NE.' ') THEN
                  TMPSTR(IPOS:IPOS) = CH
                  LEN = IPOS

C----         Otherwise, stop here
              ELSE
                  GO TO 200
              ENDIF
 100      CONTINUE

C----     Token name extracted
 200      CONTINUE

C----     If the token to be substituted equals the current name, then
C         have found what we're looking for
          IF (TMPSTR(1:LEN).EQ.TOKSUB(1:LENTOK)) THEN

C----         Extract the corresponding token value
              TMPSTR = ' '
              LEN = STRLEN
              DO 400, IPOS = 1, STRLEN

C----             Get current character
                  CH = TOKVAL(IPOS,ITOKEN)

C----             If not a space, copy across to string
                  IF (CH.NE.' ') THEN
                      TMPSTR(IPOS:IPOS) = CH
                      LEN = IPOS

C----             Otherwise, stop here
                  ELSE
                      GO TO 999
                  ENDIF
 400          CONTINUE

C----         Jump out of loop
              GO TO 999
          ENDIF
 800  CONTINUE

C---- If have found a match, then blank out return value
      TMPSTR = ' '
      LEN = 0

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETVAL  -  Get the value corresponding to the given token
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETVAL(KEY,FILNAM,FILEN,NTOKEN,TOKNAM,TOKVAL,STRLEN,
     -    MAXPAR)

      INTEGER       MAXLEN
      PARAMETER    (MAXLEN = 1000)

      INTEGER       MAXPAR, STRLEN

      CHARACTER*1   CH, TOKNAM(STRLEN,MAXPAR), TOKVAL(STRLEN,MAXPAR)
      CHARACTER*(MAXLEN) STRING
      CHARACTER*(*) KEY, FILNAM
      INTEGER       FILEN, IPOS, ITOKEN, LEN, LENSTR, LENTOK, NTOKEN

C---- Initialise variables
      DO 50, IPOS = 1, FILEN
          FILNAM(IPOS:IPOS) = ' '
 50   CONTINUE

C---- Get the length of the search key
      LEN = LENSTR(KEY)

C---- Loop through all the tokens until get a match
      DO 800, ITOKEN = 1, NTOKEN

C----     Extract the current token name
          STRING = ' '
          LENTOK = STRLEN
          DO 100, IPOS = 1, STRLEN

C----         Get current character
              CH = TOKNAM(IPOS,ITOKEN)

C----         If not a space, copy across to string
              IF (CH.NE.' ') THEN
                  STRING(IPOS:IPOS) = CH
                  LENTOK = IPOS

C----         Otherwise, stop here
              ELSE
                  GO TO 200
              ENDIF
 100      CONTINUE

C----     Token name extracted
 200      CONTINUE

C----     If the search key matches the token name, then have found
C         what we're after
          IF (STRING(1:LENTOK).EQ.KEY(1:LEN)) THEN

C----         Determine length to be transferred
              LEN = MIN(FILEN,STRLEN)

C----         Transfer token value across to answer-field
              DO 400, IPOS = 1, LEN

C----             If non-blank, then copy across
                  IF (TOKVAL(IPOS,ITOKEN).NE.' ') THEN
                      FILNAM(IPOS:IPOS) = TOKVAL(IPOS,ITOKEN)

C----             Otherwise, jump out
                  ELSE
                      GO TO 999
                  ENDIF
 400          CONTINUE

C----         Jump out of loop
              GO TO 999
          ENDIF
 800  CONTINUE

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE INITS  -  Initialise variables
C
C----------------------------------------------------------------------+---

      SUBROUTINE INITS

      INCLUDE 'wirplot.inc'

      CHARACTER*10  CNAME
      CHARACTER*80  COLINE(MXCOLR)
      INTEGER       CHCOLR, I, ICHAIN, ICOLR

      DATA COLINE /
     -    '0.0000 0.0000 0.0000  BLACK         <- Colour 1',
     -    '1.0000 1.0000 1.0000  WHITE         <- Colour 2',
     -    '1.0000 0.0000 0.0000  RED           <- Colour 3',
     -    '0.0000 1.0000 0.0000  GREEN         <- Colour 4',
     -    '0.0000 0.0000 0.8000  BLUE          <- Colour 5',
     -    '1.0000 1.0000 0.0000  YELLOW        <- Colour 6',
     -    '0.8000 0.5000 0.0000  ORANGE        <- Colour 7',
     -    '0.5000 1.0000 0.0000  LIME GREEN    <- Colour 8',
     -    '0.7000 0.2000 1.0000  PURPLE        <- Colour 9',
     -    '0.5000 1.0000 1.0000  CYAN          <- Colour 10',
     -    '1.0000 0.5000 1.0000  PINK          <- Colour 11',
     -    '0.3000 0.8000 1.0000  SKY BLUE      <- Colour 12',
     -    '1.0000 1.0000 0.7000  CREAM         <- Colour 13',
     -    '0.0000 1.0000 1.0000  TURQUOISE     <- Colour 14',
     -    '1.0000 0.0000 1.0000  LILAC         <- Colour 15',
     -    '0.8000 0.0000 0.0000  BRICK RED     <- Colour 16',
     -    '0.5000 0.0000 0.0000  BROWN         <- Colour 17',
     -    '0.9700 0.9700 0.9700  LIGHT GREY    <- Colour 18',
     -    '1.0000 1.0000 1.0000  WHITE         <- Colour 19',
     -    '1.0000 1.0000 1.0000  WHITE         <- Colour 20' /


C---- Initialise variables and set default parameter values
      HAVCON = .FALSE.
      HAVDOM = .FALSE.
      HAVINT = .FALSE.
      HAVSIT = .FALSE.
      INCOLR = .TRUE.
      NCOLOR = 20
      NDATA = 0
      NDATAR = 0
      NHELIX = 0
      NOLABL = .TRUE.
      NPAGE = 0
      NSITE = 0
      NSTRND = 0
      NUSED = 0
      SHOWAC = .TRUE.
      SHOWDS = .FALSE. 
      SHOWKY = .FALSE.
      SHOWRS = .TRUE.
      USEPRM = .FALSE.

C---- Initialise the RGB colour table
      DO 200, ICOLR = 1, MXCOLR
          READ(COLINE(ICOLR),120) (RGB(I,ICOLR), I = 1, 3),
     -        COLNAM(ICOLR)
 120      FORMAT(3(F6.4,1X),1X,A12)
 200  CONTINUE

C---- Colours for: 1. Background, 2. secondary structure, 3. minimum
C     accessibility, and 4. maximum accessibility
      COLPLT(1) = 2
      COLPLT(2) = 13
      COLPLT(3) = 9
      COLPLT(4) = 2

C---- If plotting for WWW, use different colours
      IF (WFORM .OR. CGIRUN) THEN
          CALL CHNCOL(ICHAIN,CHAIN,CHCOLR,CNAME)
          COLPLT(2) = CHCOLR
          COLPLT(3) = 4
          COLPLT(4) = 6
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE OPNRIN  -  Open the input .rin file
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNRIN(HAVRIN)

      INCLUDE 'wirplot.inc'

      INTEGER       IRESID
      LOGICAL       HAVRIN

C---- Initialise variables
      HAVRIN = .FALSE.
      NCIS = 0
      NDAM = 0
      NDISUL = 0
      NENDCH = 0
      DO 100, IRESID = 1, MXRES
          RESBRK(IRESID) = ' '
          RESSST(IRESID) = ' '
          RESACC(IRESID) = 0.0
          RESCIS(IRESID) = ' '
          RESDAM(IRESID) = ' '
          RESDOM(IRESID) = 0
          RESINT(1,IRESID) = .FALSE.
          RESINT(2,IRESID) = .FALSE.
          RESINT(3,IRESID) = .FALSE.
          RESNAM(IRESID) = ' '
          RESSEQ(IRESID) = ' '
          RESCHN(IRESID) = ' '
          RESDNA(IRESID) = 0
          RESLIG(IRESID) = 0
          RESMET(IRESID) = 0
          RESITE(1,IRESID) = 0
          RESITE(2,IRESID) = 0
 100  CONTINUE

C---- Open the data file holding the residue information, <filename>.rin
      OPEN(UNIT=1, FILE=FILRIN, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    ERR=999)

C---- Set flag that have the .rin file
      HAVRIN = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETOOI  -  Read through the .rin file to get the maximum and
C                        minimum OOi numbers, and total number of residues
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETOOI

      INCLUDE 'wirplot.inc'

      INTEGER       LINE, OOI1, OOI2

C---- Rewind the residue-information file (.rin)
      REWIND(1)

C---- Initialise variables
      LINE = 0
      NRESID = 0

C---- Read in the first record from the residue-information file
      READ(1,80,END=500,ERR=902) OOI1, OOI2
 80   FORMAT(106X,2I3)
      LINE = LINE + 1
      NRESID = NRESID + 1

C---- Initialise the maximum and minimum Ooi numbers
      OOIMAX = OOI2
      OOIMIN = OOI2

C---- Read through the residues file (.rin)
 100  CONTINUE

C----     Read in the next record
          READ(1,80,END=500,ERR=902) OOI1, OOI2

C----     Update maximum and minimum OOi numbers, as necessary
          OOIMAX = MAX(OOI2,OOIMAX)
          OOIMIN = MIN(OOI2,OOIMIN)
          NRESID = NRESID + 1

C---- Loop back for next record in file
      GO TO 100

C---- End of file reached
 500  CONTINUE

C---- Adjust max and min values if they're equal
      IF (OOIMIN.EQ.OOIMAX) THEN
          OOIMIN = OOIMIN - 1.0
          OOIMAX = OOIMAX + 1.0
      ENDIF

      GO TO 999

C---- Fatal errors
902   CONTINUE
      PRINT*, '*** ERROR. Data error in .rin file at line:', LINE + 1
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE REARIN  -  Read through the .rin file and store the
C                        secondary structure and sequence information
C
C----------------------------------------------------------------------+---

      SUBROUTINE REARIN

      SAVE

      INCLUDE 'wirplot.inc'

      CHARACTER*1   BRKCH, INCHN, SECSTR
      CHARACTER*3   RESDUE
      CHARACTER*5   SEQNO
      INTEGER       IRESID, LINE, OOI1, OOI2, SERNO
      LOGICAL       WANTED
      REAL          CGAMB, CHI1, CHI2, CHI3, CHI4, DIHANG, DISULF, ENHB,
     -              MCBVAL, OMEGA, PHI, PSI, SCBVAL

C---- Initialise variables
      HAVSST = .FALSE.

C---- Rewind the residue-information file (.rin)
      REWIND(1)

C---- Initialise variables
      IRESID = 0
      LINE = 0

C---- Read through the residues file (.rin)
 100  CONTINUE

C----     Read in the first record from the residue-information file
          READ(1,120,END=500,ERR=900) SERNO, RESDUE, BRKCH, INCHN,
     -        SEQNO, SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4,
     -        ENHB, DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
 120      FORMAT(I4,A3,A1,A1,A5,A1,11F7.2,2F7.3,2I3)
          LINE = LINE + 1

C----     Only process this residue if it belongs to the required chain
          IF ((WFORM .OR. CGIRUN) .AND. INCHN.EQ.CHAIN) THEN
              WANTED = .TRUE.
          ELSE IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN
              WANTED = .TRUE.
          ELSE
              WANTED = .FALSE.
          ENDIF
          IF (WANTED) THEN

C----         Increment residue count
              IRESID = IRESID + 1
              IF (IRESID.GT.MXRES) GO TO 902
              IF (SECSTR.NE.' ') THEN
                  HAVSST = .TRUE.
              ENDIF

C----         Store the secondary structure and other residue details
              RESBRK(IRESID) = BRKCH
              RESSST(IRESID) = SECSTR
              RESNAM(IRESID) = RESDUE
              RESSEQ(IRESID) = SEQNO
              RESCHN(IRESID) = INCHN

C----         Case of trans peptide (ie abs(omega) > 45)
              IF (ABS(OMEGA).GE.45.0 .AND. OMEGA.LE.180.0) THEN
                  IF (OMEGA.LT.0.0) OMEGA = OMEGA + 360.0

C----         Case of cis peptide (ie abs(omega) < 45)
              ELSE IF (ABS(OMEGA).LT.45.0) THEN
                  RESCIS(IRESID) = 'c'
                  NCIS = NCIS + 1
              ENDIF

C----         Alpha carbon chirality
              IF (DIHANG.NE.999.9) THEN
                  IF (DIHANG.LT.0) THEN
                      RESDAM(IRESID) = 'D'
                      NDAM = NDAM + 1
                  ENDIF
              ENDIF

C----         Calculate the estimated accessibility from the Ooi number
              RESACC(IRESID) = 100.0 * (OOIMAX - OOI2)
     -            / (OOIMAX - OOIMIN)
          ENDIF

C---- Loop back for next record in file
      GO TO 100

C---- End of file reached
 500  CONTINUE
      NRESID = IRESID

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Data error in .rin file at line:', LINE + 1
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Maximum number of residues, MXRES, exceeded',
     -    MXRES
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PRCSST  -  Process the secondary structure assignments
C                        to remove excessively short secondary structure
C                        elements
C
C----------------------------------------------------------------------+---

      SUBROUTINE PRCSST

      INCLUDE 'wirplot.inc'

      CHARACTER*1   INSST, LSTSST, SAVSST
      INTEGER       IFROM, IPOS, IRESID, NCOUNT

C---- Initialise variables
      LSTSST = ' '
      IFROM = 0
      IRESID = 0
      NCOUNT = 0

C---- Loop through all the stored residues
      DO 600, IRESID = 1, NRESID

C----     Get this residue's secondary structure assignment
          INSST = RESSST(IRESID)

C----     Simplify the codes
          IF (INSST.EQ.'I') INSST = 'H'
          IF (INSST.EQ.'G') INSST = 'H'
          IF (INSST.NE.'H' .AND. INSST.NE.'E') INSST = ' '

C----     Store the simplified secondary structure assignment
          RESSST(IRESID) = INSST

C----     If a blank, then check whether last string was too short
C         for a proper strand or helix
 200      CONTINUE
          IF (INSST.NE.LSTSST .AND. LSTSST.NE.' ') THEN

C----         Check whether length of last secondary structure was
C             below minimum limit
              IF ((LSTSST.EQ.'H' .AND. NCOUNT.LT.MINHEL) .OR.
     -            (LSTSST.EQ.'E' .AND. NCOUNT.LT.MINSTR)) THEN

C----             Set last secondary structure to coil
                  DO 300, IPOS = IFROM, IRESID - 1
                      RESSST(IPOS) = ' '
 300              CONTINUE
              ENDIF

C----         Reset the secondary structure count
              IFROM = 0
              NCOUNT = 0
          ENDIF

C----     Save the details of the current residue
          LSTSST = INSST

C----     Increment count, if relevant
          IF (INSST.NE.' ') THEN
              IF (IFROM.EQ.0) IFROM = IRESID
              NCOUNT = NCOUNT + 1
          ENDIF
 600  CONTINUE

C---- Count the numbers of secondary structure elements stored and
C     lebale the end residues in lower-case versions
      LSTSST = ' '
      DO 800, IRESID = 1, NRESID

C----     Save the current secondary structure assignment
          SAVSST = RESSST(IRESID)

C----     Check if this is the first residue of helix or strand
          IF ((LSTSST.EQ.' ' .AND. RESSST(IRESID).NE.' ') .OR.
     -        (LSTSST.NE.' ' .AND. RESSST(IRESID).NE.LSTSST)) THEN
              NDATAR = NDATAR + 1

C----         Set the secondary structure assignment to lower-case
C             equivalent
              IF (RESSST(IRESID).EQ.'H') RESSST(IRESID) = 'h'
              IF (RESSST(IRESID).EQ.'E') RESSST(IRESID) = 'e'
          ENDIF

C----     If this is the last residue of helix or strand, set to
C         full-stop
          IF (IRESID.EQ.NRESID) THEN
              IF (RESSST(IRESID).EQ.'H') RESSST(IRESID) = '.'
              IF (RESSST(IRESID).EQ.'E') RESSST(IRESID) = ':'
          ELSE IF (RESSST(IRESID).NE.' ' .AND.
     -        (RESSST(IRESID + 1).EQ.' ' .OR.
     -         RESSST(IRESID + 1).NE.SAVSST)) THEN
              IF (RESSST(IRESID).EQ.'H') RESSST(IRESID) = '.'
              IF (RESSST(IRESID).EQ.'E') RESSST(IRESID) = ':'
          ENDIF

C----     Save the current secondary structure assignment
          LSTSST = SAVSST
 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE REARES  -  Read in the residue sequence from the PDB file
C
C----------------------------------------------------------------------+---

      SUBROUTINE REARES(PDBDIR,PDBPRE,PDBSUF)

      SAVE

      INCLUDE 'wirplot.inc'

      REAL          BRKDST, BRKSQR
      PARAMETER    (BRKDST = 4.00, BRKSQR = BRKDST * BRKDST)

      CHARACTER*1   INCHN, LSTCHN
      CHARACTER*3   LSTRES, RESDUE
      CHARACTER*4   ATNAME
      CHARACTER*5   LSTSEQ, SEQNO
      CHARACTER*6   IDENT
      CHARACTER*100 IREC
      CHARACTER*(FILEN) PDBDIR(MAXPDB), PDBPRE(MAXPDB), PDBSUF(MAXPDB)
      INTEGER       IRESID, LENSTR, LINE, LASTER, NCALPH, NMODEL,
     -              NUMATM, NUMHET, NUMTER
      LOGICAL       ENSEMB, METAL, NMR, SWITCH, WANTED
      REAL          DISTSQ, X, XLAST, Y, YLAST, Z, ZLAST

C---- Initialise variables
      NUMATM = 0
      NUMHET = 0
      NUMTER = 0
      ENSEMB = .FALSE.
      NRESID = 0
      LINE = 0
      LSTCHN = '?'
      LSTRES = ' '
      LSTSEQ = ' '
      LASTER = 0
      NCALPH = 0
      NMODEL = 0
      NMR = .FALSE.
      SWITCH = .TRUE.
      WANTED = .FALSE.
      XLAST = 0.0
      YLAST = 0.0
      ZLAST = 0.0

C---- Open the PDB file
      CALL OPNPDB(PDBDIR,PDBPRE,PDBSUF)
      IF (IFAIL) GO TO 900
C      OPEN(UNIT=2, FILE=PDBFIL, STATUS='OLD', FORM='FORMATTED',
C     -    ACCESS='SEQUENTIAL',
CCVAX     -    READONLY,
C     -    ERR=900)

C---- Read through the PDB file
 100  CONTINUE

C----     Read in the next record from the file
          READ(2,220,ERR=902,END=800) IREC
 220      FORMAT(A)
          LINE = LINE + 1
          IDENT = IREC(1:6)

C----     Check that this is a coordinate record
          IF (IDENT.EQ.'ATOM  ' .OR. IDENT.EQ.'HETATM') THEN

C----         If this is an NMR structure, process only if first model
              IF (.NOT.ENSEMB .OR. NMODEL.EQ.1) THEN

C----             Get the atom type and residue type
                  ATNAME = IREC(13:16)
                  RESDUE = IREC(18:20)
                  INCHN = IREC(22:22)
                  SEQNO = IREC(23:27)

C----             Check if residue has changed
                  IF (RESDUE.NE.LSTRES .OR. INCHN.NE.LSTCHN .OR.
     -                SEQNO.NE.LSTSEQ) THEN

C----                 Determine whether this residue is wanted
                      IF ((WFORM .OR. CGIRUN) .AND. INCHN.EQ.CHAIN) THEN
                          WANTED = .TRUE.
                      ELSE IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN
                          WANTED = .TRUE.
                      ELSE
                          WANTED = .FALSE.
                      ENDIF

C----                 Cut out waters
                      IF (RESDUE.EQ.'HOH') WANTED = .FALSE.

C----                 Cut out metals
                      IF (WANTED) THEN
                          CALL CHKMET(ATNAME,METAL)
                          IF (METAL) WANTED = .FALSE.
                      ENDIF

C----                 Check whether we have this residue number already
                      IF (WANTED) THEN

C----                     Loop through all the residues stored so far
                          DO 400, IRESID = 1, NRESID
                              IF (SEQNO.EQ.RESSEQ(IRESID) .AND.
     -                            INCHN.EQ.RESCHN(IRESID)) THEN
                                  WANTED = .FALSE.
                                  GO TO 500
                              ENDIF
 400                      CONTINUE
                      ENDIF

C----                 If residue belongs to the required chain, then
C                     store
 500                  CONTINUE
                      IF (WANTED) THEN

C----                     Increment residue count
                          NRESID = NRESID + 1
                          IF (NRESID.GT.MXRES) GO TO 904

C----                     Store the secondary structure and other
C                         residue details
                          RESSST(NRESID) = ' '
                          RESNAM(NRESID) = RESDUE
                          RESSEQ(NRESID) = SEQNO
                          RESCHN(NRESID) = INCHN

C----                     If this is the first residue of a new chain,
C                         then initialise atom and hetatom counts
                          IF (SWITCH) THEN
                              NUMATM = 0
                              NUMHET = 0
                              SWITCH = .FALSE.
                          ENDIF

C----                     Increment count of ATOM/HETATM residues
                          IF (IDENT.EQ.'ATOM  ') THEN
                              NUMATM = NUMATM + 1
                          ELSE
                              NUMHET = NUMHET + 1
                          ENDIF

C----                 Check if this is a standard amino acid
C                      CALL GETCOD(RESDUE,ONELET,STAMIN,NUCLEO,RNA)

                      ENDIF

C----                 Store current residue's details
                      LSTRES = RESDUE
                      LSTCHN = INCHN
                      LSTSEQ = SEQNO
                  ENDIF

C----             If this is a CA atom of a wanted residue, get its
C                 coordinates
                  IF (WANTED .AND. ATNAME.EQ.' CA ') THEN

C----                 Read in the x-, y- and z-coordinates
                      READ(IREC,740,ERR=902) X, Y, Z
 740                  FORMAT(30X,3F8.3)

C----                 If this is not the first CA atom, then calculate
C                     distance to previous one
                      IF (NCALPH.GT.0 .AND. NRESID.GT.1) THEN

C----                     Calculate distance
                          DISTSQ = (X - XLAST) * (X - XLAST)
     -                        + (Y - YLAST) * (Y - YLAST)
     -                        + (Z - ZLAST) * (Z - ZLAST)

C----                     If distance is much larger than the standard
C                         CA-CA distance, then take it that we have a
C                         chain-break here
                          IF (DISTSQ.GT.BRKSQR) THEN
                              RESBRK(NRESID) = '!'
                              RESBRK(NRESID - 1) = '!'
                          ENDIF
                      ENDIF

C----                 Increment count of relevant C-alphas encountered
                      NCALPH = NCALPH + 1

C----                 Save current residue's C-alpha coords
                      XLAST = X
                      YLAST = Y
                      ZLAST = Z
                  ENDIF
              ENDIF

C----     If MODEL record, then increment count of models processed and
C         reinitialise variables
          ELSE IF (IDENT.EQ.'MODEL ') THEN
              ENSEMB = .TRUE.
              NMODEL = NMODEL + 1
              IF (NMODEL.GT.1 .AND. NRESID.EQ.0) THEN
                  NMODEL = NMODEL - 1
              ENDIF

C----     Check for TER record signifying a chain-end
          ELSE IF (IDENT.EQ.'TER   ') THEN

C----         If have stored any residues note the number of last residue
C             prior to the TER
              IF (.NOT.SWITCH .AND. (NUMATM.GT.0 .OR. NUMHET.GT.0)) THEN
                  LASTER = NUMTER
              ENDIF

C----         Store position of current TER record
              NUMTER = NRESID

C----         Set flag to indicate a new chain
              SWITCH = .TRUE.

C----     If this is a CONECT record then can end here
          ELSE IF (IDENT.EQ.'CONECT') THEN
              GO TO 800
          ENDIF
C---- Loop back for next record
      GO TO 100

C---- End of file reached
 800  CONTINUE

C---- Close the PDB file
      CLOSE(2)

C---- Treat as final TER record encountered
      IF (.NOT.SWITCH .AND. (NUMATM.GT.0 .OR. NUMHET.GT.0)) THEN
          LASTER = NUMTER
      ENDIF

C---- Determine whether last bunch of residues since the last TER were
C     mainly HETATM residues, and hence can be deleted
C      IF (LASTER.GT.0 .AND. NUMATM.EQ.0 .AND. NUMHET.GT.0) THEN
      IF (LASTER.GT.0 .AND. (NUMHET.GT.NUMATM .OR. NUMATM.LT.2)) THEN

C----     Remove the unwanted HET groups
          NRESID = LASTER
      ENDIF

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR opening PDB file [',
     -    PDBFIL(1:LENSTR(PDBFIL)), ']'
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Data error in PDB file at line:', LINE + 1
      GO TO 990

 904  CONTINUE
      PRINT*, '*** ERROR. Maximum number of residues, MXRES, exceeded',
     -    MXRES
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE OPNPDB  -  Locate and open the appropriate PDB file
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNPDB(PDBDIR,PDBPRE,PDBSUF)

      INCLUDE 'wirplot.inc'

      CHARACTER*4   PDBCOD
      CHARACTER*(FILEN) FNAME, PDBDIR(MAXPDB), PDBPRE(MAXPDB),
     -              PDBSUF(MAXPDB)
      INTEGER       IPDB, LENSTR

C---- Initialise variables
      IFAIL = .FALSE.
      PDBCOD = BRCODE

C---- Loop through all the possible PDB directories to find the one
C     containing our file
      DO 800, IPDB = 1, MAXPDB

C----     If directory details not blank, form filename
          IF (LENSTR(PDBDIR(IPDB)).GT.0 .AND.
     -        LENSTR(PDBPRE(IPDB)).GT.0 .AND.
     -        LENSTR(PDBSUF(IPDB)).GT.0) THEN

C----         Form the filename
              FNAME = PDBDIR(IPDB)(1:LENSTR(PDBDIR(IPDB))) // '/' //
     -            PDBPRE(IPDB)(1:LENSTR(PDBPRE(IPDB))) // PDBCOD //
     -            PDBSUF(IPDB)(1:LENSTR(PDBSUF(IPDB)))

C----         Open the PDB file
              OPEN(UNIT=2, FILE=FNAME, STATUS='OLD', FORM='FORMATTED',
     -            ACCESS='SEQUENTIAL',
CVAX     -            READONLY,
     -            ERR=800)

C----         If file successfully opened, then drop out
              GO TO 999
          ENDIF
 800  CONTINUE

C---- Otherwise, PDB file not found
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CHKMET  -  Get the next space-delimited token from the given
C                        input line, starting at the given position
C
C----------------------------------------------------------------------+---

      SUBROUTINE CHKMET(ATNAME,METAL)

      INTEGER       MXMETP
      PARAMETER    (MXMETP = 100)

      CHARACTER*4   ATNAME, METYPE(MXMETP)
      INTEGER       IMETYP
      LOGICAL       METAL

      DATA METYPE / 'HE  ', 'LI  ', 'BE  ', ' B  ', ' F  ',
     -              'NE  ', 'NA  ', 'MG  ', 'AL  ', 'SI  ',
     -              'CL  ', 'AR  ', ' K  ', 'CA  ', 'SC  ',
     -              'TI  ', ' V  ', 'CR  ', 'MN  ', 'FE  ',
     -              'CO  ', 'NI  ', 'CU  ', 'ZN  ', 'GA  ',
     -              'GE  ', 'AS  ', 'SE  ', 'BR  ', 'KR  ',
     -              'RB  ', 'SR  ', ' Y  ', 'ZR  ', 'NB  ',
     -              'MO  ', 'TC  ', 'RU  ', 'RH  ', 'PD  ',
     -              'AG  ', 'CD  ', 'IN  ', 'SN  ', 'SB  ',
     -              'TE  ', ' I  ', 'XE  ', 'CS  ', 'BA  ',
     -              'LA  ', 'CE  ', 'PR  ', 'ND  ', 'PM  ',
     -              'SM  ', 'EU  ', 'GD  ', 'TB  ', 'DY  ',
     -              'HO  ', 'ER  ', 'TM  ', 'YB  ', 'LU  ',
     -              'HF  ', 'TA  ', ' W  ', 'RE  ', 'OS  ',
     -              'IR  ', 'PT  ', 'AU  ', 'HG  ', 'TL  ',
     -              'PB  ', 'BI  ', 'PO  ', 'AT  ', 'RN  ',
     -              'FR  ', 'RA  ', 'AC  ', 'TH  ', 'PA  ',
     -              ' U  ', 'NP  ', 'PU  ', 'AM  ', 'CM  ',
     -              'BK  ', 'CF  ', 'ES  ', 'FM  ', 'MD  ',
     -              'NO  ', 'LR  ', 'MT  ', '    ', '    ' /

C---- NOTE: 'MT' is not a valid atom-name but is found in a number of
C           PDB entries for Mercury (eg 1bn1, 1bn3, 1bn4, 1bnm, 1bnn,
C           1bnt, 1bnu, 1bnw). When these PDB file have been fixed, MT can
C           be removed.

C---- Initialise variables
      METAL = .FALSE.

C---- Search through the metals list
      DO 100, IMETYP = 1, MXMETP
          IF (ATNAME(1:3).EQ.METYPE(IMETYP)(1:3)) THEN
              METAL = .TRUE.
              GO TO 999
          ENDIF
 100  CONTINUE

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETPRM  -  Read in the PROMOTIF analyses, if present
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETPRM(BRCODE,CHAIN,PRODIR,NDATA,RANGE,DTYPE,DATINF,
     -    MXDATA,RESSEQ,NRESID)

      INTEGER       NPFILE
      PARAMETER    (NPFILE = 6)

      INTEGER       MXDATA, NRESID

      CHARACTER*1   CHAIN, CHAIN1, CHAIN2
      CHARACTER*3   DATINF(MXDATA), DTYPE(MXDATA), FTYPE(NPFILE), INFO
      CHARACTER*4   BRCODE
      CHARACTER*5   RANGE(2,MXDATA), RESID1, RESID2, RESSEQ(NRESID)
      CHARACTER*120 FILNAM, IREC, PRODIR
      INTEGER       IDATA, IERROR, IFILE, IRESID, IRES1, IRES2, LEN,
     -              LENSTR, LINE, NDATA, NDISUL, NLINE
      LOGICAL       DEND, DSTART, HAVFIL

      DATA FTYPE  / 'btn', 'dsf', 'gtn', 'hlx', 'hpn', 'str' /

C---- Initialise variables
      LEN = LENSTR(PRODIR)
      NDATA = 0
      NDISUL = 0
      DO 100, IDATA = 1, MXDATA
          DTYPE(IDATA) = ' '
          DATINF(IDATA) = ' '
          RANGE(1,IDATA) = ' '
          RANGE(2,IDATA) = ' '
 100  CONTINUE

C---- Loop over all the different PROMOTIF output files
      DO 800, IFILE = 1, NPFILE

C----     Initialise flag indicating whether PROMOTIF file present
          HAVFIL = .FALSE.
          NLINE = 0

C----     Form this file's name in the WWW directory
          IF (CHAIN.EQ.' ') THEN
              FILNAM = PRODIR(1:LEN) // '/' // BRCODE // '/' // BRCODE
     -            // '_' // FTYPE(IFILE) // '.html'
          ELSE
              FILNAM = PRODIR(1:LEN) // '/' // BRCODE // '/' // BRCODE
     -            // CHAIN // '_' // FTYPE(IFILE) // '.html'
          ENDIF

C----     Open the file
          OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -        ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -        IOSTAT=IERROR)
          IF (IERROR.EQ.0) HAVFIL = .TRUE.

C----     If the file not found there, try the current directory
          IF (.NOT.HAVFIL) THEN

C----         Reform the filename
              IF (CHAIN.EQ.' ') THEN
                  FILNAM = BRCODE // '_' // FTYPE(IFILE) // '.html'
              ELSE
                  FILNAM = BRCODE // CHAIN // '_' // FTYPE(IFILE) //
     -                '.html'
              ENDIF

C----         Try to open the file again
              OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -            ACCESS='SEQUENTIAL',
CVAX     -        READONLY,
     -            IOSTAT=IERROR)
              IF (IERROR.EQ.0) HAVFIL = .TRUE.
          ENDIF

C----     If this PROMOTIF file exists, then pick up the data in it
          IF (HAVFIL) THEN

C----         Initialise variables
              DSTART = .FALSE.
              LINE = 0

C----         Read through this file until hit the start of the data
 200          CONTINUE

C----             Read the next record and check whether it is the start
C                 line
                  READ(2,220,END=700) IREC
 220              FORMAT(A)
                  LINE = LINE + 1
                  IF (IREC(1:10).EQ.'----------') DSTART = .TRUE.
              IF (.NOT.DSTART) GO TO 200

C----         Read in the data records
              DEND = .FALSE.
 400          CONTINUE

C----             Read the next record and check whether it is the end
C                 of the data
                  READ(2,220,END=700) IREC
                  LINE = LINE + 1
                  IF (IREC(1:6).EQ.'</PRE>' .OR.
     -                IREC(1:4).EQ.' <p>') THEN
                      DEND = .TRUE.
                  ELSE IF (IREC.NE.' ') THEN

C----                 Read in the data in the line, depending on the
C                     file type
                      INFO = ' '

C----                 a. Helix 
                      IF (FTYPE(IFILE).EQ.'hlx') THEN
                          READ(IREC,420,IOSTAT=IERROR) RESID1, RESID2
 420                      FORMAT(10X,A5,1X,A5)

C----                 b. Beta strand
                      ELSE IF (FTYPE(IFILE).EQ.'str') THEN
                          READ(IREC,440,IOSTAT=IERROR) RESID1, RESID2,
     -                        INFO(1:1)
 440                      FORMAT(11X,A5,1X,A5,4X,A1)

C----                 c. Beta or gamma turns
                      ELSE IF (FTYPE(IFILE).EQ.'btn' .OR.
     -                    FTYPE(IFILE).EQ.'gtn') THEN
                          READ(IREC,460,IOSTAT=IERROR) RESID1, RESID2
 460                      FORMAT(A5,1X,A5)

C----                 d. Disulphide bridge
                      ELSE IF (FTYPE(IFILE).EQ.'dsf') THEN
                          READ(IREC,480,IOSTAT=IERROR) CHAIN1, RESID1,
     -                        CHAIN2, RESID2
 480                      FORMAT(5X,A1,A5,7X,A1,A5)

C----                     Check which of these belong to the same chain
                          IF (CHAIN1.NE.' ' .AND. CHAIN1.NE.CHAIN) THEN
                              RESID1 = ' '
                          ENDIF
                          IF (CHAIN2.NE.' ' .AND. CHAIN2.NE.CHAIN) THEN
                              RESID2 = ' '
                          ENDIF

C----                     If this disulphide links two different chains,
C                         then mark it as such
                          IF (CHAIN1.NE.CHAIN2) THEN
                              INFO = 'X'

C----                     Otherwise, increment count of disulphides
                          ELSE
                              NDISUL = NDISUL + 1
                              IF (NDISUL.LT.10) THEN
                                  WRITE(INFO,520) NDISUL
 520                              FORMAT(I1,2X)
                              ELSE IF (NDISUL.LT.100) THEN
                                  WRITE(INFO,540) NDISUL
 540                              FORMAT(I2,1X)
                              ELSE
                                  WRITE(INFO,560) NDISUL
 560                              FORMAT(I3)
                              ENDIF
                          ENDIF

C----                 e. Beta hairpin
                      ELSE IF (FTYPE(IFILE).EQ.'hpn') THEN
                          READ(IREC,580,IOSTAT=IERROR) RESID1, RESID2
 580                      FORMAT(6X,A5,10X,A5)

C----                     Check that have both start and end residues
                          IRES1 = 0
                          IRES2 = 0
                          DO 600, IRESID = 1, NRESID
                              IF (RESSEQ(IRESID).EQ.RESID1)
     -                            IRES1 = IRESID
                              IF (RESSEQ(IRESID).EQ.RESID2)
     -                            IRES2 = IRESID
 600                      CONTINUE
                          IF (IRES1.EQ.NRESID) IRES1 = 0
                          IF (IRES2.EQ.1) IRES2 = 0

C----                     If haven't identified the start or end
C                         residues, then discard the hairpin
                          IF (IRES1.EQ.0 .OR. IRES2.EQ.0 .OR.
     -                        IRES1.GT.IRES2 - 1) THEN
                              PRINT*, '*** Warning. Beta hairpin disca',
     -                            'rded: ', RESID1, '(', CHAIN, ') ',
     -                            RESID2, '(', CHAIN, ') '
                              RESID1 = ' '
                              RESID2 = ' '

C----                     Otherwise, move range in by one residue at
C                         either end
                          ELSE
                              RESID1 = RESSEQ(IRES1 + 1)
                              RESID2 = RESSEQ(IRES2 - 1)
                          ENDIF
                      ENDIF

C----                 If read-error encountered, print error message
                      IF (IERROR.NE.0) THEN
                          PRINT*, '*** Warning. Format error in PROMO',
     -                        'TIF file, ', FTYPE(IFILE), ' at line ',
     -                        LINE
                      ENDIF

C----                 Increment count of data items read in
                      NLINE = NLINE + 1

C----                 Increment total residue ranges
                      NDATA = NDATA + 1

C----                 Check that limit not exceeded
                      IF (NDATA.GT.MXDATA) THEN
                          PRINT*, '*** Warning. Maximum number of PROM',
     -                        'OTIF data items exceeded, MXDATA', MXDATA
                          PRINT*, '***          Some data lost'

C----                 Otherwise store the residue range and data type
                      ELSE
                          RANGE(1,NDATA) = RESID1
                          RANGE(2,NDATA) = RESID2
                          DTYPE(NDATA) = FTYPE(IFILE)
                          DATINF(NDATA) = INFO
                      ENDIF
                  ENDIF
              IF (.NOT.DEND) GO TO 400

C----         Close the PROMOTIF file
 700          CONTINUE
              CLOSE(2)
          ENDIF

 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CHKPRM  -  Determine whether to use the PROMOTIF information
C
C----------------------------------------------------------------------+---

      SUBROUTINE CHKPRM

      INCLUDE 'wirplot.inc'

      CHARACTER*1   ENDSTR, SECSTR
      CHARACTER*5   RESID1, RESID2
      INTEGER       IDATA, IRESID, JRESID, NHELKS, NHELP, NSTRKS,
     -              NSTRP
      LOGICAL       BLANK, INRANG

C---- Count the number of helices and strands in the Kabsch & Sander
C     assignment
      NHELKS = 0
      NSTRKS = 0
      DO 100, IRESID = 1, NRESID
          IF (RESSST(IRESID).EQ.'h') THEN
              NHELKS = NHELKS + 1
          ELSE IF (RESSST(IRESID).EQ.'e') THEN
              NSTRKS = NSTRKS + 1
          ENDIF
 100  CONTINUE

C---- Count the number of PROMOTIF helices and strands
      NHELP = 0
      NSTRP = 0
      DO 200, IDATA = 1, NDATA
          IF (DTYPE(IDATA).EQ.'hlx') THEN
              NHELP = NHELP + 1
          ELSE IF (DTYPE(IDATA).EQ.'str') THEN
              NSTRP = NSTRP + 1
          ENDIF
 200  CONTINUE

C---- If number of PROMOTIF data items is greater than those from the .rin
C     file, then replace with the latter with the former
      IF (NDATA.GT.0) THEN

C----     Set flag to indicate that PROMOTIF data to be used
          USEPRM = .TRUE.
          NOLABL = .FALSE.

C----     Determine whether to blank out the K & S assignments (do so only
C         if PROMOTIF gives at least as many helices and strands as the
C         K & S assignments - this may not be true if PROMOTIF has not
C         been completely run on this structure)
          BLANK = .FALSE.
          IF (NHELP.GE.NHELKS .AND. NSTRP.GE.NSTRKS) THEN
              BLANK = .TRUE.
          ELSE

C----         Print warning messages
              IF (NHELP.LT.NHELKS) THEN
                  PRINT*, '*** Warning. PROMOTIF has assigned fewer he',
     -                'lices than in the K & S assignment'
                  PRINT*, '***          The latter assignments will be',
     -                'retained'
              ENDIF
              IF (NSTRP.LT.NSTRKS) THEN
                  PRINT*, '*** Warning. PROMOTIF has assigned fewer be',
     -                'ta strands than in the K & S assignment'
                  PRINT*, '***          The latter assignments will be',
     -                'retained'
              ENDIF

C----         Set flag so that PROMOTIF numbering isn't used for strands
C             and helices
              NOLABL = .TRUE.
          ENDIF

C----     Blank out all the .rin secondary structure assignments
          IF (BLANK) THEN
              DO 500, IRESID = 1, NRESID
                  RESSST(IRESID) = ' '
 500          CONTINUE
          ENDIF

C----     Loop through all the PROMOTIF data items, assigning the helices
C         and strands, and shifting turn positions by one residue
          DO 800, IDATA = 1, NDATA

C----         If this is a helix, strand or turn, then get the range
              IF (DTYPE(IDATA).EQ.'hlx' .OR. DTYPE(IDATA).EQ.'str' .OR.
     -            DTYPE(IDATA).EQ.'btn' .OR. DTYPE(IDATA).EQ.'gtn') THEN

C----             Extract the relevant residue-range
                  RESID1 = RANGE(1,IDATA)
                  RESID2 = RANGE(2,IDATA)
                  IF (DTYPE(IDATA).EQ.'hlx') THEN
                      ENDSTR = 'h'
                      SECSTR = 'H'
                  ELSE IF (DTYPE(IDATA).EQ.'str') THEN
                      ENDSTR = 'e'
                      SECSTR = 'E'
                  ELSE
                      SECSTR = ' '
                  ENDIF
                  INRANG = .FALSE.

C----             Loop through all the residues to find and mark all
C                 the residues within this range
                  DO 700, IRESID = 1, NRESID

C----                 Check whether this is the start of the
C                     residue-range
                      IF (RESSEQ(IRESID).EQ.RESID1) INRANG = .TRUE.

C----                 For helix or strand, mark residue if in range
                      IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'E') THEN


C----                     Update only if have blanked out all the K & S
C                         assignments
                          IF (BLANK) THEN

C----                         If within the residue range, then update the
C                             residue's secondary structure
                              IF (INRANG) RESSST(IRESID) = SECSTR

C----                         Check whether this is the end of the
C                             residue-range
                              IF (RESSEQ(IRESID).EQ.RESID2) THEN
                                  INRANG = .FALSE.
                              ENDIF

C----                         If this is either end of the structure, use the
C                             lower-case equivalent or full-stop
                              IF (RESSEQ(IRESID).EQ.RESID1) THEN
                                  RESSST(IRESID) = ENDSTR
                              ELSE IF (RESSEQ(IRESID).EQ.RESID2) THEN
                                  IF (SECSTR.EQ.'H')
     -                                RESSST(IRESID) = '.'
                                  IF (SECSTR.EQ.'E')
     -                                RESSST(IRESID) = ':'
                              ENDIF
                          ENDIF

C----                 For turns, shift start-position by 1 residue
                      ELSE IF (INRANG) THEN
                          JRESID = IRESID + 1
                          IF (JRESID.LE.NRESID) THEN
                              RANGE(1,IDATA) = RESSEQ(JRESID)
                          ENDIF
                          INRANG = .FALSE.
                      ENDIF
 700              CONTINUE
              ENDIF
 800      CONTINUE
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETDOM  -  Read in the CATH domain details, if present
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETDOM(DOMFIL,RESSEQ,RESDOM,NRESID,BCODE,CHAIN,NDOM,
     -    HAVDOM,SHWDET)

      INTEGER       LINLEN, MAXDET
      PARAMETER    (
     -              LINLEN = 256,
     -              MAXDET = 200
     -             )

      INTEGER       NRESID

      CHARACTER*1   CHAIN, INCHN
      CHARACTER*4   BRCODE
      CHARACTER*5   RESID1, RESID2, RESSEQ(NRESID)
      CHARACTER*15  DOMDET(MAXDET)
      CHARACTER*80  ERRMES
      CHARACTER*(*) BCODE, DOMFIL
      CHARACTER*(LINLEN) IREC
      INTEGER       BLEN, IDET, IDOM, IERROR, IRESID, LENSTR, LINE,
     -              NDET, NDOM, NFRAG, RESDOM(NRESID)
      LOGICAL       CHECK, DONE, HAVDOM, HAVFIL, HAVREC, INRANG,
     -              SHWDET

C---- Initialise variables
      DONE = .FALSE.
      HAVFIL = .FALSE.
      HAVREC = .FALSE.
      LINE = 0
      BRCODE = BCODE
      BLEN = LENSTR(BCODE)
      IF (BLEN.GT.4) THEN
          BRCODE = BCODE(BLEN - 3:BLEN)
      ENDIF
      IF (BRCODE.EQ.'ALL ' .OR. BRCODE.EQ.'all ') THEN
          CHECK = .TRUE.
      ELSE
          CHECK = .FALSE.
      ENDIF

C---- Open the CATH domains file
      OPEN(UNIT=3, FILE=DOMFIL, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    IOSTAT=IERROR)
      IF (IERROR.EQ.0) HAVFIL = .TRUE.

C---- If the file not found, show warning message
      IF (.NOT.HAVFIL) THEN
          PRINT*, '*** Warning. CATH domains file not located'

C---- Otherwise, read through the file until the current structure and
C     chain are located
      ELSE

C----     Loop while reading through the domains file
 200      CONTINUE

C----         Read the next record and check whether it is the one
C             we want
              READ(3,220,END=1000) IREC
 220          FORMAT(A)
              LINE = LINE + 1
              INCHN = IREC(5:5)
              IF (INCHN.EQ.'0') INCHN = ' '
              HAVREC = .FALSE.
              IF (IREC(1:4).EQ.BRCODE .AND. INCHN.EQ.CHAIN) THEN
                  HAVREC = .TRUE.
              ENDIF

C----         If just checking all entries, then read this record
              IF (CHECK) HAVREC = .TRUE.

C----         If have the required domain details, then interpret
              IF (HAVREC) THEN

C----             Interpret the data in the line and return it in fixed
C                 format
                  CALL EXTDOM(IREC,LINLEN,DOMDET,MAXDET,NDET,NDOM,NFRAG,
     -                ERRMES,SHWDET)

C----             If have an error message, display it
                  IF (ERRMES.NE.' ') THEN
                      PRINT 240, LINE, IREC(1:6),
     -                    ERRMES(1:LENSTR(ERRMES))
 240                  FORMAT('*** ERROR in domains file at line ',I5,
     -                    ' for entry [',A6,']',/,
     -                    '***       ',A)

C----             Otherwise, if there is any domain information to be had,
C                 store it
                  ELSE IF (NDOM + NFRAG.GT.1) THEN

C----                 If showing details, then do so
                      IF (SHWDET) THEN
                          PRINT 260, IREC(1:6), NDOM, NFRAG, NDET
 260                      FORMAT('[',A6,']  Domains: ',I3,
     -                        ', Fragments: ',I3,', Details: ',I3)
                      ENDIF

C----                 If have domains, then set flag
                      IF (NDOM.GT.1) HAVDOM = .TRUE.

C----                 Loop through the domain details
                      DO 800, IDET = 1, NDET

C----                     If debugging, then print details extracted 
C                         from theline
                          IF (SHWDET) THEN
                              PRINT*, '   [', DOMDET(IDET), ']'
                          ENDIF

C----                     Proceed only if this is a domain segment
                          IF (DOMDET(IDET)(1:1).EQ.'D') THEN

C----                         Get the residue-range for this domain
C                             segment
                              RESID1 = DOMDET(IDET)(5:9)
                              RESID2 = DOMDET(IDET)(11:15)

C----                         Get the domain number
                              READ(DOMDET(IDET),280,IOSTAT=IERROR) IDOM
 280                          FORMAT(1X,I2)

C----                         Loop through all the residues to mark up
C                             all that are within this domain's range
                              INRANG = .FALSE.
                              DO 700, IRESID = 1, NRESID

C----                             Check if this is the first residue of the
C                                 range
                                  IF (RESSEQ(IRESID).EQ.RESID1) THEN
                                      INRANG = .TRUE.
                                  ENDIF

C----                             If this residue is within the boundaries of
C                                 the current domains, then update its domain
C                                 number
                                  IF (INRANG) THEN

C----                                 Check that not already marked
                                      IF (RESDOM(IRESID).NE.0) THEN
                                          PRINT 320, IREC(1:6), LINE,
     -                                        RESSEQ(IRESID), INCHN
 320                                      FORMAT('*** Warning. Entry [',
     -                                        A,'] line ',I5,' has res',
     -                                        'idue ',A,'(',A,') ',
     -                                        ') marked for 2 domains')
                              
C----                                 Otherwise, mark it
                                      ELSE
                                          RESDOM(IRESID) = IDOM
                                      ENDIF
                                  ENDIF

C----                             Check if this is the last residue of
C                                 the range
                                  IF (RESSEQ(IRESID).EQ.RESID2) THEN
                                      INRANG = .FALSE.
                                  ENDIF
 700                          CONTINUE
                          ENDIF
 800                  CONTINUE
                  ENDIF
              ENDIF

C----     Loop back for next record
          IF (.NOT.DONE) GO TO 200

C----     End of file reached
 1000     CONTINUE

C----     Close the file
          CLOSE(3)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE EXTDOM  -  Extract the domain data from the free-format line
C                        of the CATH domains file and store in a fixed-
C                        format array
C
C----------------------------------------------------------------------+---

      SUBROUTINE EXTDOM(IREC,LINLEN,DOMDET,MAXDET,NDET,NDOM,NFRAG,
     -    ERRMES,SHWDET)

      INTEGER       MXTOKL
      PARAMETER    (MXTOKL = 20)

      INTEGER       NXTDOM, NXTFRG, NXTSEG, NXTCH1, NXTRS1, NXTHY1,
     -              NXTCH2, NXTRS2, NXTHY2, DONSEG
      PARAMETER    (
     -              NXTDOM =  1,
     -              NXTFRG =  2,
     -              NXTSEG =  3,
     -              NXTCH1 =  4,
     -              NXTRS1 =  5,
     -              NXTHY1 =  6,
     -              NXTCH2 =  7,
     -              NXTRS2 =  8,
     -              NXTHY2 =  9,
     -              DONSEG = 10
     -             )

      INTEGER       LINLEN, MAXDET

      CHARACTER*1   CHAIN, IREC(LINLEN)
      CHARACTER*5   RESNUM
      CHARACTER*15  DOMDET(MAXDET)
      CHARACTER*(MXTOKL) TOKEN
      CHARACTER*80  ERRMES
      INTEGER       IDET, IDOM, IERROR, IFRAG, IPOS, ISEG, LENSTR, LPOS,
     -              NDET, NDOM, NFRAG, NSEG, LENTOK, SPOS, STATE
      LOGICAL       DONE, HAVHYP, NEXTF, SHWDET

C---- Initialise variables
      CHAIN = IREC(5)
      ERRMES = ' '
      IDET = 1
      IDOM = 1
      IFRAG = 1
      IPOS = 1
      LPOS = 7
      NDET = 0
      NDOM = 0
      NFRAG = 0
      STATE = NXTDOM
      LENTOK = 0
      TOKEN = ' '
      DONE = .FALSE.

C---- Loop through line, character by character, until end reached
 100  CONTINUE

C----     Get next token string
          SPOS = LPOS
          CALL GETTOK(IREC,LINLEN,LPOS,TOKEN,MXTOKL,LENTOK,DONE)

C----     If debugging entries in file, then print current token
          IF (SHWDET) THEN
              PRINT*, 'Token [', TOKEN(1:LENSTR(TOKEN)), ']', LENTOK
          ENDIF

C----     Process the token-string according to what it is

C----     If token is empty, then skip
          IF (LENTOK.EQ.0 .OR.
     -         (LENTOK.GT.1 .AND. TOKEN(1:1).EQ.'(')) THEN
              CONTINUE

C----     Number of domains
          ELSE IF (STATE.EQ.NXTDOM) THEN
        
C----         Get the number of domains
              IF (TOKEN(1:1).EQ.'D') THEN
            
C----             Extract the number
                  READ(TOKEN,120,IOSTAT=IERROR) NDOM
 120              FORMAT(1X,I2)
                  IF (IERROR.NE.0) THEN
                      ERRMES = 'Non-numeric no. of domains: [' //
     -                    TOKEN(1:3) // ']'
                      DONE = .TRUE.
                  ENDIF

C----         If have wrong token, then generate error message
              ELSE
                  ERRMES = 'Missing Dxx token. Instead have [' //
     -                TOKEN(1:LENSTR(TOKEN)) // ']'
                  DONE = .TRUE.
              ENDIF

C----         Switch state
              STATE = NXTFRG

C----     Number of fragments
          ELSE IF (STATE.EQ.NXTFRG) THEN
        
C----         Get the number of inter-domain fragments
              IF (TOKEN(1:1).EQ.'F') THEN
            
C----             Extract the number
                  READ(TOKEN,120,IOSTAT=IERROR) NFRAG
                  IF (IERROR.NE.0) THEN
                      ERRMES = 'Non-numeric no. of fragments: [' //
     -                    TOKEN(1:3) // ']'
                      DONE = .TRUE.
                  ENDIF

C----         If have wrong token, then generate error message
              ELSE
                  ERRMES = 'Missing Fxx token. Instead have [' //
     -                TOKEN(1:LENSTR(TOKEN)) // ']'
                      DONE = .TRUE.
              ENDIF

C----         Switch state
              STATE = NXTSEG

C----     Number of segments
          ELSE IF (STATE.EQ.NXTSEG) THEN
        
C----         Get the number of segments
              READ(TOKEN,140,IOSTAT=IERROR) NSEG
 140          FORMAT(I10)
              IF (IERROR.NE.0) THEN
                  ERRMES = 'Non-numeric no. of segments: [' //
     -                TOKEN(1:3) // ']'
                  DONE = .TRUE.
              ENDIF

C----         Increment details count
              NDET = NDET + 1

C----         Check that array bounds not exceeded
              IF (NDET.GT.MAXDET) THEN
                  WRITE(ERRMES,160) MAXDET
 160              FORMAT('Maximum number of domain details exceeded:',
     -                I6)
                  DONE = .TRUE.

C----         Otherwise, initialise the next details line
              ELSE
                  DOMDET(NDET) = ' '
                  WRITE(DOMDET(NDET),180) IDOM
 180              FORMAT('D',I2)
                  IPOS = 4
                  ISEG = 0
              ENDIF

C----         Switch state
              STATE = NXTCH1

C----     Chain identifier
          ELSE IF (STATE.EQ.NXTCH1 .OR. STATE.EQ.NXTCH2) THEN
        
C----         If too long to be a chain-id, then show error message
              IF (LENTOK.GT.1) THEN
                  ERRMES = 'Expected chain-id is too long: [' //
     -                TOKEN(1:LENSTR(TOKEN)) // ']'
                  DONE = .TRUE.

C----         Otherwise, store the chain-id
              ELSE
                  DOMDET(NDET)(IPOS:IPOS) = TOKEN(1:1)
                  IPOS = IPOS + 1

C----             Check whether the chain agrees with that at the start of
C                 the record
                  IF (TOKEN(1:1).NE.CHAIN) THEN
                      ERRMES = 'Chain mismatch [' // TOKEN(1:1) //
     -                    '] != [' // CHAIN // ']'
                      DONE = .TRUE.
                  ENDIF
              ENDIF

C----         Switch state
              IF (STATE.EQ.NXTCH1) THEN
                STATE = NXTRS1
              ELSE
                STATE = NXTRS2
              ENDIF

C----     Residue number
          ELSE IF (STATE.EQ.NXTRS1 .OR. STATE.EQ.NXTRS2) THEN
        
C----         Check whether have a hyphen on the end of the residue number
              IF (LENTOK.GT.1 .AND. TOKEN(LENTOK:LENTOK).EQ.'-') THEN
            
C----             Have hyphen, so strip it off
                  HAVHYP = .TRUE.
                  TOKEN(LENTOK:LENTOK) = ' '
                  LENTOK = LENTOK - 1
              ELSE
                  HAVHYP = .FALSE.
              ENDIF

C----         Format the residue number as a 5-character string
              CALL FORMRS(RESNUM,TOKEN,LENTOK)

C----         Store the residue number
              DOMDET(NDET)(IPOS:) = RESNUM
              IPOS = IPOS + 5

C----         Switch state
              IF (STATE.EQ.NXTRS1) THEN

C----              If already have hyphen, next token will be the second
C                  residue's chain
                   IF (HAVHYP) THEN
                       STATE = NXTCH2
                   ELSE
                       STATE = NXTHY1
                   ENDIF

C----         If have done second residue, then nearly at end of segment
              ELSE

C----             If already have hyphen, then segment is done
                  IF (HAVHYP) THEN
                      TOKEN = '-'
                      LENTOK = 1
                      STATE = DONSEG

C----             Otherwise, still need to read in the hyphen                
                  ELSE
                      STATE = NXTHY2
                  ENDIF
              ENDIF

C----     Hyphen between residues
          ELSE IF (STATE.EQ.NXTHY1) THEN

C----         Check that is really a hyphen, then switch state
              IF (TOKEN.EQ.'-') THEN
                  STATE = NXTCH2


C----         Otherwise, take this to be the insertion code
              ELSE IF (RESNUM(5:5).EQ.' ') THEN
                  DOMDET(NDET)(9:9) = TOKEN
                  STATE = NXTCH2

C----         Otherwise, give an error message
              ELSE
                  WRITE(ERRMES,220) RESNUM, TOKEN(1:LENSTR(TOKEN))
 220              FORMAT('Duplicate insertion code on 1st residue [',A,
     -                '] - [', A, ']')
                  DONE = .TRUE.
              ENDIF

C----     Hyphen after second residue
          ELSE IF (STATE.EQ.NXTHY2) THEN
        
C----         Check that is really a hyphen, then switch state
              IF (TOKEN.EQ.'-') THEN
                  STATE = DONSEG

C----         Otherwise, take this to be the insertion code
              ELSE IF (RESNUM(5:5).EQ.' ') THEN
                  DOMDET(NDET)(15:15) = TOKEN
                  STATE = DONSEG

C----         Otherwise, give an error message
              ELSE
                  WRITE(ERRMES,240) RESNUM, TOKEN(1:LENSTR(TOKEN))
 240              FORMAT('Duplicate insertion code on 2nd residue [',A,
     -                '] - [', A, ']')
                  DONE = .TRUE.
              ENDIF
         ENDIF

C----    If details complete, prepare for the next
         IF (STATE.EQ.DONSEG) THEN
        
C----        Check that length exactly 15 characters
             IF (IPOS.EQ.16) THEN

C----            Determine what's coming next

C----            Increment segment count
                 ISEG = ISEG + 1

C----            If have finished segments for this domain/fragment
C                then expect number of segments next
                 IF (ISEG.GE.NSEG) THEN
                
C----                Initialise flag
                     NEXTF = .FALSE.

C----                If domain just completed, the increment count
                     IF (DOMDET(NDET)(1:1).EQ.'D') THEN
                    
C----                    Increment domains count
                         IDOM = IDOM + 1

C----                    If all domains just done, next info will be
C                        about the fragments
                         IF (IDOM.GT.NDOM) THEN

C----                        Check that have fragment info
                             IF (IFRAG.LE.NFRAG) THEN
                                 NEXTF = .TRUE.

C----                        Otherwise, all is done
                             ELSE
                                 DONE = .TRUE.
                             ENDIF

C----                    Otherwise, expecting number of segments making
C                        up the domain next
                         ELSE
                             STATE = NXTSEG
                         ENDIF

C----                If domain just completed was a fragment, increment
C                    count
                     ELSE IF (DOMDET(NDET)(1:1).EQ.'F') THEN
                    
C----                    Increment fragment count and set flag
                         IFRAG = IFRAG + 1
                         NEXTF = .TRUE.

C----                    If all fragments done, then can stop here
                         IF (IFRAG.GT.NFRAG) THEN
                             DONE = .TRUE.
                             NEXTF = .FALSE.
                         ENDIF
                     ENDIF
                        
C----                For a fragment, initialise the details
                     IF (NEXTF) THEN
                    
C----                    Increment details count
                         NDET = NDET + 1

C----                    Start the next details line
                         IF (NDET.LT.MAXDET) THEN
                             DOMDET(NDET) = ' '
                             WRITE(DOMDET(NDET),280) IFRAG
 280                         FORMAT('F',I2)
                             IPOS = 4
                         ENDIF

C----                    Set state to look for a chain-id
                         STATE = NXTCH1
                         ISEG = 0
                     ENDIF

C----            Otherwise, expect chain-id of first residue next
                 ELSE
                
C----                Copy the domain details for next residue range
                     IF (NDET.LT.MAXDET) THEN
                         DOMDET(NDET + 1) = DOMDET(NDET)(1:3)
                         IPOS = 4
                     ENDIF

C----                Increment details count
                     NDET = NDET + 1

C----                Set state to look for chain-id
                     STATE = NXTCH1
                 ENDIF

C----            Show error if maximum number of details exceeded
                 IF (NDET.GT.MAXDET) THEN
                     WRITE(ERRMES,320) NDET
 320                 FORMAT('Maximum number of domain details ',
     -                   'exceeded ',I3)
                     DONE = .TRUE.
                 ENDIF
                
C----        Otherwise, give an error message
             ELSE
                 WRITE(ERRMES,340) TOKEN(1:LENSTR(TOKEN)), SPOS
 340             FORMAT('Domain details wrong length [',A,
     -               '] from pstn ',I3)
                 DONE = .TRUE.
             ENDIF
         ENDIF
    
C---- Loop back if line not completed
      IF (.NOT.DONE) GO TO 100
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETTOK  -  Get the next space-delimited token from the given
C                        input line, starting at the given position
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETTOK(IREC,LINLEN,IPOS,TOKEN,MXTOKL,LENTOK,DONE)

      INTEGER       LINLEN, MXTOKL

      CHARACTER*1   CH, IREC(LINLEN), TOKEN(MXTOKL)
      INTEGER       I, IPOS, LENTOK
      LOGICAL       DONE, HAVTOK

C---- Initialise variables
      DONE = .FALSE.
      HAVTOK = .FALSE.
      DO 50, I = 1, MXTOKL
          TOKEN(I) = ' '
 50   CONTINUE
      I = 0

C---- Loop until token-string found or end of line reached
 100  CONTINUE

C----     Get the next character in the string
          CH = IREC(IPOS)

C----     If have a space, then take to be the end of the token if
C         have already got something in it
          IF (CH.EQ.' ') THEN
        
C----         If have a token, then we are done
              IF (TOKEN(1).NE.' ') THEN
                  HAVTOK = .TRUE.
              ENDIF

C----     Otherwise, add character to token-string provided not too long
          ELSE
              IF (I.LE.MXTOKL) THEN
                  I = I + 1
                  TOKEN(I) = CH
              ENDIF
          ENDIF

C----     Go to the next character in the line
          IPOS = IPOS + 1
    
C---- Loop back for next character
      IF (.NOT.DONE .AND. .NOT.HAVTOK .AND. IPOS.LT.LINLEN) GO TO 100

C---- Terminate the token-string
      LENTOK = I
      IF (I.EQ.0 .OR. IPOS.GE.LINLEN) DONE = .TRUE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE FORMRS  -  Right-justify residue number, taking into
C                        account whether it includes an insertion code
C
C----------------------------------------------------------------------+---

      SUBROUTINE FORMRS(RESNUM,TOKEN,LENTOK)

      INTEGER       LENTOK

      CHARACTER*1   CH, TOKEN(LENTOK + 1)
      CHARACTER*5   RESNUM

      INTEGER       IPOS, JPOS, LEN, SPOS

C---- Initialise variables
      LEN = LENTOK
      RESNUM = ' '

C---- Proceed if have a token to process
      IF (LEN.GT.0) THEN
    
C----     If token is maximum length, then transfer as is
          IF (LEN.GE.5) THEN
        
C----         Set start-position at start of token
              SPOS = 0
              LEN = 5

C----     Otherwise, determine how number is to be transferred
          ELSE
        
C----         Check whether last character is a number or an insertion code
              CH = TOKEN(LEN)

C----         If it is a number, then add a space onto the end
              IF (LGE(CH,'0') .AND. LLE(CH,'9')) THEN

C----             Add space onto end of token and increase its length
                  LEN = LEN + 1
                  TOKEN(LEN) = ' '
              ENDIF

C----         Calculate start-position for transfer
              SPOS = 5 - LEN
          ENDIF

C----     Perform the transfer of the residue number to justify it as
C         required
          DO 100, IPOS = 1, LEN
              JPOS = SPOS + IPOS
              RESNUM(JPOS:JPOS) = TOKEN(IPOS)
 100      CONTINUE
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETSIT  -  Read in any SITE records from the original PDB file
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETSIT(CHAIN,PDBFIL,RESSEQ,RESNAM,RESCHN,
     -    RESITE,SITNAM,MXSITE,MXRES,NRESID,HAVSIT,NSITE,SUSED,NUSED,
     -    WFORM,CGIRUN)

      INTEGER       MXRES, MXSITE, NRESID

      CHARACTER*1   CHAIN, INCHN, RESCHN(NRESID)
      CHARACTER*3   LSNAME, RESDUE, RESNAM(NRESID), SITNAM(MXSITE),
     -              SNAME
      CHARACTER*5   RESNUM, RESSEQ(NRESID)
      CHARACTER*(*) PDBFIL
      CHARACTER*120 IREC
      INTEGER       IERROR, IPOS, IRESID, ISITE, LINE, LOOP, NSITE,
     -              NUSED, RESITE(2,MXRES)
      LOGICAL       CGIRUN, DEND, FOUND, HAVFIL, HAVSIT, SUSED(MXSITE),
     -              WANTED, WFORM

C---- Initialise flag indicating whether input file is present
      HAVSIT = .FALSE.
      HAVFIL = .FALSE.
      LINE = 0
      LOOP = 0
      LSNAME = '///'
      NSITE = 0
      NUSED = 0
      DO 50, ISITE = 1, MXSITE
          SUSED(ISITE) = .FALSE.
          SITNAM(ISITE) = ' '
 50   CONTINUE

C---- Open the PDB file
      OPEN(UNIT=2, FILE=PDBFIL, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    IOSTAT=IERROR)
      IF (IERROR.EQ.0) HAVFIL = .TRUE.

C---- If one of the required files exists, then pick up the data in it
      IF (HAVFIL) THEN

C----     Loop while reading through the file
          DEND = .FALSE.
 400      CONTINUE

C----         Read in the next record
              READ(2,420,END=700) IREC
 420          FORMAT(A)
              LINE = LINE + 1

C----         If this is a SITE record, then pick up the relevant residues
              IF (IREC(1:6).EQ.'SITE  ') THEN

C----             Check whether this is a new site
                  SNAME = IREC(12:14)
                  IF (SNAME.NE.LSNAME) THEN

C----                 Increment count of sites found
                      NSITE = NSITE + 1
                      IF (NSITE.GT.MXSITE) THEN
                          PRINT*, '*** Warning. Maximum number of SITE',
     -                        's exceeded, MXSITE', MXSITE
                          PRINT*, '***          Some SITE data lost'
                          NSITE = MXSITE
                      ENDIF

C----                 Store this site's identifier
                      SITNAM(NSITE) = SNAME
                      LSNAME = SNAME
                  ENDIF

C----             Initialise the record position for reading in the residues
C                 in this record
                  IPOS = 19

C----             Process each of the site residues in turn
                  DO 600, ISITE = 1, 4

C----                 Get the chain-ID, residue-name and number
                      RESDUE = IREC(IPOS:IPOS+2)
                      INCHN = IREC(IPOS+4:IPOS+4)
                      RESNUM = IREC(IPOS+5:IPOS+9)

C----                 If not blank, and the chain is the one we're
C                     after, then process
                      IF ((WFORM .OR. CGIRUN) .AND. INCHN.EQ.CHAIN) THEN
                          WANTED = .TRUE.
                      ELSE IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN
                          WANTED = .TRUE.
                      ELSE
                          WANTED = .FALSE.
                      ENDIF
                      IF (RESDUE.NE.' ' .AND. RESNUM.NE.' ' .AND.
     -                    WANTED) THEN

C----                     Search for the corresponding residue in the list
                          FOUND = .FALSE.
                          IRESID = 0
 500                      CONTINUE

C----                         Increment residue number and check whether
C                             this is the right one
                              IRESID = IRESID + 1
                              IF (RESCHN(IRESID).EQ.INCHN .AND.
     -                            RESSEQ(IRESID).EQ.RESNUM .AND.
     -                            RESNAM(IRESID).EQ.RESDUE) THEN
                                  FOUND = .TRUE.

C----                             Update this residue's site details
                                  IF (RESITE(1,IRESID).NE.0) THEN

C----                                 If already part of an active site,
C                                     then note this second site
                                      IF (RESITE(2,IRESID).EQ.0) THEN
                                          RESITE(2,IRESID) = NSITE
                                          SUSED(NSITE) = .TRUE.

C----                                 If it's already part of two active
C                                     sites, then print a warining message
                                      ELSE
                                          PRINT 510, '*** Warning. Res',
     -                                        'idue belongs to more th',
     -                                        'an two SITEs: [', RESDUE,
     -                                        RESNUM, INCHN,
     -                                        ']', RESITE(1,IRESID),
     -                                        RESITE(2,IRESID), ' of',
     -                                        NSITE
 510                                      FORMAT(7A,2I4,A,I4)
                                      ENDIF
                                  ELSE
                                      RESITE(1,IRESID) = NSITE
                                      SUSED(NSITE) = .TRUE.
                                  ENDIF
                              ENDIF

C----                     Loop back for next residue unless have found
C                         the one required
                          IF (.NOT.FOUND .AND. IRESID.LT.NRESID)
     -                        GO TO 500
                      ENDIF

C----                 Increment position for next residue
                      IPOS = IPOS + 11

 600              CONTINUE

C----         If this is an ATOM record, can end the read here
              ELSE IF (IREC(1:6).EQ.'ATOM  ') THEN
                  DEND = .TRUE.
              ENDIF
          IF (.NOT.DEND) GO TO 400

C----     Close the input file
 700      CONTINUE
          CLOSE(2)
      ENDIF

C---- Count the number of sites actually in the current chain
      DO 800, ISITE = 1, NSITE
          IF (SUSED(ISITE)) NUSED = NUSED + 1
 800  CONTINUE

C---- Set flag if have any SITE details
      IF (NUSED.GT.0) HAVSIT = .TRUE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETCON  -  Read in the H-bonds and non-bonded contacts
C                        analyses, generated by Duncan Milburn's GROW
C                        program, if present
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCON(BRCODE,CHAIN,PRODIR,RESSEQ,RESNAM,RESCHN,RESDNA,
     -    RESLIG,RESMET,NRESID,HAVCON,WFORM,CGIRUN)

      INTEGER       NRESID

      CHARACTER*1   CHAIN, INCHN, LSTCHN, OTHMOL, RESCHN(NRESID), TYPE
      CHARACTER*3   LSTRES, RESDUE, RESNAM(NRESID)
      CHARACTER*4   BRCODE
      CHARACTER*5   LSTNUM, RESNUM, RESSEQ(NRESID)
      CHARACTER*120 FILNAM, IREC, PRODIR
      INTEGER       IERROR, IRESID, LENSTR, LINE, NCON,
     -              NDNACN, NLIGCN, NMETCN, RESDNA(NRESID),
     -              RESLIG(NRESID), RESMET(NRESID)
      LOGICAL       CGIRUN, DEND, FOUND, HAVCON, HAVFIL, WANTED, WFORM

C---- Initialise flag indicating whether contacts file is present
      DEND = .FALSE.
      HAVCON = .FALSE.
      HAVFIL = .FALSE.
      LINE = 0
      LSTCHN = ' '
      LSTRES = '   '
      LSTNUM = '     '
      NCON = 0
      NDNACN = 0
      NLIGCN = 0
      NMETCN = 0

C---- Form this file's name in the WWW directory
      FILNAM = PRODIR(1:LENSTR(PRODIR)) // '/' // BRCODE //
     -    '/grow.out'

C---- Open the file
      OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    IOSTAT=IERROR)
      IF (IERROR.EQ.0) HAVFIL = .TRUE.

C---- If the file not found there, try the current directory
      IF (.NOT.HAVFIL) THEN

C----     Reform the filename
          FILNAM = 'grow.out'

C----     Try to open the file again
          OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -        ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -        IOSTAT=IERROR)
          IF (IERROR.EQ.0) HAVFIL = .TRUE.
      ENDIF

C---- If this contacts file exists, then pick up the data in it
      IF (HAVFIL) THEN

C----     Read through this file until hit the start of the data
 200      CONTINUE

C----         Read the next record and check whether it is the end
C             of the data
              READ(2,220,END=700) IREC
 220          FORMAT(A)
              LINE = LINE + 1

C----         Check whether this is the last line of the file
              IF (IREC(1:13).EQ.'# End of data') THEN
                  DEND = .TRUE.
                  IREC = 'X'
              ENDIF

C----         Process providing it is not a blank line or a comment line
              IF (IREC.NE.' ' .AND. IREC(1:1).NE.'#') THEN

C----             Get the chain-id and check whether it is the one we want
                  INCHN = IREC(7:7)
                  IF ((WFORM .OR. CGIRUN) .AND. INCHN.EQ.CHAIN) THEN
                      WANTED = .TRUE.
                  ELSE IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN
                      WANTED = .TRUE.
                  ELSE
                      WANTED = .FALSE.
                  ENDIF
                  IF (DEND) WANTED = .TRUE.

C----             If record is wanted, extract the required details
                  IF (WANTED) THEN

C----                 Get the residue details
                      IF (.NOT.DEND) THEN
                          READ(IREC,420,IOSTAT=IERROR) TYPE, OTHMOL,
     -                        RESNUM, RESDUE
 420                      FORMAT(A1,3X,A1,4X,A5,A3)
                      ENDIF

C----                 If new residue, or end, then update previous
C                     residue's contact details
                      IF ((INCHN.NE.LSTCHN .OR. RESNUM.NE.LSTNUM .OR.
     -                    RESDUE.NE.LSTRES .OR. DEND) .AND.
     -                    LSTRES.NE.'   ') THEN

C----                     Search for the corresponding residue in the list
                          FOUND = .FALSE.
                          IRESID = 0
 500                      CONTINUE

C----                         Increment residue number and check whether this
C                             is the right one
                              IRESID = IRESID + 1
                              IF (RESCHN(IRESID).EQ.LSTCHN .AND.
     -                            RESSEQ(IRESID).EQ.LSTNUM .AND.
     -                            RESNAM(IRESID).EQ.LSTRES) THEN
                                  FOUND = .TRUE.

C----                             Update this residue's contact details
                                  RESDNA(IRESID)
     -                                = RESDNA(IRESID) + NDNACN
                                  RESLIG(IRESID)
     -                                = RESLIG(IRESID) + NLIGCN
                                  RESMET(IRESID)
     -                                = RESMET(IRESID) + NMETCN

C----                             Update number of residues affected
                                  IF (NDNACN + NLIGCN + NMETCN.GT.0)
     -                                NCON = NCON + 1
                              ENDIF

C----                     Loop back for next residue unless have found the one
C                         required
                          IF (.NOT.FOUND .AND. IRESID.LT.NRESID)
     -                        GO TO 500

C----                     Zero the counts again
                          NDNACN = 0
                          NLIGCN = 0
                          NMETCN = 0
                      ENDIF

C----                 Store the current residue details
                      LSTCHN = INCHN
                      LSTRES = RESDUE
                      LSTNUM = RESNUM

C----                 Increment appropriate count according to the residue
C                     type
                      IF (TYPE.NE.'W') THEN
                          IF (OTHMOL.EQ.'N') THEN
                              NDNACN = NDNACN + 1
                          ELSE IF (OTHMOL.EQ.'L') THEN
                              NLIGCN = NLIGCN + 1
                          ELSE IF (OTHMOL.EQ.'M') THEN
                              NMETCN = NMETCN + 1
                          ENDIF
                      ENDIF
                  ENDIF

              ENDIF
          IF (.NOT.DEND) GO TO 200

C----     Close the contacts file
 700      CONTINUE
          CLOSE(2)
      ENDIF

C---- Set flag if have any contacts
      IF (NCON.GT.0) HAVCON = .TRUE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETINT  -  Read in any intron positions for this chain
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETINT(BRCODE,CHAIN,PRODIR,RESSEQ,RESNAM,RESINT,MXRES,
     -    NRESID,HAVINT,WFORM)

      INTEGER       MXRES, NRESID

      CHARACTER*1   CHAIN, LSTCHN
      CHARACTER*3   LSTRES, RESNAM(NRESID), RSNAME
      CHARACTER*4   BRCODE
      CHARACTER*5   LSTNUM, RESNUM, RESSEQ(NRESID)
      CHARACTER*120 ENDBIT, FILNAM, IREC, PRODIR
      INTEGER       IERROR, IPHASE, IRESID, LENSTR, LINE,
     -              NINTR
      LOGICAL       HAVINT, HAVFIL, RESINT(3,MXRES), WFORM

C---- Initialise flag indicating whether contacts file is present
      HAVINT = .FALSE.
      HAVFIL = .FALSE.
      LINE = 0
      LSTCHN = ' '
      LSTRES = '   '
      LSTNUM = '     '
      NINTR = 0

C---- Form this file's name in the WWW directory
      ENDBIT = 'introns_.dat'
      IF (CHAIN.NE.' ') THEN
          ENDBIT = 'introns_' // CHAIN // '.dat'
      ENDIF
      FILNAM = PRODIR(1:LENSTR(PRODIR)) // '/' // BRCODE // '/' //
     -    ENDBIT

C---- Open the file
      OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    IOSTAT=IERROR)
      IF (IERROR.EQ.0) HAVFIL = .TRUE.

C---- If the file not found there, try the current directory
      IF (.NOT.HAVFIL) THEN

C----     Reform the filename
          FILNAM = ENDBIT

C----     Try to open the file again
          OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -        ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -        IOSTAT=IERROR)
          IF (IERROR.EQ.0) HAVFIL = .TRUE.
      ENDIF

C---- If this contacts file exists, then pick up the data in it
      IF (HAVFIL) THEN

C----     Skip the first two lines
          READ(2,*,END=700)
          READ(2,*,END=700)

C----     Read through this file until hit the start of the data
 200      CONTINUE

C----         Read the next record and check whether it is the end
C             of the data
              READ(2,220,END=700) IREC
 220          FORMAT(A)
              LINE = LINE + 1

C----         If have hit first GenBank seq info record, then no more
C             intron data to be read
              IF (IREC(1:2).EQ.'GB') THEN
                  GO TO 700

C----         If this is an intron record, then extract the details
              ELSE

C----             Pick up the details
                  RSNAME = IREC(3:5)
                  RESNUM = IREC(6:10)
                  READ(IREC(1:1),240,ERR=300) IPHASE
 240              FORMAT(I1)

C----             Find the relevant residue and update
 300              CONTINUE
                  DO 400, IRESID = 1, NRESID

C----                 Check if we have a match
                      IF (RSNAME.EQ.RESNAM(IRESID) .AND.
     -                    RESNUM.EQ.RESSEQ(IRESID)) THEN

C----                     Update intron details
                          IF (IPHASE.GE.0 .AND. IPHASE.LT.3) THEN
                              RESINT(IPHASE + 1,IRESID) = .TRUE.
                          ENDIF

C----                     Increment count of found introns
                          NINTR = NINTR + 1

C----                     Jump out of loop
                          GO TO 500
                      ENDIF
 400              CONTINUE

C----             Residue found
 500              CONTINUE
              ENDIF

          GO TO 200

C----     Close the contacts file
 700      CONTINUE
          CLOSE(2)
      ENDIF

C---- Set flag if have any intron positions
      IF (NINTR.GT.0) HAVINT = .TRUE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLTSST  -  Work through the stored secondary structure data
C                        and plot wiring diagram
C
C----------------------------------------------------------------------+---

      SUBROUTINE PLTSST

      SAVE

      INCLUDE 'wirplot.inc'

      CHARACTER*1   BRKCH, INCHN, CHNEND, CIS, DAMINO, LSTBRK, LSTCHN,
     -              NXTBRK, NXTCHN, NXTSTR, PINCIS(MXPINS), SECSTR
      CHARACTER*2   PINCHN(MXPINS), PINSST(MXPINS)
      CHARACTER*3   PINRES(MXPINS), RESDUE
      CHARACTER*5   PINSNO(MXPINS), SEQNO
      INTEGER       BGAP, DOMAIN, ENDPIN, FGAP, FPIN, IGAP, IRESID,
     -              JRESID, LSTDOM, LSTPIN, NGAP, NPIN, ONPAGE,
     -              PINDOM(MXPINS), PINRNM(MXPINS), THEPIN
      LOGICAL       BRKPOS(MXPINS), HAVDNA, HAVLIG, HAVMET,
     -              PINDCH(MXPINS), PINOPE
      REAL          PINACC(MXPINS), VALUE, SCALEX, XLEFT, XRIGHT, Y,
     -              YBOT, YCUT, YPOS, YTOP

      DATA BGAP, FGAP / 2, 10 /

      DATA XLEFT, XRIGHT / 0.0, 485.0 /

C---- Initialise variables
      DO 50, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          PINDCH(NPIN) = .FALSE.
          PINDOM(NPIN) = 0
          PINRES(NPIN) = ' '
          PINRNM(NPIN) = 0
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          PINSNO(NPIN) = ' '
 50   CONTINUE
      ENDPIN = 0
      HAVDNA = .FALSE.
      HAVLIG = .FALSE.
      HAVMET = .FALSE.
      LSTDOM = 0
      PINOPE = .FALSE.
      IF (.NOT.SHOWRS) XRIGHT = XPWID + 20.0

C---- Initialise variables
      FPIN = 0
      NPIN = 0
      LSTPIN = 0
      ONPAGE = 0
      THEPIN = MXPINS
      IF (NRESID.LT.MXPINS .AND. NRESID.GT.2) THEPIN = NRESID
      THEPIN = NPINS

C---- Initialise chain-break identifiers
      LSTBRK = ' '
      LSTCHN = ' '
C      NXTCHN = RESCHN(1)
C      NXTSTR = RESSST(1)
C      OLDCHN = ' '

C---- Loop through all the stored residues
      DO 800, IRESID = 1, NRESID

C----     Retrieve the secondary structure code and other details
          BRKCH = RESBRK(IRESID)
          CIS = RESCIS(IRESID)
          DAMINO = RESDAM(IRESID)
          DOMAIN = RESDOM(IRESID)
          INCHN = RESCHN(IRESID)
          RESDUE = RESNAM(IRESID)
          SECSTR = RESSST(IRESID)
          SEQNO = RESSEQ(IRESID)
          VALUE = RESACC(IRESID)

C----     Increment the column position for the current line and
C         store this residue's details
          NPIN = NPIN + 1
          LSTPIN = NPIN
          PINACC(NPIN) = VALUE
          PINRES(NPIN) = RESDUE
          PINSST(NPIN) = SECSTR
          IF (CIS.EQ.'c' .AND. DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = 'X'
          ELSE IF (CIS.EQ.'c') THEN
              PINCIS(NPIN) = CIS
          ELSE IF (DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = DAMINO
          ENDIF
          PINCHN(NPIN) = INCHN
          PINDOM(NPIN) = DOMAIN
          PINRNM(NPIN) = IRESID
          PINSNO(NPIN) = SEQNO
          IF (DOMAIN.NE.LSTDOM) PINDCH(NPIN) = .TRUE.
          LSTDOM = DOMAIN
          IF (IRESID.EQ.NRESID) ENDPIN = NPIN

C----     Check whether this is the start of a new chain or chain-break
C         segment

C----     If first residue, then obviously a chain-start
          IF (IRESID.EQ.1) THEN
              CHNEND = '>'
              PINCHN(NPIN)(2:2) = CHNEND

C----     Otherwise, check whether previous residue belonged to a
C         different chain, or whether there was a chain-break there
          ELSE IF (INCHN.NE.LSTCHN .OR.
     -        (BRKCH.EQ.'!' .AND. LSTBRK.EQ.'!')) THEN
              CHNEND = '>'
              PINCHN(NPIN)(2:2) = CHNEND
          ENDIF

C----     Check whether there is a chain break after this residue

C----     If this is the last residue, then mark as a chain-end
          IF (IRESID.EQ.NRESID) THEN
              CHNEND = '<'
              PINCHN(NPIN)(2:2) = CHNEND
              NPIN = THEPIN

C----     Otherwise, check the next residue
          ELSE

C----         Get the details about the next residue
              JRESID = IRESID + 1
              NXTBRK = RESBRK(JRESID)
              NXTCHN = RESCHN(JRESID)
              NXTSTR = RESSST(JRESID)
              PINSST(NPIN)(2:2) = NXTSTR

C----         If the next residue is of a different chain, then force
C             a large gap
              NGAP = 0
              IF (NXTCHN.NE.INCHN) THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  NGAP = FGAP

C----         If just have a break in the same chain, then insert a short
C             gap
              ELSE IF (BRKCH.EQ.'!' .AND. NXTBRK.EQ.'!') THEN
                  NGAP = BGAP
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
              ENDIF

C----         Add the appropriate number of gaps, if required
              DO 300, IGAP = 1, NGAP

C----             Add blanks providing that haven't reached end of line
                  IF (NPIN.LT.THEPIN) THEN
                      NPIN = NPIN + 1
                      BRKPOS(NPIN) = .TRUE.
                  ENDIF
 300          CONTINUE
          ENDIF

C----     Store the current chain and chain-break indicator
          LSTCHN = INCHN
          LSTBRK = BRKCH

C----     If have a complete line, then plot it
          IF (NPIN.EQ.THEPIN) THEN

C----         If PostScript file not open, then open one
              IF (.NOT.PINOPE) THEN
                  CALL PSTART(YPOS)
                  PINOPE = .TRUE.

C----             If have domains, then draw corresponding key
                  IF (HAVDOM .AND. IPLOT.EQ.0) THEN
                      CALL SSDOM(XPORIG,YPTOP,NDOM)
                  ENDIF
              ENDIF

C----         If this is the only line for this structure, then can
C             draw in the disulphide bonds
              SHOWDS = .TRUE.

C----         Produce current secondary structure line
              CALL SECPLT(THEPIN,LSTPIN,FPIN,PINRES,PINSST,PINCHN,
     -            PINSNO,PINDOM,PINDCH,BRKPOS,PINACC,PINCIS,PINRNM,YTOP,
     -            YBOT,YPOS,SCALEX,ENDPIN,HAVDNA,HAVLIG,HAVMET)
              ONPAGE = ONPAGE + 1
              FPIN = FPIN + THEPIN
              NPIN = 0
              LSTPIN = NPIN

C----         Check whether end of current page reached
              IF (IRESID.EQ.NRESID .OR. ONPAGE.GE.NPPAGE .OR.
     -            YPOS.LT.100.0) THEN

C----             Join up all the disulphide bonds with dashed yellow
C                 lines, if required
                  IF (SHOWDS .AND. NCYS.GT.1) THEN
                      CALL JOINCS
                  ENDIF

C----             If this is the very last page, then plot the key
                  IF (IRESID.EQ.NRESID) THEN

C----                 Plot the active sites key, if required
                      IF (NUSED.GT.0 .OR. HAVCON) THEN
                          CALL SITKEY(XPORIG,YPOS,SCALEX,INCOLR,MXCOLR,
     -                        RGB,SITNAM,MXSITE,NSITE,SUSED,NUSED,
     -                        HAVDNA,HAVLIG,HAVMET)
                      ENDIF

C----                 Plot key for intron splice sites
                      IF (HAVINT) THEN
                          CALL INTKEY(XPORIG,YPOS,SCALEX,INCOLR,MXCOLR)
                      ENDIF

C----                 Plot the secondary structures key, if required
                      IF (SHOWKY) THEN
                          CALL SSKEY(XPORIG,YPOS,SCALEX,SHOWAC,SSSIZE,
     -                        INCOLR,MXCOLR,RGB,COLPLT(2),COLPLT(3),
     -                        COLPLT(4))
                      ENDIF
                  ENDIF

C----             Write out the CONVERT data (for converting
C                 to a gif file) and close it
                  Y = YTOP + 20.0
                  IF (USEPRM) Y = YTOP + 28.0
                  IF (HAVDOM) Y = YTOP + 38.0
                  YCUT = YPOS - 45.0
                  CALL CONVRT(XLEFT,XRIGHT,YCUT,Y)

C----             Close the current PostScript page and file
                  CALL PSENDP
                  IF (.NOT.CGIRUN) THEN
                      CALL PSCLOS(NINT(XLEFT),NINT(XRIGHT),NINT(YCUT),
     -                    NINT(Y))
                  ENDIF
                  PINOPE = .FALSE.
                  ONPAGE = 0
              ENDIF
          ENDIF
 800  CONTINUE

C---- If running inside a CGI script, then close PostScript file, if
C     it is open
      IF (CGIRUN .AND. IPLOT.GT.0) THEN
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PSTART  -  Create a new PostScript page
C
C----------------------------------------------------------------------+---

      SUBROUTINE PSTART(YPOS)

      SAVE

      INCLUDE 'wirplot.inc'

      CHARACTER*2   PAGENO
      CHARACTER*7   PAGE
      CHARACTER*9   PLHAND
      CHARACTER*30  PLDESC
      CHARACTER*20  BSTRNG
      CHARACTER*60  PTITLE
      INTEGER       ICYS, IPAGE, LENSTR
      LOGICAL       OPENEW, PLABEL, PLOTKY, WITHAN
      REAL          X, XCENTR, Y, YP, YPOS

C---- Initialise variables
      PLABEL = .FALSE.
      PLDESC = 'Secondary structure plot'
      PTITLE = PLDESC
      PLHAND = 'secstrplt'
      WITHAN = .FALSE.

C---- Determine whether a new PostScript file needs to be opened
      IF (CGIRUN) THEN

C----     Output file is called wirplot.ps
          FILPS = 'wirplot.ps'

C----     If this is the very first page, then need to open a new
C         wirplot.ps file
          IF (IPLOT.EQ.0) THEN
              OPENEW = .TRUE.
          ELSE
              OPENEW = .FALSE.
          ENDIF
      ELSE
          OPENEW = .TRUE.
      ENDIF

C---- Open new PostScript file
      IF (OPENEW) THEN
          IF (CGIRUN) THEN

C----         Increment page count
              IPLOT = IPLOT + 1
          ELSE
              CALL PSNAME(FILPS,FLEN,IPLOT,PLDESC,PLHAND,WITHAN)
          ENDIF
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR,PTITLE,PAGE)
      ELSE IF (CGIRUN) THEN
          IPLOT = IPLOT + 1
      ENDIF

C---- Open new page
      IPAGE = 1
      IF (CGIRUN) IPAGE = IPLOT
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,
     -    RGB,INCOLR,COLPLT(1),IPAGE,PLABEL,.FALSE.)
      PLOTKY = .FALSE.
      YPOS = YPTOP + YPDIFF
      IF (.NOT.SHOWRS) YPOS = YPOS - YPCOMP / 2.0

C---- Print the page number on the plot
      NPAGE = NPAGE + 1
      WRITE(PAGENO,'(I2)') NPAGE
      PAGE = 'Page ' // PAGENO
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

C---- Main graph heading
      IF (CGIRUN) THEN
          X = 530
          Y = 760
          IF (CHAIN.EQ.' ') THEN
              BSTRNG = BRCODE
          ELSE
              BSTRNG = BRCODE // '(' // CHAIN // ')'
          ENDIF
          CALL PSCTXT(X,Y,30.0,BSTRNG(1:LENSTR(BSTRNG)))
      ELSE IF (.NOT.WFORM) THEN
          XCENTR = XPORIG + XPWID / 2.0
          YP = YPOS
          CALL PSCTXT(XCENTR,YP - 24.0,25.0,
     -        'Secondary structure of ' // BRCODE)
      ENDIF
      CALL PSLWID(0.1)

C---- Initialise cysteine positions for joining pairs of Cys residues
C     making up disulphide bonds
      DO 200, ICYS = 1, MXCYS
          CYSPOS(1,ICYS) = 0.0
          CYSPOS(2,ICYS) = 0.0
          CYSNUM(ICYS) = ' '
          CYSUPD(ICYS) = ' '
 200  CONTINUE
      NCYS = 0

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SECPLT  -  Print current line of secondary structure
C                        information
C
C----------------------------------------------------------------------+---

      SUBROUTINE SECPLT(THEPIN,NPIN,FPIN,PINRES,PINSST,PINCHN,PINSNO,
     -    PINDOM,PINDCH,BRKPOS,PINACC,PINCIS,PINRNM,YTOP,Y,YPOS,SCALEX,
     -    ENDPIN,HAVDNA,HAVLIG,HAVMET)

      SAVE

      REAL          HPNWID
      PARAMETER    (HPNWID = 1.0)

      INCLUDE 'wirplot.inc'

      INTEGER       THEPIN

      CHARACTER*1   A, CONPLT(MXPINS), PINCIS(THEPIN), RCHAR, SECSTR
      CHARACTER*2   PINCHN(THEPIN), PINSST(THEPIN)
      CHARACTER*3   CODE(20), CYSPLT(MXPINS), PINRES(THEPIN)
      CHARACTER*5   PINSNO(THEPIN), RESID1, RESID2, TICLAB(MXPINS)
      CHARACTER*6   CNUMB
      CHARACTER*10  CNAME
      CHARACTER*20  AMINO
      CHARACTER*26  LOWER
      INTEGER       COLCON, COLHB, COLOUR, DOMAIN, ENDPIN, FPIN, ICODE,
     -              ICYS, IDATA, IERROR, IPHASE, IPIN, IPOS, IRESID,
     -              IRGRAF, ISWAP, LASITE, LENSTR, N, NCYSLN, NEVEN,
     -              NPIN, PINDOM(THEPIN), PINRNM(THEPIN),
     -              SITPLT(2,MXPINS), TICLEN(MXPINS)
      LOGICAL       BRKPOS(MXPINS), CONTS, HAVDNA, HAVLIG, HAVMET,
     -              HAVE1, HAVE2, INRANG, INTPLT(3,MXPINS), INTRNS,
     -              TICPOS(MXPINS), PINDCH(THEPIN), PLOTKY, SITES,
     -              THREE, UPUSED
      REAL          CDIFF, COLHEL(3), COLSTR(3), COLTRN(3), DCOL1,
     -              DCOL2, DCOL3, DIFFY, EXTRA, FRAC, PINACC(THEPIN),
     -              R, RADIUS, SCALEX, SHADE, SIZLAB, STSIZE, X, X1,
     -              X2, X3, XCENTR, Y, Y1, Y2, YP, YPOS, YSAVE, YTOP

      DATA  A      / 'A' /
      DATA  AMINO  / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  COLCON / 5 /
      DATA  COLHB  / 3 /
      DATA  COLHEL / 0.000, 0.000, 1.000 /
      DATA  COLSTR / 1.000, 0.000, 0.000 /
      DATA  COLTRN / 0.700, 0.200, 1.000 /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /

C---- Initialise variables
      DO 100, IPIN = 1, NPIN
          CONPLT(IPIN) = ' '
          CYSPLT(IPIN) = ' '
          SITPLT(1,IPIN) = 0
          SITPLT(2,IPIN) = 0
 100  CONTINUE
      XCENTR = XPORIG + XPWID / 2.0
      YP = YPOS
      YTOP = YPTOP + 2.0 * SSSIZE
      CONTS = .FALSE.
      INTRNS = .FALSE.
      NEVEN = 0
      SCALEX = XPWID / THEPIN
      SITES = .FALSE.
      CYSRAD = SCALEX / 2.0
      RADIUS = SCALEX / 6.6
      IF (WFORM .OR. CGIRUN) THEN
          SIZLAB = SIZLBW
          STSIZE = STSIZW
      ELSE
          SIZLAB = SIZLB
          STSIZE = STSIZ
      ENDIF

C---- Print the "wiring diagram" showing the secondary structure, with
C     background shading giving a measure of the accessibility
      IRGRAF = IRGRAF + 1
      YPOS = YPOS - YPDIFF
      IF (.NOT.SHOWRS) YPOS = YPOS + YPCOMP
      Y = YPOS

C---- Shade in the estimated accessibilities
      IF (SHOWAC) THEN
          CALL ACCSHD(THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
     -        SSSIZE,INCOLR,MXCOLR,RGB,COLPLT(4),COLPLT(3))
      ENDIF

C---- Plot the secondary structure
      CALL PSLWID(0.0)
      CALL SSDRAW(THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRESID,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLPLT(2),
     -    COLPLT(3),COLPLT(4),PLOTKY)

C---- Save the y-position
      YSAVE = Y
      CDIFF = 0.0
      NCYSLN = 0

C---- If using PROMOTIF data, then mark this residue accordingly
      IF (USEPRM) THEN
          Y = YSAVE + 12.0

C----     Loop through all the residues on this line
          DO 600, IPIN = 1, NPIN
              X = XPORIG + (IPIN - 1) * SCALEX
              CYSPLT(IPIN) = ' '
              UPUSED = .FALSE.

C----         Loop through all the PROMOTIF data items
              DO 500, IDATA = 1, NDATA

C----             Check for helix- or strand-start
                  IF ((DTYPE(IDATA).EQ.'hlx' .OR. DTYPE(IDATA).EQ.'str')
     -                .AND. RANGE(1,IDATA).EQ.PINSNO(IPIN)) THEN

C----                 Increment appropriate count
                      IF (DTYPE(IDATA).EQ.'hlx') THEN
                          SECSTR = 'H'
                          NHELIX = NHELIX + 1
                          WRITE(CNUMB,20) NHELIX
 20                       FORMAT(I6)

C----                     Write the helix number above start
                          IPOS = 1
                          IF (CNUMB(1:1).EQ.' ') IPOS = 2
                          IF (CNUMB(2:2).EQ.' ') IPOS = 3
                          IF (CNUMB(3:3).EQ.' ') IPOS = 4
                          IF (CNUMB(4:4).EQ.' ') IPOS = 5
                          IF (CNUMB(5:5).EQ.' ') IPOS = 6
                          IF (.NOT.NOLABL) THEN
                              CALL PSCOLB(COLHEL(1),COLHEL(2),COLHEL(3))
                              CALL PSTEXT(X,Y,STSIZE,
     -                            SECSTR // CNUMB(IPOS:))
                              CALL PSCOLB(0.0,0.0,0.0)
                          ENDIF
                      ELSE
                          NSTRND = NSTRND + 1
                          SECSTR = DATINF(IDATA)
                          IF (.NOT.NOLABL) THEN
                              CALL PSCOLB(COLSTR(1),COLSTR(2),COLSTR(3))
                              CALL PSTEXT(X,Y - 2.0,STSIZE,SECSTR)
                              CALL PSCOLB(0.0,0.0,0.0)
                          ENDIF
                      ENDIF
                  ENDIF

C----             Check for beta- or gamma turn
                  IF ((DTYPE(IDATA).EQ.'btn' .OR. DTYPE(IDATA).EQ.'gtn')
     -                .AND. RANGE(1,IDATA).EQ.PINSNO(IPIN)) THEN

C----                 Show appropriate symbol
                      DIFFY = 0.0
                      IF (DTYPE(IDATA).EQ.'btn') THEN
                          SECSTR = 'b'
                      ELSE IF (DTYPE(IDATA).EQ.'gtn') THEN
                          SECSTR = 'g'
                          DIFFY = 2.0
                      ENDIF
                      
C----                 Write the turn type
                      CALL PSSAVE
                      CALL PSCOLB(COLTRN(1),COLTRN(2),COLTRN(3))
                      IF (.NOT.UPUSED) THEN
                          CALL PSTXTG(X,Y - 5.5 + DIFFY,STSIZE,SECSTR)
                          UPUSED = .TRUE.
                      ELSE
                          CALL PSTXTG(X,Y - 19.0 + DIFFY,STSIZE,SECSTR)
                      ENDIF
                      CALL PSREST
                  ENDIF

C----             Check for beta hairpin
                  IF (DTYPE(IDATA).EQ.'hpn') THEN

C----                 Store the residue range
                      RESID1 = RANGE(1,IDATA)
                      RESID2 = RANGE(2,IDATA)

C----                 If this is the final residue in the hairpin,
C                     close the pin
                      IF (RESID2.EQ.PINSNO(IPIN)) THEN
                          CALL PSSAVE
                          CALL PSLWID(HPNWID)
                          CALL PSCOLB(1.0,0.0,0.0)
                          CALL PSLINE(X,Y - 16.0,
     -                        X + SCALEX / 2.0,Y - 16.0)
                          CALL PSLINE(X,Y - 22.0,
     -                        X + SCALEX / 2.0,Y - 22.0)
                          CALL PSARC(X + SCALEX / 2.0,Y - 19.0,3.0,
     -                        -90.0,90.0)
                          CALL PSREST

C----                 Otherwise, check whether this residue falls within
C                     the range defining the hairpin
                      ELSE

C----                     Set the in-range flag
                          INRANG = .FALSE.

C----                     If this is the first residue of the hairpin,
C                         then is obviously in range
                          IF (RESID1.EQ.PINSNO(IPIN)) THEN
                              INRANG = .TRUE.

C----                     Otherwise search through all residues to
C                         identify start and end and whether this
C                         residue lies between them
                          ELSE

C----                         Initialise match-flags
                              HAVE1 = .FALSE.
                              HAVE2 = .FALSE.

C----                         Perform the search
                              DO 200, IRESID = 1, NRESID

C----                             Skip if have hit end already
                                  IF (.NOT.HAVE2) THEN
                                      IF (RESSEQ(IRESID).EQ.RESID1)
     -                                    HAVE1 = .TRUE.
                                      IF (RESSEQ(IRESID).EQ.RESID2)
     -                                    HAVE2 = .TRUE.
                                      IF (HAVE1 .AND.
     -                                    RESSEQ(IRESID).EQ.
     -                                    PINSNO(IPIN))
     -                                    INRANG = .TRUE.
                                  ENDIF
 200                          CONTINUE
                          ENDIF

C----                     If residue is in range, plot the hairpin
C                         symbol
                          IF (INRANG) THEN

C----                         Plot the symbol as two parallel lines
                              CALL PSSAVE
                              CALL PSLWID(HPNWID)
                              CALL PSCOLB(1.0,0.0,0.0)
                              CALL PSLINE(X,Y - 16.0,
     -                            X + SCALEX,Y - 16.0)
                              CALL PSLINE(X,Y - 22.0,
     -                            X + SCALEX,Y - 22.0)
                              CALL PSREST
                          ENDIF
                      ENDIF
                  ENDIF

C----             Check for disulphide bridge
                  IF (DTYPE(IDATA).EQ.'dsf' .AND.
     -                (RANGE(1,IDATA).EQ.PINSNO(IPIN) .OR.
     -                 RANGE(2,IDATA).EQ.PINSNO(IPIN))) THEN

C----                 Store the disulphide identifier
                      CYSPLT(IPIN) = DATINF(IDATA)
                      NCYSLN = NCYSLN + 1
                  ENDIF
 500          CONTINUE
 600      CONTINUE
      ENDIF

C---- Mark any residues that are part of an active site
      IF (HAVSIT) THEN
          DO 700, IPIN = 1, NPIN
              SITPLT(1,IPIN) = 0
              SITPLT(2,IPIN) = 0

C----         Get the residue at this position
              IRESID = PINRNM(IPIN)

C----         Check this is a valid residue
              IF (IRESID.GT.0) THEN

C----             Loop over the two possible site indicators
                  DO 650, IPOS = 1, 2

C----                 Get which site this residue belongs to
                      IF (RESITE(IPOS,IRESID).GT.0) THEN
                          SITES = .TRUE.

C----                     Store this site number
                          SITPLT(IPOS,IPIN) = RESITE(IPOS,IRESID)
                      ENDIF
 650              CONTINUE
              ENDIF
 700      CONTINUE
      ENDIF

C---- Mark any ligand contacts on this line
      IF (HAVCON) THEN
          DO 800, IPIN = 1, NPIN
              CONPLT(IPIN) = ' '

C----         Get the residue at this position
              IRESID = PINRNM(IPIN)

C----         Check this is a valid residue
              IF (IRESID.GT.0) THEN

C----             Get numbers of H-bonds and contacts
                  IF (RESMET(IRESID).GT.0) THEN
                      CONPLT(IPIN) = 'M'
                      HAVMET = .TRUE.
                  ELSE IF (RESLIG(IRESID).GT.0) THEN
                      CONPLT(IPIN) = 'L'
                      HAVLIG = .TRUE.
                  ELSE IF (RESDNA(IRESID).GT.0) THEN
                      CONPLT(IPIN) = 'D'
                      HAVDNA = .TRUE.
                  ENDIF

C----             If residue involved in contacts, then set flag
                  IF (CONPLT(IPIN).NE.' ') THEN
                      CONTS = .TRUE.
                  ENDIF
              ENDIF
 800      CONTINUE
      ENDIF

C---- Mark any intron splice sites on this line
      IF (HAVINT) THEN
          DO 1000, IPIN = 1, NPIN
              INTPLT(1,IPIN) = .FALSE.
              INTPLT(2,IPIN) = .FALSE.
              INTPLT(3,IPIN) = .FALSE.

C----         Get the residue at this position
              IRESID = PINRNM(IPIN)

C----         Check this is a valid residue
              IF (IRESID.GT.0) THEN

C----             Store the intron splice-type
                  DO 900, IPHASE = 1, 3
                      INTPLT(IPHASE,IPIN) = RESINT(IPHASE,IRESID)
                      IF (RESINT(IPHASE,IRESID)) THEN
                          INTRNS = .TRUE.
                      ENDIF
 900              CONTINUE
              ENDIF
 1000     CONTINUE
      ENDIF

C---- Plot the disulphide markers, if required
      IF (SHOWDS) THEN

C----     Loop through again to plot any disulphides
          DO 1200, IPIN = 1, NPIN
              X = XPORIG + (IPIN - 0.5) * SCALEX

C----         If have a disulphide at this position, plot marker
              IF (CYSPLT(IPIN).NE.' ') THEN

C----             Increment count of stored Cys residues
                  NCYS = NCYS + 1
                  IF (NCYS.GT.MXCYS) THEN
                      PRINT*, '*** Warning. Maximum number of stored c',
     -                    'ysteines for disulphide links exceeded, MXC',
     -                    'YS:', MXCYS
                      PRINT*, '             Some disulphide links lost'
                      NCYS = MXCYS
                  ENDIF

C----             Draw a yellow circle representing this end of the
C                 bridge
                  Y = YPOS + 3.0
                  CYSUPD(NCYS) = 'U'

C----             If this is an even-numbered disulphide, then show below
C                 central line
                  IF (CYSPLT(IPIN).NE.'X  ') THEN

C----                 Read the disulphide number
                      ICYS = 0
                      IERROR = 0
                      IF (CYSPLT(IPIN)(2:2).EQ.' ') THEN
                          READ(CYSPLT(IPIN),1120,IOSTAT=IERROR) ICYS
 1120                     FORMAT(I1)
                      ELSE
                          READ(CYSPLT(IPIN),1140,IOSTAT=IERROR) ICYS
 1140                     FORMAT(I2)
                      ENDIF

C----                 If this is a valid number, check whether it is 
C                     an even one
                      IF (IERROR.EQ.0 .AND. ICYS.GT.0) THEN
                          IF (MOD(ICYS,2).EQ.0) THEN
                              Y = YPOS - 3.0
                              CYSUPD(NCYS) = 'D'
                              NEVEN = NEVEN + 1
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL PSCCOL(1.0,1.0,0.0)
                  CALL PSCIRC(X,Y,CYSRAD)

C----             Plot the disulphide ID inside the circle
                  CALL PSCTXT(X,Y,TSIZE / 2.0,
     -                CYSPLT(IPIN)(1:LENSTR(CYSPLT(IPIN))))

C----             Store this cysteine's PostScript coordinates
                  CYSPOS(1,NCYS) = X
                  CYSPOS(2,NCYS) = Y
                  CYSNUM(NCYS) = CYSPLT(IPIN)
              ENDIF
 1200     CONTINUE

C----     Restore the lowest y-value of this plot
          Y = YSAVE
      ENDIF

C---- Adjust y-drop depending on number of below-line Cys bonds that are
C     likely to be required
      CDIFF = CDIFF + 3.0
      NEVEN = NEVEN / 2
      IF (NEVEN.GT.1) CDIFF = CDIFF + (NEVEN - 1) * 4.0

C---- If there are any contact markers, active site residues, or intron
C     splice positions, then plot these
      IF (CONTS .OR. SITES .OR. INTRNS) THEN

C----     Get the y-position for the site markers
          Y = YSAVE - SEQRMY - CDIFF
          IF (INTRNS) THEN
              Y = Y - 3.0
          ELSE IF (.NOT.SITES) THEN
              Y = Y + 6.0
          ENDIF
          LASITE = 0

C----     Loop over all the positions in the current line
          DO 1500, IPIN = 1, NPIN

C----         Set the x-position for this residue
              X = XPORIG + (REAL(IPIN) - 0.5) * SCALEX

C----         If this is an active site residue, then plot appropriate
C             symbol
              IF (SITPLT(1,IPIN).GT.0) THEN

C----             Calculate coordinates of marker
                  X1 = X - SCALEX / 2.0
                  X2 = X + SCALEX / 2.0
                  Y2 = Y + 6.0
                  Y1 = Y2 - SQRT(3.0) * SCALEX / 2.0
                  X3 = X2

C----             If this residue is part of two sites, then plot
C                 left-half of marker only
                  IF (SITPLT(2,IPIN).GT.0) THEN
                      X3 = X

C----                 Try to set the left-hand one to correspond to the
C                     last site we had
                      IF (SITPLT(2,IPIN).EQ.LASITE) THEN
                          ISWAP = SITPLT(2,IPIN)
                          SITPLT(2,IPIN) = SITPLT(1,IPIN)
                          SITPLT(1,IPIN) = ISWAP
                      ENDIF
                  ENDIF

C----             Set appropriate colour
                  CALL SITCOL(SITPLT(1,IPIN),COLOUR,CNAME)
                  CALL PSHADE(0.0,COLOUR,RGB,MXCOLR,.TRUE.)
                  LASITE = SITPLT(1,IPIN)

C----             Plot the marker
                  CALL PSTRIA(X1,Y2,X,Y1,X3,Y2)

C----             If this residue is part of two sites, then plot
C                 the other half of the marker
                  IF (SITPLT(2,IPIN).GT.0) THEN

C----                 Set appropriate colour
                      CALL SITCOL(SITPLT(2,IPIN),COLOUR,CNAME)
                      CALL PSHADE(0.0,COLOUR,RGB,MXCOLR,.TRUE.)
                      LASITE = SITPLT(2,IPIN)

C----                 Plot the marker
                      CALL PSTRIA(X3,Y2,X,Y1,X2,Y2)
                  ENDIF
              ENDIF

C----         Loop over the three possible intron phases
              DO 1400, IPHASE = 1, 3

C----             If residue is at an intron splice-site, plot the
C                 scissors of the appropriate colour
                  IF (INTPLT(IPHASE,IPIN)) THEN

C----                 Set colour of scissors according to the intron phase
                      IF (IPHASE.EQ.1) THEN
                          COLOUR = 3
                          SHADE = 0.2
                      ELSE IF (IPHASE.EQ.2) THEN
                          COLOUR = 9
                          SHADE = 0.4
                      ELSE
                          COLOUR = 5
                          SHADE = 0.8
                      ENDIF

C----                 Show intron marker according to its phase
                      FRAC = REAL(IPHASE - 1) / 3.0
                      X1 = X + (FRAC - 0.5) * SCALEX - 8.0

C----                 Calculate y-position for the marker
                      Y1 = Y + 13.0 - SQRT(3.0) * SCALEX / 5.0

C----                 Plot the marker
                      CALL PSCISS(X1,Y1,SHADE,COLOUR,INCOLR)
                  ENDIF
 1400         CONTINUE

C----         If residue involved in contacts, then plot appropriate
C             symbol
              IF (CONPLT(IPIN).NE.' ') THEN

C----             Set colour of marker according to the contact type
                  IF (CONPLT(IPIN).EQ.'D') THEN
                      CALL PSCCOL(0.7,0.2,1.0)
                  ELSE IF (CONPLT(IPIN).EQ.'L') THEN
                      CALL PSCCOL(1.0,0.0,0.0)
                  ELSE IF (CONPLT(IPIN).EQ.'M') THEN
                      CALL PSCCOL(0.0,0.0,1.0)
                  ENDIF

C----             Calculate y-position for the marker
                  Y1 = Y + 0.5 - SQRT(3.0) * SCALEX / 5.0
                  R = RADIUS
C                  IF (SITPLT(1,IPIN).GT.0) R = 0.8 * R

C----             Plot the marker
                  CALL PSUCIR(X,Y1,R)
              ENDIF
 1500     CONTINUE
      ENDIF

C---- Adjust the y-value, if necessary
      IF (INTRNS) THEN
          IF (CONTS) THEN
              CDIFF = CDIFF + 12.0
          ELSE
              CDIFF = CDIFF + 10.0
          ENDIF
      ELSE
          IF (SITES .AND. CONTS) THEN
              CDIFF = CDIFF + 9.0
          ELSE IF (SITES) THEN
              CDIFF = CDIFF + 6.0
          ELSE IF (CONTS) THEN
              CDIFF = CDIFF + 3.0
          ENDIF
      ENDIF

C---- Print the residue codes
      IF (SHOWRS) THEN
          IRGRAF = IRGRAF + 1
          Y = YSAVE - SEQRMY - CDIFF
          THREE = .FALSE.
          DO 2000, IPIN = 1, NPIN
              X = XPORIG + (IPIN - 0.5) * SCALEX

C----         If residue belongs to a domain, then set the appropriate
C             colour
              IF (PINDOM(IPIN).GT.0) THEN
                  DOMAIN = PINDOM(IPIN)
                  CALL DOMCOL(DOMAIN,DCOL1,DCOL2,DCOL3)
                  CALL PSCOLB(DCOL1,DCOL2,DCOL3)
              ENDIF

C----         Find single-letter code for this residue
              ICODE = 0
              DO 1700, N = 1, 20
                  IF (PINRES(IPIN).EQ.CODE(N)) THEN
                      ICODE = N
                      GO TO 1800
                  ENDIF
 1700         CONTINUE

C----         If not one of the standard 20, then print full 3-letter code
 1800         CONTINUE
              IF (ICODE.EQ.0) THEN
                  CALL PSCTXT(X,Y,STSIZE,PINRES(IPIN)(1:1))
                  RCHAR = PINRES(IPIN)(2:2)
                  N = ICHAR(RCHAR) - ICHAR(A) + 1
                  IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
                  CALL PSCTXT(X,Y - 6.0,STSIZE,RCHAR)
                  RCHAR = PINRES(IPIN)(3:3)
                  N = ICHAR(RCHAR) - ICHAR(A) + 1
                  IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
                  CALL PSCTXT(X,Y - 12.0,STSIZE,RCHAR)
                  THREE = .TRUE.

C----         Otherwise, print the single-letter code
              ELSE
                  RCHAR = AMINO(ICODE:ICODE)
                  CALL PSCTXT(X,Y,STSIZE,RCHAR)
              ENDIF

C----         Reset text colour to black
              IF (PINDOM(IPIN).GT.0) THEN
                  CALL PSCOLB(0.0,0.0,0.0)
              ENDIF

C----         If domain has changed, plot a dotted line
              IF (PINDCH(IPIN)) THEN
                  X = XPORIG + (IPIN - 1) * SCALEX
                  CALL PSDASH(2)
                  CALL PSLINE(X,YSAVE - 25.0,X,YSAVE + 19.0)
                  CALL PSDASH(0)
              ENDIF
              IF (IPIN.EQ.ENDPIN .AND. HAVDOM) THEN
                  X = XPORIG + IPIN * SCALEX
                  CALL PSDASH(2)
                  CALL PSLINE(X,YSAVE - 25.0,X,YSAVE + 19.0)
                  CALL PSDASH(0)
              ENDIF
 2000     CONTINUE

C----     Print the residue numbers along the x-axis
          IF (THREE) THEN
              Y = Y - 16.0
              EXTRA = 8.0
          ELSE
              Y = Y - 8.0
              EXTRA = 0.0
          ENDIF
          YSAVE = Y

C----     Print horizontal line and residue numbers
          CALL PINTIC(XPORIG,Y,0.0,XPWID,NPINS,NPIN,-2.0,TICPOS,BRKPOS,
     -        .FALSE.)
          CALL PINRNO(XPORIG,XPORIG + XPWID,Y,PINSNO,NPINS,NPIN,FPIN,
     -        TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)
      ENDIF

C---- Re-initalise arrays
      DO 2200, NPIN = 1, NPINS
          BRKPOS(NPIN) = .FALSE.
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          PINDCH(NPIN) = .FALSE.
          PINDOM(NPIN) = 0
          PINRES(NPIN) = ' '
          PINRNM(NPIN) = 0
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          PINSNO(NPIN) = ' '
 2200 CONTINUE
      YPOS = YPOS - CDIFF - EXTRA

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE ACCSHD  -  Shade in the background of the secondary
C                        structure "wiring diagram" to give an indication
C                        of the relative accessibility
C
C----------------------------------------------------------------------+---

      SUBROUTINE ACCSHD(THEPIN,NPIN,PINACC,PINSST,XP,YP,DX,SSSIZE,
     -    INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)

      SAVE

      INTEGER       MXCOLR, NPIN, THEPIN
      CHARACTER*1   SECSTR
      CHARACTER*2   PINSST(THEPIN)
      INTEGER       IPIN, MAXCOL, MINCOL
      LOGICAL       BLANK, INCOLR
      REAL          DX, HEIGHT, PINACC(THEPIN), RGB(3,MXCOLR), SHADE,
     -              SSSIZE, X, XP, X1, X2, Y, YP, Y1, Y2

C---- Initialise values
      HEIGHT = SSSIZE * 3.0
      X = XP
      Y = YP

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)(1:1)
          IF (SECSTR.EQ.'=') THEN
              BLANK = .TRUE.
          ELSE
              BLANK = .FALSE.
          ENDIF

C----     If not off the end of a chain, draw a shaded patch according to
C         the accessibility
          IF (.NOT.BLANK) THEN
              X1 = X
              X2 = X + DX
              Y1 = Y - HEIGHT
              Y2 = Y + HEIGHT
              SHADE = PINACC(IPIN) / 100.0
              CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          ENDIF

C----     Increment x-position
          X = X + DX
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SSDRAW  -  Draw the secondary structure "wiring diagram"
C
C----------------------------------------------------------------------+---

      SUBROUTINE SSDRAW(THEPIN,NPIN,PINSST,XP,YP,DX,NRESID,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLOUR,MINACC,MAXACC,PLOTKY)

      SAVE

      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

      REAL          ARRWID, COIWID, THICK, THIN
      PARAMETER    (
     -              ARRWID = 1.8,
     -              COIWID = 0.25,
     -              THICK  = 0.4,
     -              THIN   = 0.2
     -             )

      INTEGER       MXCOLR, NPIN, THEPIN
      CHARACTER*1   NXTSTR, SECSTR
      CHARACTER*2   PINCHN(THEPIN), PINSST(THEPIN)
      INTEGER       COLOUR, FIRSTH, ISTRUC, IPIN, IRES, LENRUN, LSTRUC,
     -              MAXACC, MINACC, NRESID
      LOGICAL       INCOLR, SHOWAC, PLOTKY
      REAL          DX, HEIGHT, HWIDTH, RGB(3,MXCOLR), SSSIZE, X, XP,
     -              X1, X2, Y, YP, Y1, Y2

      DATA IRES,LSTRUC   / 0, 0 /

C---- Initialise values
      HEIGHT = SSSIZE * 1.8
      HWIDTH = SSSIZE * 1.8
      X = XP
      Y = YP
      LENRUN = 0
      CALL PSLWID(THIN)

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     If this is the start of a chain, draw chain-start
          IF (PINCHN(IPIN)(2:2).EQ.'>' .AND.
     -        PINCHN(IPIN)(1:1).NE.' ') THEN
              CALL PSLINE(X,Y - SSSIZE * 0.6,X,Y + SSSIZE * 0.6)

C----         Print the chain identifier
C              CALL PSTEXT(X - 10.0,Y,10.0,PINCHN(IPIN)(1:1))
          ENDIF

C----     If this is the end of a chain, draw chain-end
CPROCHECK fix
          IF (PINCHN(IPIN)(2:2).EQ.'<' .AND.
     -        PINCHN(IPIN)(1:1).NE.' ') THEN
              CALL PSLINE(X + DX,Y - SSSIZE * 0.6,X + DX,
     -            Y + SSSIZE * 0.6)
          ENDIF

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)(1:1)
          NXTSTR = PINSST(IPIN)(2:2)
          IF (SECSTR.NE.'=') IRES = IRES + 1
          IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'h'
     -        .OR. SECSTR.EQ.'.') THEN
              ISTRUC = HELIX
          ELSE IF (SECSTR.EQ.'E' .OR. SECSTR.EQ.'e'
     -        .OR. SECSTR.EQ.':') THEN
              ISTRUC = STRAND
          ELSE IF (SECSTR.EQ.'=') THEN
              ISTRUC = BLANK
          ELSE
              ISTRUC = COIL
          ENDIF

C----     If coil, then draw a horizontal bar
          IF (ISTRUC.EQ.COIL) THEN

C----         Draw the current fragment of the coil
              X1 = X
              X2 = X + DX
              Y1 = Y - SSSIZE * COIWID
              Y2 = Y + SSSIZE * COIWID
              CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
              CALL PSLINE(X1,Y1,X2,Y1)
              CALL PSLINE(X1,Y2,X2,Y2)

C----         If this is the start of the coil, then start box
              IF (LSTRUC.NE.COIL) THEN
                  CALL PSLINE(X,Y1,X,Y2)
              ENDIF

C----         If this is the last residue of the coil, draw its end
              IF (NXTSTR.EQ.'e' .OR. NXTSTR.EQ.'h'
     -            .OR. IRES.EQ.NRESID) THEN
                  CALL PSLINE(X2,Y1,X2,Y2)
              ENDIF
              X = X + DX

C----     Else if it's a strand, draw a horizontal box
          ELSE IF (ISTRUC.EQ.STRAND) THEN

C----         If this is the last residue of the strand, draw the arrow-head
              IF (SECSTR.EQ.':') THEN
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - ARRWID * SSSIZE
                  Y2 = Y + ARRWID * SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
                  CALL PSLINE(X,Y2,X,Y + SSSIZE)
                  CALL PSLINE(X,Y1,X,Y - SSSIZE)
                  CALL PSLINE(X,Y2,X + DX,Y)
                  CALL PSLINE(X,Y1,X + DX,Y)
                  X = X + DX

C----         Otherwise, draw the current fragment of the strand
              ELSE
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - SSSIZE
                  Y2 = Y + SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X,Y - SSSIZE,X + DX,Y - SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
                  CALL PSLINE(X,Y + SSSIZE,X + DX,Y + SSSIZE)
                  X = X + DX
              ENDIF

C----         If this is the start of the strand, then start box
              IF (SECSTR.EQ.'e') THEN
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X1,Y - SSSIZE,X1,Y + SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
              ENDIF

C----     Else if it's a helix, draw a sawtooth
          ELSE IF (ISTRUC.EQ.HELIX) THEN

C----         Increment count of helix residues in current helix
              LENRUN = LENRUN + 1
              IF (LENRUN.EQ.1) FIRSTH = IRES

C----         If at end of the helix, draw it
              IF (IRES.EQ.NRESID .OR. IPIN.EQ.NPIN .OR.
     -            SECSTR.EQ.'.') THEN
                  CALL DHELIX(LENRUN,X,Y,FIRSTH,DX,HWIDTH,HEIGHT,
     -                SHOWAC,INCOLR,MXCOLR,RGB,COLOUR)
                  LENRUN = 0
              ENDIF
          ELSE
              X = X + DX
          ENDIF

C----     Save current structure
          LSTRUC = ISTRUC
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SSDOM  -  Print out the domain colours
C
C----------------------------------------------------------------------+---

      SUBROUTINE SSDOM(XP,YPTOP,NDOM)

      REAL          DX
      PARAMETER    (DX = 6.0)

      CHARACTER*4   CNUMB
      INTEGER       IDOM, IPOS, NDOM
      REAL          DCOL1, DCOL2, DCOL3, X, XP, Y, YPTOP

C---- Initialise values
      X = XP

C---- Show key to wiring diagram
      X = XP
      Y = YPTOP + 30.0
      CALL PSTEXT(X,Y,14.0,'Domains:-')
      X = X + 70.0

C---- Loop through all the domains
      DO 200, IDOM = 1, NDOM
          WRITE(CNUMB,120) IDOM
 120      FORMAT(I4)
          IPOS = 1
          IF (CNUMB(1:1).EQ.' ') IPOS = 2
          IF (CNUMB(2:2).EQ.' ') IPOS = 3
          IF (CNUMB(3:3).EQ.' ') IPOS = 4
          CALL DOMCOL(IDOM,DCOL1,DCOL2,DCOL3)
          CALL PSCOLB(DCOL1,DCOL2,DCOL3)
          CALL PSTEXT(X,Y,14.0,CNUMB(IPOS:))
          CALL PSCOLB(0.0,0.0,0.0)
          X = X + 8.0 + (5 - IPOS) * 8.0
 200  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DOMCOL  -  Routine to return domain's colour
C
C----------------------------------------------------------------------+---

      SUBROUTINE DOMCOL(DOMAIN,DCOL1,DCOL2,DCOL3)

      SAVE

      INTEGER       MXDCOL
      PARAMETER    (MXDCOL = 7)

      INTEGER       DOMAIN, IDOM
      REAL          DCOL(3,MXDCOL), DCOL1, DCOL2, DCOL3

      DATA  DCOL   / 1.0000, 0.0000, 0.0000,
     -               0.0000, 0.0000, 0.8000,
     -               0.0000, 1.0000, 0.0000,
     -               0.7000, 0.2000, 1.0000,
     -               0.8000, 0.5000, 0.0000,
     -               0.0000, 1.0000, 1.0000,
     -               1.0000, 0.0000, 1.0000 /

C---- Get this domain's colour
      IDOM = DOMAIN
      IF (IDOM.GT.MXDCOL) IDOM = MOD(IDOM,MXDCOL)
      IF (IDOM.EQ.0) IDOM = MXDCOL
      DCOL1 = DCOL(1,IDOM)
      DCOL2 = DCOL(2,IDOM)
      DCOL3 = DCOL(3,IDOM)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SITKEY  -  Add the key defining the active site(s) and
C                        residue contacts
C
C----------------------------------------------------------------------+---

      SUBROUTINE SITKEY(XP,YP,SCALEX,INCOLR,MXCOLR,RGB,SITNAM,MXSITE,
     -    NSITE,SUSED,NUSED,HAVDNA,HAVLIG,HAVMET)

      INTEGER       MXCOLR, MXSITE

      CHARACTER*3   SITNAM(MXSITE)
      CHARACTER*10  CNAME
      CHARACTER*15  INTYPE(3)
      INTEGER       COLOUR, HPOS, INTRAC, ISITE, NSITE, NUSED
      LOGICAL       HAVDNA, HAVLIG, HAVMET, HAVCON(3), KEYCON, INCOLR,
     -              SUSED(MXSITE)
      REAL          COL(3,3), RADIUS, RGB(3,MXCOLR), SCALEX, WIDTXT(3),
     -              X, XP, XSAVE, XWID, X1, X2, Y, YP, Y1, Y2

      DATA COL    / 0.7, 0.2, 1.0,
     -              1.0, 0.0, 0.0, 
     -              0.0, 0.0, 1.0 /
      DATA INTYPE / 'with DNA', 'with ligand', 'with metal' /
      DATA WIDTXT / 42.0, 46.0, 45.0 /

C---- Initialise values
      HPOS = 0
      RADIUS = SCALEX / 6.6
      X = XP
      XSAVE = X
      Y = YP - 50.0
      CALL PSLWID(0.2)

C---- If have any active sites, then plot key
      IF (NUSED.GT.0) THEN

C----     Show key to active sites
          IF (NUSED.EQ.1) THEN
              CALL PSTEXT(X,Y,10.0,'Active site:-')
          ELSE
              CALL PSTEXT(X,Y,10.0,'Active sites:-')
          ENDIF
          X = X + 70.0
          XSAVE = X

C----     Plot the symbol and description for each active site
          DO 200, ISITE = 1, NSITE

C----         Plot the key to this active site only if it is included in 
C             the current chain
              IF (SUSED(ISITE)) THEN

C----             See if have reached the end of the line
                  HPOS = HPOS + 1
                  IF (HPOS.GT.8) THEN
                      HPOS = 0
                      Y = Y - 10.0
                      X = XSAVE
                  ENDIF

C----             Calculate coordinates of marker
                  X1 = X - SCALEX / 2.0
                  X2 = X + SCALEX / 2.0
                  Y2 = Y + 4.0
                  Y1 = Y2 - SQRT(3.0) * SCALEX / 2.0

C----             Get the colour for this active site marker
                  CALL SITCOL(ISITE,COLOUR,CNAME)
                  CALL PSHADE(0.0,COLOUR,RGB,MXCOLR,.TRUE.)

C----             Plot the marker
                  CALL PSTRIA(X1,Y2,X,Y1,X2,Y2)

C----             Plot the active site identifier
                  X = X + 8.0
                  CALL PSTEXT(X,Y,10.0,SITNAM(ISITE))
                  X = X + 32.0
              ENDIF
 200      CONTINUE

C----     Shift x along
          X = X + 15.0
      ENDIF

C---- Work out how much space key for residue contacts will take up
      XWID = 92.0
      KEYCON = .FALSE.
      DO 300, INTRAC = 1, 3
          HAVCON(INTRAC) = .FALSE.
 300  CONTINUE
      IF (HAVDNA) THEN
          KEYCON = .TRUE.
          HAVCON(1) = .TRUE.
          XWID = XWID + WIDTXT(1) + 16.0
      ENDIF
      IF (HAVLIG) THEN
          KEYCON = .TRUE.
          HAVCON(2) = .TRUE.
          XWID = XWID + WIDTXT(2) + 16.0
      ENDIF
      IF (HAVMET) THEN
          KEYCON = .TRUE.
          HAVCON(3) = .TRUE.
          XWID = XWID + WIDTXT(3) + 16.0
      ENDIF

C---- Proceed if have anything to write out
      IF (KEYCON) THEN

C----     Determine whether need to start a new line
          IF (X + XWID.GT.480.0) THEN
              Y = Y - 12.0
              X = XP
          ENDIF

C----     Write out the text
          CALL PSTEXT(X,Y,10.0,'Residue interactions:-')
          X = X + 92.0

C----     Loop over the different interaction types
          DO 500, INTRAC = 1, 3

C----         If have any interactions of this type, print the key
              IF (HAVCON(INTRAC)) THEN

C----             Plot the marker
                  X = X + 10.0
                  CALL PSCCOL(COL(1,INTRAC),COL(2,INTRAC),
     -                COL(3,INTRAC))
                  CALL PSUCIR(X,Y,RADIUS)
                  X = X + 6.0

C----             Write out the text
                  CALL PSTEXT(X,Y,10.0,INTYPE(INTRAC))
                  X = X + WIDTXT(INTRAC)
              ENDIF
 500      CONTINUE
      ENDIF

C---- Return the current low-point
      YP = Y + 25.0

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE INTKEY  -  Add the key defining intron splice sites
C
C----------------------------------------------------------------------+---

      SUBROUTINE INTKEY(XP,YP,SCALEX,INCOLR,MXCOLR)

      INTEGER       MXCOLR

      INTEGER       COLOUR
      LOGICAL       INCOLR
      REAL          SCALEX, SHADE, X, XP, XSAVE, Y, YP, Y1

C---- Initialise values
      X = XP
      XSAVE = X
      Y = YP - 40.0
      Y1 = Y + 8.0
      CALL PSLWID(0.2)

C---- Show key to intron splice sites
      CALL PSTEXT(X,Y,10.0,'Intron splice sites:-')
      X = X + 80.0
      XSAVE = X

C---- Plot scissors for phase 0
      SHADE = 0.2
      COLOUR = 3
      CALL PSCISS(X,Y1,SHADE,COLOUR,INCOLR)
      X = X + 15.0
      CALL PSTEXT(X,Y,10.0,'= phase 0,')

C---- Plot scissors for phase 0
      X = XSAVE + 60
      SHADE = 0.4
      COLOUR = 9
      CALL PSCISS(X,Y1,SHADE,COLOUR,INCOLR)
      X = X + 15.0
      CALL PSTEXT(X,Y,10.0,'= phase 1,')

C---- Plot scissors for phase 0
      X = XSAVE + 120
      SHADE = 0.8
      COLOUR = 5
      CALL PSCISS(X,Y1,SHADE,COLOUR,INCOLR)
      X = X + 15.0
      CALL PSTEXT(X,Y,10.0,'= phase 2')

C---- Return the current low-point
      YP = Y + 25.0

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SSKEY  -  Draw the key to the "wiring diagram"
C
C----------------------------------------------------------------------+---

      SUBROUTINE SSKEY(XP,YP,DX,SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLOUR,
     -    MINACC,MAXACC)

      SAVE

      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

      REAL          ARRWID, COIWID, THICK, THIN
      PARAMETER    (
     -              ARRWID = 1.8,
     -              COIWID = 0.25,
     -              THICK  = 0.4,
     -              THIN   = 0.2
     -             )

      INTEGER       MXCOLR
      INTEGER       COLOUR, IRES, LENRUN, LSTRUC, MAXACC, MINACC
      LOGICAL       INCOLR, SHOWAC
      REAL          DX, HEIGHT, HWIDTH, RGB(3,MXCOLR), SSSIZE, X, XP,
     -              X1, X2, Y, YP, Y1, Y2

      DATA IRES,LSTRUC   / 0, 0 /

C---- Initialise values
      HEIGHT = SSSIZE * 1.8
      HWIDTH = SSSIZE * 1.8
      X = XP
      Y = YP
      LENRUN = 0
      CALL PSLWID(THIN)

C---- Show key to wiring diagram
      X = XP
      Y = YP - 60.0
      YP = Y
      CALL PSTEXT(X,Y,12.0,'Key:-')

C---- Helix
      X = XP + 32.0
      CALL DHELIX(4,X,Y,1,DX,HWIDTH,HEIGHT,SHOWAC,INCOLR,MXCOLR,
     -    RGB,COLOUR)
 500  CONTINUE
      X = X + 4.0
      CALL PSTEXT(X,Y,11.0,'Helix')

C---- Strand
      X = XP + 96.0
      X1 = X
      X2 = X + 3 * DX
      Y1 = Y - SSSIZE
      Y2 = Y + SSSIZE
      CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
      CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      IF (.NOT.SHOWAC) CALL PSLWID(THICK)
      CALL PSLINE(X1,Y1,X1,Y2)
      CALL PSLINE(X,Y - SSSIZE,X + 3 * DX,Y - SSSIZE)
      IF (.NOT.SHOWAC) CALL PSLWID(THIN)
      CALL PSLINE(X,Y + SSSIZE,X + 3 * DX,Y + SSSIZE)
      X = X + 3 * DX
      X1 = X
      X2 = X + DX
      Y1 = Y - ARRWID * SSSIZE
      Y2 = Y + ARRWID * SSSIZE
      CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
      CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
      CALL PSLINE(X,Y2,X,Y + SSSIZE)
      CALL PSLINE(X,Y1,X,Y - SSSIZE)
      CALL PSLINE(X,Y2,X + DX,Y)
      CALL PSLINE(X,Y1,X + DX,Y)
      X = X + DX + 4.0
      CALL PSTEXT(X,Y,11.0,'Beta strand')

C---- Coil
      X = XP + 182.0
      X1 = X + DX
      X2 = X1 + 3 * DX
      Y1 = Y - SSSIZE * COIWID
      Y2 = Y + SSSIZE * COIWID
      CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
      CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSLINE(X1,Y1,X2,Y1)
      CALL PSLINE(X1,Y2,X2,Y2)
      CALL PSLINE(X1,Y1,X1,Y2)
      CALL PSLINE(X2,Y1,X2,Y2)
      X = X + 4 * DX + 4.0
      CALL PSTEXT(X,Y,11.0,'Random coil')

C---- Accessibility shading
      IF (SHOWAC) THEN
          X = XP + 288.0
          Y1 = Y + 2.5
          Y2 = Y - 2.5
          IF (INCOLR) THEN
              CALL PSTEXT(X,Y,10.0,'Accessibility shading:')
              X1 = X + 94.0
              X2 = X1 + 5.0
              CALL PSHADE(0.0,MINACC,RGB,MXCOLR,INCOLR)
              CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
              X = X2 + 3.0
              CALL PSTEXT(X,Y,10.0,'Buried')
              X1 = X + 38.0
              X2 = X1 + 5.0
              CALL PSHADE(0.0,MAXACC,RGB,MXCOLR,INCOLR)
              CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
              X = X2 + 3.0
              CALL PSTEXT(X,Y,10.0,'Accessible')
          ELSE
              CALL PSTEXT(X,Y,10.0,'Accessibility shading: Black=' //
     -            'buried, White=accessible')
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CHNCOL  -  Routine to locate the chain ID in the chain list
C                        and return its position
C
C----------------------------------------------------------------------+---

      SUBROUTINE CHNCOL(ICHAIN,INCHN,CHCOLR,CNAME)

      INCLUDE 'wirplot.inc'

      CHARACTER*1   INCHN
      CHARACTER*10  CNAME, COLTXT(MXCOBJ)
      CHARACTER*37  CHAINS
      INTEGER       CHCOLR, COLMAP(MXCOBJ), ICHAIN, ICOLR

      DATA COLMAP /  9, 3, 17, 11, 5, 4, 10, 6 /
      DATA COLTXT /'purple    ', 'red       ', 'brown     ',
     -             'pink      ', 'blue      ', 'green     ',
     -             'cyan      ', 'yellow    ' /

      DATA CHAINS / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456 7890' /

C---- Get the corresponding chain-ID
      ICOLR = INDEX(CHAINS,INCHN)
      IF (ICOLR.LT.1) ICOLR = 1

C---- Get the colour for this chain
100   CONTINUE
          IF (ICOLR.GT.MXCOBJ) THEN
              ICOLR = ICOLR - MXCOBJ
              GO TO 100
          ENDIF
      CHCOLR = COLMAP(ICOLR)
      CNAME = COLTXT(ICOLR)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SITCOL  -  Routine to get the marker colour for this active
C                        site
C
C----------------------------------------------------------------------+---

      SUBROUTINE SITCOL(ISITE,COLOUR,CNAME)

      INCLUDE 'wirplot.inc'

      CHARACTER*10  CNAME, COLTXT(MXCOBJ)
      INTEGER       COLOUR, COLMAP(MXCOBJ), ISITE, ICOLR

      DATA COLMAP /  4, 5, 3, 6, 9, 17, 11, 10 /
      DATA COLTXT /'green     ', 'blue      ', 'red       ',
     -             'yellow    ', 'purple    ', 'brown     ',
     -             'pink      ', 'cyan      ' /

C---- Set colour
      ICOLR = ISITE

C---- Adjust the colour, if necessary
100   CONTINUE
          IF (ICOLR.GT.MXCOBJ) THEN
              ICOLR = ICOLR - MXCOBJ
              GO TO 100
          ENDIF
      COLOUR = COLMAP(ICOLR)
      CNAME = COLTXT(ICOLR)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE JOINCS  -  Join all the cysteine residues making up the 
C                        disulphide bonds
C
C----------------------------------------------------------------------+---

      SUBROUTINE JOINCS 

      INCLUDE 'wirplot.inc'

      INTEGER       FSTDWN, FSTUP
      PARAMETER    (FSTDWN = 5.0, FSTUP = 10.0)

      INTEGER       ICYS, IPOS, ISPAN, JCYS, NSPAND, NSPANU
      LOGICAL       CLASH, FOUND
      REAL          DIST, DYDOWN, DYUP, FRACTN, LASTY, SPANDX(2,MXPINS),
     -              SPANUX(2,MXPINS), XDIFF, X1, X2, YDIFF, Y1, Y2,
     -              YSHIFT


C---- Initialise variables
      DYDOWN = FSTDWN
      DYUP = FSTUP
      LASTY = 0.0
      DO 50, ISPAN = 1, MXPINS
          SPANDX(1,ISPAN) = 0.0
          SPANDX(2,ISPAN) = 0.0
          SPANUX(1,ISPAN) = 0.0
          SPANUX(2,ISPAN) = 0.0
 50   CONTINUE
      NSPAND = 0
      NSPANU = 0

C---- Loop until all pairs have been exhausted
 100  CONTINUE
          ICYS = 0
          FOUND = .FALSE.

C----     Search through all the cysteines until find the
C         first one of a pair
 200      CONTINUE
              ICYS = ICYS + 1
              IF (CYSNUM(ICYS).NE.' ' .AND. CYSNUM(ICYS).NE.'X') THEN
                  FOUND = .TRUE.
              ENDIF
          IF (.NOT.FOUND .AND. ICYS.LT.NCYS) GO TO 200

C----     If have found the first of a pair, then locate the other
          IF (FOUND) THEN
              JCYS = 0
              DO 400, IPOS = ICYS + 1, NCYS

C----             If have a matching partner, then store
                  IF (CYSNUM(IPOS).EQ.CYSNUM(ICYS)) JCYS = IPOS
 400          CONTINUE

C----         If have the partner, then join the two
              IF (JCYS.GT.0) THEN

C----             Get the coordinates of the two Cys residues
                  X1 = CYSPOS(1,ICYS)
                  Y1 = CYSPOS(2,ICYS)
                  X2 = CYSPOS(1,JCYS)
                  Y2 = CYSPOS(2,JCYS)

C----             Set line-type
                  CALL PSSAVE
                  CALL PSDOT(1,4)
                  CALL PSCOLB(0.0,1.0,0.0)
                  CALL PSLWID(0.1)

C----             Determine if the two are on the same line
                  IF (ABS(Y1 - Y2).LT.1.0) THEN

C----                 If this is a different line from before, reinitialise
C                     the shifts
                      IF (ABS(Y1 - LASTY).GT.10.0) THEN
                          LASTY = Y1
                          DYDOWN = FSTDWN
                          DYUP = FSTUP

C----                     Reinitialise the record of spanning x-positions
                          DO 500, ISPAN = 1, MXPINS
                              SPANDX(1,ISPAN) = 0.0
                              SPANDX(2,ISPAN) = 0.0
                              SPANUX(1,ISPAN) = 0.0
                              SPANUX(2,ISPAN) = 0.0
 500                      CONTINUE
                          NSPAND = 0
                          NSPANU = 0
                      ENDIF

C----                 If below the line, then shift y-coords downwards
                      IF (CYSUPD(ICYS).EQ.'D') THEN

C----                     If first Cys lies outside all previous spans
C                         in this line, then reinitialise shift positions
                          CLASH = .FALSE.
                          DO 600, ISPAN = 1, NSPAND
                              IF (X1.GT.SPANDX(1,ISPAN) .AND.
     -                            X1.LT.SPANDX(2,ISPAN)) CLASH = .TRUE.
 600                      CONTINUE

C----                     If no clash, then reset shift positions
                          IF (.NOT.CLASH) THEN
                              DYDOWN = FSTDWN
                          ENDIF

C----                     Add the current span to the list
                          NSPAND = NSPAND + 1
                          IF (NSPAND.GT.MXPINS) THEN
                              PRINT*, '*** ERROR. Maximum number of Cy',
     -                            's spans exceeded! NSPAND = ', NSPAND
                              NSPAND = MXPINS
                          ELSE
                              SPANDX(1,NSPAND) = X1
                              SPANDX(2,NSPAND) = X2
                          ENDIF

C----                     Apply the downward shift
                          Y1 = Y1 - (CYSRAD + 1.0)
                          YSHIFT = Y1 - DYDOWN
                          DYDOWN = DYDOWN + 4.0

C----                 Otherwise, shift the upwards
                      ELSE

C----                     If first Cys lies outside all previous spans
C                         in this line, then reinitialise shift positions
                          CLASH = .FALSE.
                          DO 700, ISPAN = 1, NSPANU
                              IF (X1.GT.SPANUX(1,ISPAN) .AND.
     -                            X1.LT.SPANUX(2,ISPAN)) CLASH = .TRUE.
 700                      CONTINUE

C----                     If no clash, then reset shift positions
                          IF (.NOT.CLASH) THEN
                              DYUP = FSTUP
                          ENDIF

C----                     Add the current span to the list
                          NSPANU = NSPANU + 1
                          IF (NSPANU.GT.MXPINS) THEN
                              PRINT*, '*** ERROR. Maximum number of Cy',
     -                            's spans exceeded! NSPANU = ', NSPANU
                              NSPANU = MXPINS
                          ELSE
                              SPANUX(1,NSPANU) = X1
                              SPANUX(2,NSPANU) = X2
                          ENDIF

C----                     Apply the downward shift
                          Y1 = Y1 + (CYSRAD + 1.0)
                          YSHIFT = Y1 + DYUP
                          DYUP = DYUP + 4.0
                      ENDIF

C----                 Join the circle edges to the shift positions
                      CALL PSLINE(X1,Y1,X1,YSHIFT)
                      CALL PSLINE(X2,Y1,X2,YSHIFT)

C----                 Draw the horizontal line
                      CALL PSLINE(X1,YSHIFT,X2,YSHIFT)

C----             If residues not on the same line, then just join
                  ELSE

C----                 Calculate the distance between the residues
                      DIST = (X1 - X2) * (X1 - X2)
     -                    + (Y1 - Y2) * (Y1 - Y2)
                      DIST = SQRT(DIST)

C----                 Calculate fraction to be lopped off at either end
C                     so as not to have the line going over the residue
C                     circles
                      FRACTN = (CYSRAD + 1.0) / DIST

C----                 Adjust the x- and y-coordinates accordingly
                      XDIFF = X2 - X1
                      YDIFF = Y2 - Y1
                      X1 = X1 + FRACTN * XDIFF
                      X2 = X2 - FRACTN * XDIFF
                      Y1 = Y1 + FRACTN * YDIFF
                      Y2 = Y2 - FRACTN * YDIFF

C----                 Draw the line between them
                      CALL PSLINE(X1,Y1,X2,Y2)
                  ENDIF


C----             Restore the graphics state
                  CALL PSREST

C----             Blank out the ID so that not done twice
                  CYSNUM(JCYS) = ' '
              ENDIF

C----         Blank out the ID so that not done twice
              CYSNUM(ICYS) = ' '
          ENDIF

C---- If there are more to do, then loop back
      IF (FOUND) GO TO 100

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CONVRT  -  Write out the clip-line for use with CONVERT when
C                        automatically converting the PostScript file to a
C                        gif file in the run.scr script of generate
C
C----------------------------------------------------------------------+---

      SUBROUTINE CONVRT(XLEFT,XRIGHT,YBOT,YTOP)

      INCLUDE 'wirplot.inc'

      CHARACTER*3   CONTXT(4), CRPTXT(4)
      REAL          XLEFT, XRIGHT, YBOT, YTOP
      INTEGER       ILOOP, IPOS(4), JPOS(4), IVALUE(4)

C---- Form the four integers required
      IVALUE(1) = NINT(XRIGHT - XLEFT)
      IVALUE(2) = NINT(YTOP - YBOT)
      IVALUE(3) = NINT(XLEFT)
      IVALUE(4) = NINT(YBOT)

C---- Convert each of the numbers into a character-string
      DO 200, ILOOP = 1, 4
          WRITE(CONTXT(ILOOP),120) IVALUE(ILOOP)
 120      FORMAT(I3)
          IPOS(ILOOP) = 1
          IF (CONTXT(ILOOP)(1:1).EQ.' ') IPOS(ILOOP) = 2
          IF (CONTXT(ILOOP)(2:2).EQ.' ') IPOS(ILOOP) = 3
 200  CONTINUE

C---- Repeat for the new -crop parameters
      IVALUE(4) = NINT(YTOP)
      WRITE(CRPTXT(1),120) IVALUE(1)
      WRITE(CRPTXT(2),120) IVALUE(2)
      WRITE(CRPTXT(3),120) IVALUE(3) - BBOXX1 + 1
      WRITE(CRPTXT(4),120) BBOXY2 - IVALUE(4) + 1
      DO 300, ILOOP = 1, 4
          JPOS(ILOOP) = 1
          IF (CRPTXT(ILOOP)(1:1).EQ.' ') JPOS(ILOOP) = 2
          IF (CRPTXT(ILOOP)(2:2).EQ.' ') JPOS(ILOOP) = 3
 300  CONTINUE

C---- Write out the convert clip parameters to the PostScript file
      WRITE(11,420) (CONTXT(ILOOP)(IPOS(ILOOP):), ILOOP = 1, 4)
 420  FORMAT('%convert -clip ',A,'x',A,'+',A,'-',A)

C---- Write out the convert clip parameters to the PostScript file
      WRITE(11,440) (CRPTXT(ILOOP)(JPOS(ILOOP):), ILOOP = 1, 4)
 440  FORMAT('%convert -crop ',A,'x',A,'+',A,'+',A)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE WRSITE  -  Write out the active site details, as read in
C                        from the SITE records and corresponding remarks
C
C----------------------------------------------------------------------+---

      SUBROUTINE WRSITE(BRCODE,CHAIN,PRODIR,PDBFIL,SITNAM,MXSITE,NSITE,
     -     SUSED,NUSED)

      INTEGER       MXLINE
      PARAMETER    (MXLINE = 50)

      INTEGER       MXSITE

      CHARACTER*1   CHAIN
      CHARACTER*3   SITNAM(MXSITE), SNAME
      CHARACTER*4   BRCODE
      CHARACTER*5   STRING
      CHARACTER*10  CHNTXT, CNAME, LSTREM
      CHARACTER*12  TITLE
      CHARACTER*45  RLINES(MXLINE)
      CHARACTER*60  DLINES(MXLINE)
      CHARACTER*(*) PDBFIL
      CHARACTER*120 FILNAM, IREC, PRODIR, SITDES
      INTEGER       CLEN, COLOUR, IERROR, ILINE, IPOS1,
     -              IPOS2, ISITE, LENSTR, LINE, LOOP, NDLINE, NRLINE,
     -              NSITE, NUSED
      LOGICAL       DEND, HAVFIL, INSITE, SUSED(MXSITE)

C---- Initialise variables
      IF (CHAIN.NE.' ') THEN
          WRITE(CHNTXT,30) CHAIN
 30       FORMAT('Chain ',A1,' - ')
          CLEN = 10
      ELSE
          CHNTXT = ' '
          CLEN = 1
      ENDIF
      IF (NUSED.EQ.1) THEN
          TITLE = 'Active site'
      ELSE
          TITLE = 'Active sites'
      ENDIF

C---- Initialise flag indicating whether input file is present
      HAVFIL = .FALSE.
      LINE = 0
      LOOP = 0
      LSTREM = ' '

C---- Loop until have successfully opened either the pdbhead.txt file,
C     or the original PDB file
 100  CONTINUE

C----     Increment loop count
          LOOP = LOOP + 1

C----     Form the file-name according to which loop we're on

C----     For first loop, try the pdbhead.txt file in the WWW directory
          IF (LOOP.EQ.1) THEN
              FILNAM = PRODIR(1:LENSTR(PRODIR)) // '/' // BRCODE //
     -            '/pdbhead.txt'

C----     For second loop, try the pdbhead.txt file in the current directory
          ELSE IF (LOOP.EQ.2) THEN
              FILNAM = BRCODE // '_con.dat'

C----     Otherwise, try the original PDB file
          ELSE
              FILNAM = PDBFIL
          ENDIF

C----     Open the file
          OPEN(UNIT=2, FILE=FILNAM, STATUS='OLD', FORM='FORMATTED',
     -        ACCESS='SEQUENTIAL',
CVAX         -    READONLY,
     -        IOSTAT=IERROR)
          IF (IERROR.EQ.0) HAVFIL = .TRUE.

C---- If haven't found a valid file yet, try another one
      IF (.NOT.HAVFIL .AND. LOOP.LT.3) GO TO 100

C---- If one of the required files exists, then pick up the data in it
      IF (HAVFIL) THEN

C----     Form the name of the output html file
          IF (CHAIN.EQ.' ') THEN
              FILNAM = 'sites.html'
          ELSE
              FILNAM = 'sites' // CHAIN // '.html'
          ENDIF

C----     Open the sites output file
          OPEN(UNIT=7,FILE=FILNAM,STATUS='UNKNOWN',
     -         ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL='LIST',
     -         FORM='FORMATTED',ERR=900)

C----     Write out the header records
          WRITE(7,110) '<html>'
 110      FORMAT(10A)
          WRITE(7,110) '<head>'
          WRITE(7,140) BRCODE, CHNTXT(1:CLEN), TITLE
 140      FORMAT('<title>',A,': ',2A,'</title>')
          WRITE(7,110) '</head>'
          WRITE(7,110) '<body>'
          WRITE(7,110) '<H1><A HREF="main.html">', BRCODE, '</A>: ',
     -        CHNTXT(1:CLEN), TITLE, '</H1>'

C----     Loop through all the active sites in the current chain
          DO 1500, ISITE = 1, NSITE

C----         If this is one of the active sites used, then get all the
C             details from the file
              IF (SUSED(ISITE)) THEN

C----             Rewind the input file
                  REWIND(2)

C----             Initialise storage counters
                  NDLINE = 0
                  NRLINE = 0
                  INSITE = .FALSE.

C----             Loop while reading through the file
                  DEND = .FALSE.
 400              CONTINUE

C----                 Read in the next record
                      READ(2,420,END=1000) IREC
 420                  FORMAT(A)
                      LINE = LINE + 1

C----                 If this is a SITE record, then pick up the residues
                      IF (IREC(1:6).EQ.'SITE  ') THEN

C----                     Check whether this is the right site
                          SNAME = IREC(12:14)
                          IF (SNAME.EQ.SITNAM(ISITE)) THEN

C----                         Increment count of lines read in
                              NRLINE = NRLINE + 1
                              IF (NRLINE.GT.MXLINE) THEN
                                  PRINT*, '*** Warning. Maximum number',
     -                                'of SITE lines exceeded, MXLINE',
     -                                MXLINE
                                  PRINT*, '***          Some data lost'
                                  NRLINE = MXLINE
                              ENDIF

C----                         Store this line of data
                              RLINES(NRLINE) = IREC(19:61)
                          ENDIF
                          INSITE = .FALSE.

C----                 If this is a SITE remark for this site, then pick
C                     up the description
                      ELSE IF (IREC(1:6).EQ.'REMARK') THEN

C----                     Check for old format
                          STRING = '*' // SITNAM(ISITE) // '*'
                          IPOS1 = INDEX(IREC,STRING)
                          IF (IPOS1.GT.0) THEN
                              INSITE = .TRUE.
                              SNAME = SITNAM(ISITE)
                          ENDIF

C----                     Check for alternative old format
                          IF (.NOT.INSITE) THEN
                              IPOS1 = INDEX(IREC,' *SITE* ')
                              IF (IPOS1.GT.0) THEN
                                  INSITE = .TRUE.
                                  SNAME = ' '
                              ENDIF
                          ENDIF

C----                     Check for old, old format
                          IF (.NOT.INSITE) THEN
                              IPOS1 = INDEX(IREC,' THE SITE')
                              IPOS2 = INDEX(IREC,' WITH IDENTIFIER ')
                              IF (IPOS1.GT.0 .AND. IPOS2.GT.0) THEN
                                  INSITE = .TRUE.
                                  SNAME = ' '
                              ENDIF
                          ENDIF

C----                     If this is a site identifer, then check whether
C                         it is for the current site
                          IF (IREC(13:27).EQ.'SITE_IDENTIFIER') THEN

C----                         Check whether this is the right site
                              SNAME = IREC(30:32)
                              IF (SNAME(3:3).EQ.' ') THEN
                                  SNAME = ' ' // SNAME
                              ENDIF
                              IF (SNAME.EQ.SITNAM(ISITE)) THEN
                                  INSITE = .TRUE.
                              ELSE
                                  INSITE = .FALSE.
                              ENDIF

C----                     If this is a site identifer, then check whether
C                         it is for the current site
                          ELSE IF (IREC(12:27).EQ.'SITE_IDENTIFIER:')
     -                        THEN

C----                         Check whether this is the right site
                              SNAME = IREC(29:31)
                              IF (SNAME(3:3).EQ.' ') THEN
                                  SNAME = ' ' // SNAME
                              ENDIF
                              IF (SNAME.EQ.SITNAM(ISITE)) THEN
                                  INSITE = .TRUE.
                              ELSE
                                  INSITE = .FALSE.
                              ENDIF

C----                     If currently picking up the details of the current
C                         site, add this line
                          ELSE IF (INSITE) THEN

C----                         If the REMARK number has changed, then no longer
C                             in site description
                              IF (IREC(1:10).NE.LSTREM) THEN
                                  INSITE = .FALSE.

C----                         Increment count of lines read in
                              ELSE
                                  NDLINE = NDLINE + 1
                                  IF (NDLINE.GT.MXLINE) THEN
                                      PRINT*, '*** Warning. Maximum nu',
     -                                    'mberof SITE description lin',
     -                                    'es exceeded, MXLINE', MXLINE
                                      PRINT*, '***          Some data ',
     -                                    'lost'
                                      NDLINE = MXLINE
                                  ENDIF

C----                             Extract key-words if present
                                  SITDES = IREC(12:72)
                                  IPOS1 = 
     -                                INDEX(SITDES,'SITE_DESCRIPTION:')
                                  IF (IPOS1.GT.0) THEN
                                      IF (IPOS1.EQ.1) THEN
                                          IREC(12:72) = SITDES(18:)
                                      ELSE
                                          IREC(12:72)
     -                                        = SITDES(1:IPOS1 - 1)
     -                                        // SITDES(IPOS1 + 17:)
                                      ENDIF
                                  ENDIF

C----                             Store this line of data
                                  DLINES(NDLINE) = IREC(12:72)
                              ENDIF
                          ENDIF

C----                     Save the REMARK number
                          LSTREM = IREC(1:10)

C----                 If this is an ATOM record, can end the read here
                      ELSE IF (IREC(1:6).EQ.'ATOM  ') THEN
                          DEND = .TRUE.
                      ELSE
                          INSITE = .FALSE.
                      ENDIF
                  IF (.NOT.DEND) GO TO 400

C----             End of input file reached
 1000             CONTINUE

C----             Get this site's colour
                  CALL SITCOL(ISITE,COLOUR,CNAME)

C----             Write out the site details for this site
                  WRITE(7,110) '<H2><IMG SRC="../',
     -                CNAME(1:LENSTR(CNAME)), '_tri.gif"> Site: ',
     -                SITNAM(ISITE), '</H2>'

C----             Write out the site description
                  IF (NDLINE.GT.0) THEN
                      WRITE(7,110) '<I>'
                      DO 1100, ILINE = 1, NDLINE
                          WRITE(7,110) DLINES(ILINE)
 1100                 CONTINUE
                      WRITE(7,110) '</I>'
                  ENDIF

C----             Write out the site residues
                  WRITE(7,110) '<H3>Active site residue(s):-</H3><PRE>'
                  DO 1200, ILINE = 1, NRLINE
                      WRITE(7,110) RLINES(ILINE)
 1200             CONTINUE
                  WRITE(7,110) '</PRE>'
                  WRITE(7,110) '<HR>'
              ENDIF

C----     Close the input file
 1500     CONTINUE
          CLOSE(2)

C----     Write closing lines to the html file and close
          WRITE(7,*)
          WRITE(7,110) '</body>'
          WRITE(7,110) '</html>'
          CLOSE(7)

      ENDIF

      GO TO 999

 900  CONTINUE
      PRINT*, '*** Warning. Unable to open sites.html file for output'

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
