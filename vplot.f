C**************************************************************************
C
C  VPLOT.FOR  -  Restraint-violations plots for NMR ensembles
C
C     Written by Roman Laskowski, University College, London, March 1996.
C
C     Original version was part of v.3.4 of the PROCHECK suite of programs.
C     (Initial version made of routines stripped out of mplot.f)
C
C     Subsequent amendments will be labelled by CHECK v.m.n--> and
C     CHECK v.m.n<-- where m.n is the version number corresponding to the
C     change
C     
C
C  v.3.4.3 - Allowance for larger atom names in the distance restraints and
C            restraint differences plots. Minor cosmetic changes.
C            Amendment to Violations Frequency plot s.t. numbers of
C            unviolated restraints excluded from calculation of graph
C            y-axis scales.
C                                              Roman Laskowski (16 May 1996)
C            Minor bugs, thrown up by f2c, fixed.
C                                              Roman Laskowski (23 Jul 1996)
C
C  v.3.5.4 - Bug fix. Uninitialised variable giving core dumps under linux,
C            and other new compilers. Reported by Art Edison and Atro
C            Tossavainen.
C                                              Roman Laskowski (27 Feb 2001)
C
C--------------------------------------------------------------------------
C
C Compilation and linking (on unix)
C -----------------------
C
C f77 -u -c vplot.f
C f77 -u -c ps.f
C f77 -o vplot vplot.o ps.o
C
C Compilation and linking (on VAX VMS)
C -----------------------
C
C FORT VPLOT
C FORT PS
C LINK VPLOT, PS
C
C--------------------------------------------------------------------------
C     
C  Files
C  -----
C     
C  2  mplot.in       - File containing the list of .rin files to be processed
C                      Each line of the file contains the filename and
C                      optional additional information on how the point
C                      is to be plotted.
C  4  <filename>.rin - Individual .rin files generated by program secstr.f,
C                      containing the secondary structure information and
C                      all the required torsion angles
C 10  procheck_nmr.prm - Input parameter file containing user-defined
C                      options governing the plots produced. For ensembles,
C                      file is called procheck_comp.prm
C 11  <outname>.dnn  - Output PostScript files, numbered nn = 01, 02, ...
C 12  <filename>.nrv - NOE restraints            }
C     <filename>.hrv - H-bond restraints         }  Files output by AQUA
C     <filename>.tor - Dihedral angle restraints }
C 13  <filename>.edt - Input file of calculated residue-by-residue data,
C                      including circular variances, G-factors, etc.
C 16  <user-defined> - Optional input file holding the model- and residue-
C                      number ranges to be included in the plots.
C
C--------------------------------------------------------------------------
C     
C     Subroutine calling tree
C     -----------------------
C     
C     MAIN    --> INITS
C             --> GETOUT  --> GETNAM
C             --> PARAMS  --> FINKEY
C                         --> GETCOL
C             --> GETPSN
C             --> GETFIL  --> GETNOD  --> READCH
C                         --> GETNAM
C             --> GETRNG  --> GETOKN
C                         --> INTOKN  --> LENSTR
C                         --> DELTOK
C                         --> STOTOK
C                         --> PRNRNG
C             --> GETWNT  --> INMODL
C             --> GETVAL  --> GETRIN  --> INRANG  --> LENSTR
C             --> OPNEDT
C             --> GETCON  --> GETCLS
C             --> GETORS  --> CVIOL
C             --> PRESRT  --> RESORT
C
C                 Plot the restraint analyses
C             --> RSTPLT  --> RSWANT
C                         --> ADJLIM
C                         --> PLTKEY  --> PSCTXT
C                                     --> PSHADE
C                                     --> PSUBOX
C                                     --> PSLINE
C                                     --> PSDASH
C                                     --> PSTEXT
C                                     --> PSCOLB
C                                     --> PSLWID
C                                     --> PSBBOX
C                                     --> PSCCOL
C                                     --> PSCSHD
C                                     --> PSCIRC
C                                     --> PLEXCL  --> PSTEXT
C                         --> PSENDP
C                         --> PSCLOS
C                         --> PGOPEN  --> PSNAME
C                                     --> PSOPEN
C                                     --> PSPAGE
C                                     --> PSLWID
C                                     --> PSCTXT
C                                     --> LENSTR
C                                     --> PSTEXT
C                         --> PINRPT  --> PINGBX  --> PSHADE
C                                                 --> PSUBOX
C                                                 --> PSDASH
C                                                 --> PSLINE
C                                                 --> AXES    --> PSLWID
C                                                             --> PSLINE
C                                                             --> PSCTXT
C                                                             --> PSLINE
C                                                             --> PSLINE
C                                                 --> PSCTXT
C                                                 --> PSRCTX
C                                     --> PSRTXT
C                                     --> PSHADE
C                                     --> PSUBOX
C                                     --> PSLINE
C                                     --> FMTRES
C                                     --> PSCTXT
C                                     --> PSCOLB
C                                     --> PSLWID
C                                     --> PLTPTS  --> SHSORT
C                                                 --> PSLWID
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSCIRC
C                                                 --> PSCTXT
C                                     --> PSTRIA
C
C                 Plot the restraint summariess
C             --> RSUMPL  --> BRCALC  --> GETBAR
C                                     --> INSORT
C                                     --> ADJLIM
C                         --> PGOPEN  --> (as above)
C                         --> PSCTXT
C                         --> SUMKEY  --> PSCTXT
C                                     --> PSLWID
C                                     --> PSHADE
C                                     --> PSBBOX
C                                     --> PSTEXT
C                         --> PSENDP
C                         --> PSCLOS
C                         --> PSTEXT
C                         --> PSTEXT
C                         --> PSHADE
C                         --> PSUBOX
C                         --> PSRCTX
C                         --> BRPLOT  --> DRWBAR  --> PSLWID
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                                 --> PSUBOX
C                                                 --> PSLINE
C                                     --> PSHADE
C                                     --> PSTRIA
C                                     --> PSCTXT
C                         --> AXES    --> PSLWID
C                                     --> PSLINE
C                                     --> PSCTXT
C                                     --> PSLINE
C                                     --> PSDASH
C                         --> PSDASH
C                         --> PSLINE
C
C                 Plot the restraint statistics
C             --> RSTATS  --> PGOPEN  --> (as above)
C                         --> PSTEXT
C                         --> RHEADS  --> PSTEXT
C                         --> PSLINE
C                         --> RSLINE  --> PSTEXT
C                         --> RSRANG  --> PSTEXT
C                         --> PSENDP
C                         --> PSCLOS
C             --> OPTSET
C
C                 Plot the residue restraint spans
C             --> RSPANS  --> RSWANT
C                         --> ADJLIM
C                         --> PSENDP
C                         --> PSCLOS
C                         --> PGOPEN  --> (as above)
C                         --> PLSPAN  --> PSLWID
C                                     --> PINGBX  --> (as above)
C                                     --> PINRNO  --> PSCTXT
C                                                 --> PSLINE
C                                     --> PSCTXT
C                                     --> PSCOLB
C                                     --> PSDASH
C                                     --> PSLINE
C                                     --> PSTEXT
C                                     --> PSLWID
C                                     --> ACCSHD  --> PSCALE
C                                                 --> PSUBOX
C                                     --> SSPLOT  --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSUBOX
C                                                 --> PSUTRI
C                                                 --> DHELIX  --> PSHADE
C                                                             --> PSUBOX
C                                                             --> PSLWID
C                                                 --> PSBBOX
C                                     --> PINTIC
C                                     --> PLEXLC  --> PSTEXT
C
C                 Plot the residue-by-residue restraint violations
C             --> PINVIO  --> RSWANT
C                         --> ADJLIM
C                         --> PSENDP
C                         --> PSCLOS
C                         --> PGOPEN  --> (as above)
C                         --> PINVPT  --> PSLWID
C                                     --> PINGBX  --> (as above)
C                                     --> PINRNO  --> PSCTXT
C                                                 --> PSLINE
C                                     --> PSCTXT
C                                     --> PLTPTS  --> SHSORT
C                                                 --> PSLWID
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSCIRC
C                                                 --> PSCTXT
C                                     --> PSTEXT
C                                     --> SYMKEY  --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSCIRC
C                                                 --> PSTEXT
C                                                 --> PSCOLB
C                                     --> PINBOX  --> PSLWID
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                     --> ACCSHD  --> PSCALE
C                                                 --> PSUBOX
C                                     --> SSPLOT  --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSUBOX
C                                                 --> PSUTRI
C                                                 --> DHELIX  --> PSHADE
C                                                             --> PSUBOX
C                                                             --> PSLWID
C                                                 --> PSBBOX
C                                     --> CNPLOT  --> PSLWID
C                                                 --> PSTEXT
C                                                 --> SHSORT
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                     --> PINTIC  --> PSLWID
C                                                 --> PSLINE
C                                     --> PSHADE
C                                     --> PSBBOX
C                                     --> PLEXCL  --> PSTEXT
C
C                 Plot the model-by-model restraint violations and G-factors
C             --> MODELC  --> RSWANT
C                         --> ADJLIM
C                         --> PSENDP
C                         --> PSCLOS
C                         --> PGOPEN  --> (as above)
C                         --> MODPLT  --> PSLWID
C                                     --> PSTEXT
C                                     --> ACCSHD  --> PSCALE
C                                                 --> PSUBOX
C                                     --> SSPLOT  --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSTEXT
C                                                 --> PSHADE
C                                                 --> PSUBOX
C                                                 --> PSUTRI
C                                                 --> DHELIX  --> PSHADE
C                                                             --> PSUBOX
C                                                             --> PSLWID
C                                                 --> PSBBOX
C                                     --> CNPLOT  --> PSLWID
C                                                 --> PSTEXT
C                                                 --> SHSORT
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSCTXT
C                                     --> PSCTXT
C                                     --> PINGBX  --> (as above)
C                                     --> PSDASH
C                                     --> PSLINE
C                                     --> PLTPTS  --> SHSORT
C                                                 --> PSLWID
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSLWID
C                                                 --> PSCCOL
C                                                 --> PSCSHD
C                                                 --> PSCIRC
C                                                 --> PSCTXT
C                                     --> PINRNO  --> PSCTXT
C                                                 --> PSLINE
C                                     --> PINTIC  --> PSLWID
C                                                 --> PSLINE
C                                     --> SYMKEY  --> (as above)
C                                     --> PLEXCL  --> PSTEXT
C
C--------------------------------------------------------------------------
      
      
      PROGRAM VPLOT
      
      INCLUDE 'vplot.inc'

      INTEGER       MAXCON, NFILE, PLTYPE,
     -              SINDEX(2 * MXCONS)
      REAL          ACDIST(MAXARR), VIOLAT(MAXARR)
      
C---- Initialise variables
      CALL INITS(ACDIST,VIOLAT)
CHECK v.3.5.4-->
      PLTYPE = 0
CHECK v.3.5.4<--
      IF (IFAIL) GO TO 999
      
C---- Request the name of the original PDB file
      CALL GETOUT
      IF (IFAIL) GO TO 999

C---- Read in the program parameters
      CALL PARAMS
      IF (IFAIL) GO TO 999

C---- Read in the last-used plot-number for the PostScript files
      CALL GETPSN(IPLOT)

C---- Read in all the filenames and plot attributes from the mplot.in
C     file, and store the details
      CALL GETFIL(NFILE)
      IF (IFAIL) GO TO 999
      MAXCON = MAXARR / (NFILE + 2)
      IF (MAXCON.GT.MXCONS) MAXCON = MXCONS
      NMODEL = NFILE

C---- Read in the model- and residue-ranges in the supplied ranges file,
C     if there is one
      IF (HAVRAN) THEN
          CALL GETRNG(FILRNG,MODFRM,MODTO,RESFRM,RESTO,MAXRNG,MRANGE,
     -        NRANGE,BOTHND,IFAIL)
          IFAIL = .FALSE.

C----     Check whether the user has selected a range of residues
          IF (RESFRM(1).NE.'*ALL  ') RSELEC = .TRUE.
      ENDIF

C---- If this is an NMR structure, then find which of the files
C     contain the wanted models
      IF (NMR) THEN
          CALL GETWNT(MXFILE,NFILE,FILRIN,FFILE,MAXRNG,MODFRM,
     -        MODTO,MRANGE,RSELEC,MWANT,NMODEL,MODNUM,ACTNUM,TOPMOD,
     -        TITLE,NAMLEN,TLEN,IFAIL)
          IF (IFAIL) GO TO 999

C---- Model ranges only apply to NMR ensembles, so set to default
C     if this is not an NMR structure
      ELSE
          MRANGE = 1
          MODFRM(MRANGE) = -99999
          MODTO(MRANGE) = 99999
      ENDIF

C---- Read in the data from the .rin files
      CALL GETVAL(NFILE)
      IF (IFAIL) GO TO 999

C---- Open the input calculated data file
      CALL OPNEDT
      IF (IFAIL) GO TO 999

C---- Read in the distance restraints from the Aqua output files
      CALL GETCON(ACDIST,VIOLAT,NFILE,MAXCON)
      IF (IFAIL) GO TO 999

C---- Read in the torsion angle restraints from the Aqua output files
      CALL GETORS(NFILE)
      IF (IFAIL) GO TO 999
      IF (TCONST + ACONST.EQ.0) THEN
          PRINT*, '*'
          PRINT*, '**** No restraints found, so no restraint plots wil',
     -        'l be produced'
          GO TO 999
      ENDIF

C---- Presort all the restraints
      CALL PRESRT(MAXCON,SINDEX)

C---- Produce the restraint plot showing all individual restraints and
C     their violations
      PLTYPE = PLTYPE + 1
      IF (PLOTRS) THEN
          CALL RSTPLT(PLTYPE,ACDIST,VIOLAT,NFILE,MAXCON,SINDEX)
      ENDIF

C---- Produce the restraint differences plot showing the differences
C     between the actual distances and upper- or lower-bound restraints
      PLTYPE = PLTYPE + 1
      IF (PLOTRD) THEN
          CALL RSTPLT(PLTYPE,ACDIST,VIOLAT,NFILE,MAXCON,SINDEX)
      ENDIF

C---- Plot numbers of distance restraints information 
      PLTYPE = PLTYPE + 1
      IF (PLOTSM .OR. PLOTST) THEN
          CALL RSUMPL(PLTYPE,ACDIST,NFILE,MAXCON,PLOTSM)
          IF (IFAIL) GO TO 999
      ENDIF

C---- Plot (actual distance - restraint) summary information 
      PLTYPE = PLTYPE + 1
      IF (PLOTSD) THEN
          CALL RSUMPL(PLTYPE,ACDIST,NFILE,MAXCON,PLOTSD)
          IF (IFAIL) GO TO 999
      ENDIF

C---- Plot histogram of violation frequency (ie numbers of restraints
C     with zero, 1, 2, etc violations in the ensemble)
      PLTYPE = PLTYPE + 1
      IF (PLOTVF .AND. NMODEL.GT.1) THEN
          CALL RSUMPL(PLTYPE,ACDIST,NFILE,MAXCON,PLOTVF)
          IF (IFAIL) GO TO 999
      ENDIF

C---- Print and plot the restraint statistics
      PLTYPE = PLTYPE + 1
CHECK v.3.4.3-->
C      IF (PLOTST) CALL RSTATS(PLTYPE,NFILE,MAXCON)
      IF (PLOTST) CALL RSTATS(PLTYPE)
CHECK v.3.4.3<--
      IF (IFAIL) GO TO 999

C---- Produce the restraint spans plot
      PLTYPE = PLTYPE + 1
      CALL OPTSET
      IF (PLOTSP) CALL RSPANS(PLTYPE,ACDIST,VIOLAT,NFILE,MAXCON)

C---- Produce the residue-by-residue restraint violations plot
      PLTYPE = PLTYPE + 1
      IF (PLOTVI) CALL PINVIO(PLTYPE,ACDIST,VIOLAT,SINDEX,NFILE,MAXCON)

C---- Plot the model-by-model violations
      PLTYPE = PLTYPE + 1
      IF (PLOTMD) CALL MODELC(PLTYPE,ACDIST,VIOLAT,SINDEX,NFILE,MAXCON)

 999  CONTINUE
      IF (IFAIL) THEN
         PRINT*, '**** Program terminated with error'
      ELSE 
         PRINT*, 'Program complete'
      ENDIF
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE INITS  -  Initialise variables
C     
C----------------------------------------------------------------------+---
      
      SUBROUTINE INITS(ACDIST,VIOLAT)
      
      INCLUDE 'vplot.inc'
      
      CHARACTER*3   AMNAME(NAMINO)
      INTEGER       I, IAMINO, IBLOCK, ICTYPE, IFILE, IGFACT, IPROPT,
     -              IQUALP, IRES, ITORS, LMSTYP
      REAL          ACDIST(MAXARR), VIOLAT(MAXARR)

      DATA AMNAME /'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -             'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -             'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

C---- Initialise variables
      DO 50, IAMINO = 1, NAMINO
          AMINO(IAMINO) = AMNAME(IAMINO)
 50   CONTINUE
      ASTSTR = 0
      AVESTR = 0
      BOTHND = .FALSE.
      DO 60, I = 1, NPLOT
          BSHADE(I) = .TRUE.
          INCOLR(I) = .FALSE.
 60   CONTINUE
      CHAIN = ' '
      COMBPS = .FALSE.
      ENASTR = 0
      ENSEMB = .FALSE.
      FFILE = 1
      FSTRES = 1
      HAVANG = .FALSE.
      HAVRAN = .FALSE.
      IFAIL = .FALSE. 
      INCLUL = .TRUE.
      INCLUM = .TRUE.
      INCLUS = .TRUE.
      IPLOT = 0
      DO 100, IQUALP = 1, NQUALP
          MEAVAL(IQUALP) = 0.0
          DO 80, IFILE = 1, MXFILE
              NVALUE(IQUALP,IFILE) = 0
              SVALUE(IQUALP,IFILE) = 0.0
 80       CONTINUE
 100  CONTINUE
      MAXLEN = 0
      MINLEN = 0
      MRANGE = 1
      MODFRM(MRANGE) = -99999
      MODTO(MRANGE) = 99999
      DO 110, IFILE = 1, MXFILE
          MODNUM(IFILE) = IFILE
          ACTNUM(IFILE) = IFILE
          MWANT(IFILE) = .TRUE.
 110  CONTINUE
      NATTYP = 0
      NRANGE = 1
      RESFRM(NRANGE) = '*ALL  '
      RESTO(NRANGE) = 'XXXXXX'
      NFOUND = 0
      NLABEL = 0
      NMR = .TRUE.
      DO 250, ICTYPE = 1, NCTYPE
          DO 240, LMSTYP = 1, 3
              DO 220, IBLOCK = 1, 4
                  RCOUNT(IBLOCK,LMSTYP,ICTYPE) = 0
 220          CONTINUE
 240      CONTINUE
 250  CONTINUE
      NRES = 0
      OOIMAX = 0
      OOIMIN = 999
      DO 500, IRES = 1, MXRES
          AVRACC(IRES) = 0.0
          CHNBRK(IRES) = ' '
          DO 320, I = 1, NDISTR
              CIRCVR(I,IRES) = 0.0
 320      CONTINUE
          CONSST(IRES) = ' '
          DO 340, IGFACT = 1, NGFACT + 1
              GFACT(IGFACT,IRES) = 999.9
 340      CONTINUE
          DOUBL(IRES) = .FALSE.
          NOOI(IRES) = 0
          NXTRES(IRES) = 0
          SSTCNT(1,IRES) = 0
          SSTCNT(2,IRES) = 0
          SSTCNT(3,IRES) = 0
          VALOOI(IRES) = 0.0
          VALRES(IRES) = ' '
          VALSNO(IRES) = ' '
          DO 400, IFILE = 1, MXFILE
              RESMOD(IRES,IFILE) = .FALSE.
              SAVOOI(IRES,IFILE) = 0.0
              STOSST(IRES,IFILE) = ' '
              DO 360, IPROPT = 1, NPROPT
                  VALUE(IPROPT,IRES,IFILE) = 999.9
 360          CONTINUE
 400      CONTINUE
          DO 440, ITORS = 1, MXTORS
              DIHCON(1,ITORS,IRES) = 999.9
              DIHCON(2,ITORS,IRES) = 999.9
              DVIOL(ITORS,IRES) = 0
              DO 420, IFILE = 1, MXFILE
                  DVIOLM(ITORS,IRES,IFILE) = -999.9
 420          CONTINUE
 440      CONTINUE
 500  CONTINUE
      PINDMX = 0.0
      RSELEC = .FALSE.
      DO 600, I = 1, MXPLOT
          PINMAX(I) = 0.0
          PLTSTD(I) = 0.0
 600  CONTINUE
      HISTOG = .TRUE.
      DO 680, IFILE = 1, MXFILE + 1
          DO 660, IRES = 1, MXRES + 1
              SCOMOD(IRES,IFILE) = 0.0
              NUMSCO(IRES,IFILE) = 0
 660      CONTINUE
 680  CONTINUE
      WITHAN = .FALSE.
      DO 750, IRES = 1, MXRES
          RMSALL(1,IRES) = 0.0
          RMSALL(2,IRES) = 0.0
          RMSALL(3,IRES) = 0.0
          DO 720, IFILE = 1, MXFILE
              RMSDEV(1,IRES,IFILE) = 0.0
              RMSDEV(2,IRES,IFILE) = 0.0
              RMSDEV(3,IRES,IFILE) = 0.0
 720      CONTINUE
 750  CONTINUE

C---- Initialise the violations array
      DO 800, I = 1, MAXARR
          ACDIST(I) = 0.0
          VIOLAT(I) = 0.0
 800  CONTINUE

      RETURN
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETOUT  -  Read in the name out the output file and the
C                        chain
C
C----------------------------------------------------------------------+--- 
 
      SUBROUTINE GETOUT
 
      INCLUDE 'vplot.inc'
 
      CHARACTER*1   LOWERA
      CHARACTER*26  UPPER
      INTEGER       LINE, N
      LOGICAL       IERROR

      DATA  LOWERA / 'a' /
      DATA  UPPER  / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /

C---- Initialise variables
      LINE = 0

C---- Accept name of output file
      PRINT*, 'Enter name of input PDB file'
      PRINT*, '  (or, for a list of files, enter %filelist, where',
     -    ' filelist'
      PRINT*, '   contains the PDB filenames)'
      READ(*,110,ERR=900) PDBFIL
 110  FORMAT(A)
      IF (PDBFIL(1:1).EQ.'%') THEN
          PDBFIL = PDBFIL(2:)
          ENSEMB = .TRUE.
          NMR = .FALSE.
      ENDIF

C---- Peel off directory path and extension
      CALL GETNAM(PDBFIL,ISTART,IEND,IERROR)
      IF (IERROR) GO TO 990

C---- Form names of other files that will be required in default directory
      PSLEN = IEND - ISTART + 1
      BRCALL = PDBFIL(ISTART:IEND)
      FILPS = BRCALL
      TITLE = BRCALL
      FILEDT = PDBFIL(ISTART:IEND) // '.edt'
      FILRMS = PDBFIL(ISTART:IEND) // '.rms'
      FILTOR = PDBFIL(ISTART:IEND) // '.tor'
      FILVIO(1) = PDBFIL(ISTART:IEND) // '.nrv'
      FILVIO(2) = PDBFIL(ISTART:IEND) // '.hrv'
      FILVIO(3) = PDBFIL(ISTART:IEND) // '.srv'

C---- Accept chain-ID
      PRINT*, 'Enter required chain-ID, or leave blank for all'
      READ(*,110,ERR=904) CHAIN

C---- Convert chain ID to upper-case if necessary
      N = ICHAR(CHAIN) - ICHAR(LOWERA) + 1
      IF (N.GE.1 .AND. N.LE.26) CHAIN = UPPER(N:N)

C---- Add chain identifier to plot headings
      TLEN = PSLEN
      IF (CHAIN.NE.' ' .AND. PSLEN.LT.30) THEN
          TITLE = TITLE(1:PSLEN) // ' - Chain ' // CHAIN
          TLEN = TLEN + 10
      ENDIF
      IF (TLEN.GT.78) TLEN = 78
      NAMLEN = TLEN

C---- Read in (optional) name of ranges file
      PRINT*, 'Enter name of ranges file (blank if none)'
      READ(*,110,ERR=900) FILRNG
      IF (FILRNG.EQ.' ') THEN
          HAVRAN = .FALSE.
      ELSE
          HAVRAN = .TRUE.
      ENDIF

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** ERROR. Data error in entered filename'
      GO TO 990

 904  CONTINUE
      PRINT*, '**** ERROR. Data error in entered title'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.
 
999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PARAMS  -  Read in program parameters from parameter file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PARAMS

      INCLUDE 'vplot.inc'

      CHARACTER*1   YESNO
      CHARACTER*80  FNAME, IREC
CHECK v.3.4.3-->
C      INTEGER       I, ICLASS, ICOL, IP, LINE, LOCATN(MXPLOT), PLTYPE
      INTEGER       I, ICLASS, ICOL, IP, LINE, PLTYPE
CHECK v.3.4.3<--
      LOGICAL       ALLCOL, ENDCOL, FINERR

CHECK v.3.4.3-->
C      DATA LOCATN / LOCHI1, LOCOME, LOCZET /
CHECK v.3.4.3<--

C---- Open parameter file
      IF (NMR) THEN
          FNAME = 'procheck_nmr.prm'
      ELSE
          FNAME = 'procheck_comp.prm'
      ENDIF
      OPEN(UNIT=10, FILE=FNAME, STATUS='OLD',
     -     FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)
      FINERR = .FALSE.
      LINE = 0

C---- Read in the parameters

C---- Check that have the right version number in the parameter file
      IF (NMR) THEN
          CALL FINKEY('PROCHECK-NMR. PROCHECK v.3.4',28,LINE,FINERR)
      ELSE
          CALL FINKEY('PROCHECK-COMP. PROCHECK v.3.4',29,LINE,FINERR)
      ENDIF
      IF (FINERR) GO TO 901

C---- Find the colours key-word
      CALL FINKEY('Colours',7,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Read in all the RGB colours and corresponding colour names
      ENDCOL = .FALSE.
      NCOLOR = MXCOLR
      DO 100, ICOL = 1, MXCOLR
          IF (.NOT.ENDCOL) THEN
              LINE = LINE + 1
              READ(10,20,END=902,ERR=904) IREC
 20           FORMAT(A)
              IF (IREC.EQ.' ') THEN
                  ENDCOL = .TRUE.
              ELSE
                  READ(IREC,*,ERR=904) (RGB(I,ICOL), I = 1, 3),
     -                COLNAM(ICOL)
                  NCOLOR = ICOL
              ENDIF
          ENDIF

C----     If have reached end of colours then insert default
          IF (ENDCOL) THEN
              RGB(1,ICOL) = 0.0
              RGB(2,ICOL) = 0.0
              RGB(3,ICOL) = 0.0
              COLNAM(ICOL) = 'WHITE'
          ENDIF
 100  CONTINUE

C---- Determine whether all plots are to be in colour

C---- Find the colour-all-plots keywords
      CALL FINKEY('Colour all plots?',17,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Determine whether all plots are to be in colour
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
 120  FORMAT(A)
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          ALLCOL = .TRUE.
      ELSE
          ALLCOL = .FALSE.
      ENDIF

C---- Determine which plots are to be produced

C---- Find the appropriate keyword
      CALL FINKEY('b. Restraint analyses',22,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Read in whether the Distance Restraints plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTRS = .TRUE.
      ELSE
          PLOTRS = .FALSE.
      ENDIF

C---- Read in whether the Restraint Differences plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTRD = .TRUE.
      ELSE
          PLOTRD = .FALSE.
      ENDIF

C---- Read in whether the Numbers of Distance Restraints Summary plot
C     is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTSM = .TRUE.
      ELSE
          PLOTSM = .FALSE.
      ENDIF

C---- Read in whether the Numbers of Distance Restraints Summary plot
C     is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTSD = .TRUE.
      ELSE
          PLOTSD = .FALSE.
      ENDIF

C---- Read in whether the Violations Frequency plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTVF = .TRUE.
      ELSE
          PLOTVF = .FALSE.
      ENDIF

C---- Read in whether the Restraint Statistics are required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTST = .TRUE.
      ELSE
          PLOTST = .FALSE.
      ENDIF

C---- Read in whether the restraint spans plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTSP = .TRUE.
      ELSE
          PLOTSP = .FALSE.
      ENDIF

C---- Read in whether the residue-by-residue restraint violations plot
C     is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTVI = .TRUE.
      ELSE
          PLOTVI = .FALSE.
      ENDIF

C---- Read in whether the model-by-model comparisons plot is required
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTMD = .TRUE.
      ELSE
          PLOTMD = .FALSE.
      ENDIF

C---- Read in the general parameters for the restraint analyses

C---- Find the appropriate keyword
      CALL FINKEY('General parameters',18,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Read in whether short, medium and long-range restraints are to be
C     defined in terms of diatances, rather than residue separation
      LINE = LINE + 1
      READ(10,120,END=902,ERR=904) YESNO
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          DCLASS = .TRUE.
      ELSE
          DCLASS = .FALSE.
      ENDIF

C---- If distance ranges are required, then read in the values
      IF (DCLASS) THEN
          DO 150, ICLASS = 1, 3
              LINE = LINE + 1
              READ(10,*,END=902,ERR=904) CLASS(1,ICLASS),
     -            CLASS(2,ICLASS)
 150      CONTINUE

C---- Otherwise, just skip these lines
      ELSE
          DO 160, ICLASS = 1, 3
              LINE = LINE + 1
              READ(10,*,END=902,ERR=904)
 160      CONTINUE
      ENDIF

C---- Read in the different colours for these restraint-range types
      DO 180, ICOL = 1, 3
          CALL GETCOL(COLPNT(ICOL),LINE,COLNAM,MXCOLR)
 180  CONTINUE

C---- Read in the plot parameters for each individual plot
      PLTYPE = 0

C---- Plots 13-14
      PLTYPE = PLTYPE + 1
      IF (PLOTRS .OR. PLOTRD) THEN

C----     Find the plot's identifying key-words
          CALL FINKEY('13-14. Distance restraints',26,LINE,FINERR)
          IF (FINERR) GO TO 990

C----     Include short-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLUS = .TRUE.
          ELSE
              INCLUS = .FALSE.
          ENDIF

C----     Include medium-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLUM = .TRUE.
          ELSE
              INCLUM = .FALSE.
          ENDIF

C----     Include long-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLUL = .TRUE.
          ELSE
              INCLUL = .FALSE.
          ENDIF

C----     NOE restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPENO = .TRUE.
          ELSE
              TYPENO = .FALSE.
          ENDIF

C----     H-bond restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPEHB = .TRUE.
          ELSE
              TYPEHB = .FALSE.
          ENDIF

C----     Disulphide restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPESS = .TRUE.
          ELSE
              TYPESS = .FALSE.
          ENDIF

C----     Show only violated restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              VIONLY = .TRUE.
          ELSE
              VIONLY = .FALSE.
          ENDIF

C----     Exclude duplicate restraints within the same residue (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              EXDUPL = .TRUE.
          ELSE
              EXDUPL = .FALSE.
          ENDIF

C----     Background shading (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              BSHADE(PLTYPE) = .TRUE.
          ELSE
              BSHADE(PLTYPE) = .FALSE.
          ENDIF
          BSHADE(PLTYPE + 1) = BSHADE(PLTYPE)

C----     Produce a black-and-white or colour PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCOLR(PLTYPE) = .TRUE.
          ELSE
              INCOLR(PLTYPE) = .FALSE.
          ENDIF
          INCOLR(PLTYPE + 1) = INCOLR(PLTYPE)

C----     Get each of the user-defined colours for this plot
          DO 200, ICOL = 1, 4
              CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
              COLPLT(ICOL,PLTYPE + 1) = COLPLT(ICOL,PLTYPE)
 200      CONTINUE
      ENDIF
      PLTYPE = PLTYPE + 1

C---- Plots 15-17
      PLTYPE = PLTYPE + 1
CHECK v.3.4.3-->
C      IF (PLOTSM) THEN
      IF (PLOTSD .OR. PLOTSM .OR. PLOTVF) THEN
CHECK v.3.4.3<--

C----     Find the plot's identifying key-words
          CALL FINKEY('15-17. Summaries',16,LINE,FINERR)
          IF (FINERR) GO TO 990

C----     Separate page for each graph (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              SUMSEP = .TRUE.
          ELSE
              SUMSEP = .FALSE.
          ENDIF

C----     Background shading (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              BSHADE(PLTYPE) = .TRUE.
          ELSE
              BSHADE(PLTYPE) = .FALSE.
          ENDIF
          BSHADE(PLTYPE + 1) = BSHADE(PLTYPE)
          BSHADE(PLTYPE + 2) = BSHADE(PLTYPE)

C----     Produce a black-and-white or colour PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCOLR(PLTYPE) = .TRUE.
          ELSE
              INCOLR(PLTYPE) = .FALSE.
          ENDIF
          INCOLR(PLTYPE + 1) = INCOLR(PLTYPE)
          INCOLR(PLTYPE + 2) = INCOLR(PLTYPE)

C----     Get each of the user-defined colours for this plot
          DO 300, ICOL = 1, 6
              CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
              COLPLT(ICOL,PLTYPE + 1) = COLPLT(ICOL,PLTYPE)
              COLPLT(ICOL,PLTYPE + 2) = COLPLT(ICOL,PLTYPE)
 300      CONTINUE
      ENDIF
      PLTYPE = PLTYPE + 2

C---- Plot 18
      PLTYPE = PLTYPE + 1
      IF (PLOTST) THEN

C----     Find the plot's identifying key-words
          CALL FINKEY('18. Restraint statistics',24,LINE,FINERR)
          IF (FINERR) GO TO 990

C----     Produce a black-and-white or colour PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCOLR(PLTYPE) = .TRUE.
          ELSE
              INCOLR(PLTYPE) = .FALSE.
          ENDIF

C----     Get each of the user-defined colours for this plot
          DO 400, ICOL = 1, 5
              CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
 400      CONTINUE
      ENDIF

C---- Plots 19-21
      PLTYPE = PLTYPE + 1
      IF (PLOTSP .OR. PLOTVI .OR. PLOTMD) THEN

C----     Find the plot's identifying key-words
          CALL FINKEY('19-21. Restraint spans',22,LINE,FINERR)
          IF (FINERR) GO TO 990

C----     Include short-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLS1 = .TRUE.
          ELSE
              INCLS1 = .FALSE.
          ENDIF

C----     Include medium-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLM1 = .TRUE.
          ELSE
              INCLM1 = .FALSE.
          ENDIF

C----     Include long-range restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCLL1 = .TRUE.
          ELSE
              INCLL1 = .FALSE.
          ENDIF

C----     NOE restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPEN1 = .TRUE.
          ELSE
              TYPEN1 = .FALSE.
          ENDIF

C----     H-bond restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPEH1 = .TRUE.
          ELSE
              TYPEH1 = .FALSE.
          ENDIF

C----     Disulphide restraints (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              TYPES1 = .TRUE.
          ELSE
              TYPES1 = .FALSE.
          ENDIF

C----     Background shading (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              BSHADE(PLTYPE) = .TRUE.
          ELSE
              BSHADE(PLTYPE) = .FALSE.
          ENDIF
          BSHADE(PLTYPE + 1) = BSHADE(PLTYPE)
          BSHADE(PLTYPE + 2) = BSHADE(PLTYPE)

C----     Shading showing estimated accessibility (Y/N)?
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              SHOWAC = .TRUE.
          ELSE
              SHOWAC = .FALSE.
          ENDIF
          SHOWMA = SHOWAC

C----     Produce a black-and-white or colour PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              INCOLR(PLTYPE) = .TRUE.
          ELSE
              INCOLR(PLTYPE) = .FALSE.
          ENDIF
          INCOLR(PLTYPE + 1) = INCOLR(PLTYPE)
          INCOLR(PLTYPE + 2) = INCOLR(PLTYPE)

C----     Get each of the user-defined colours for this plot
          DO 460, ICOL = 1, 10
              CALL GETCOL(COLPLT(ICOL,PLTYPE),LINE,COLNAM,MXCOLR)
              COLPLT(ICOL,PLTYPE + 1) = COLPLT(ICOL,PLTYPE)
              COLPLT(ICOL,PLTYPE + 2) = COLPLT(ICOL,PLTYPE)
 460      CONTINUE
      ENDIF
      PLTYPE = PLTYPE + 2

C---- General plot parameters

C---- Find whether file-handles are required or not
      CALL FINKEY('File-handles',12,LINE,FINERR)
      IF (.NOT.FINERR) THEN

C----     See whether the file-handle is required
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              WITHAN = .TRUE.
          ELSE
              WITHAN = .FALSE.
          ENDIF

C----     See whether plot filename to be printed on the plot itself
          LINE = LINE + 1
          READ(10,*,END=902,ERR=904)
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              PLABEL = .TRUE.
          ELSE
              PLABEL = .FALSE.
          ENDIF

C----     See whether all pages of same plot to be combined in one
C         paginated PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              COMBPS = .TRUE.
          ELSE
              COMBPS = .FALSE.
          ENDIF
      ENDIF

C---- If all plots are required to be in colour, then set all the
C     appropriate flags to TRUE
      IF (ALLCOL) THEN
          DO 600, IP = 1, NPLOT
              INCOLR(IP) = .TRUE.
 600      CONTINUE
      ENDIF

      GO TO 999


C---- Errors reading parameter file
900   CONTINUE
      IF (NMR) THEN
          PRINT*, '*** ERROR Parameters file (procheck_nmr.prm) not ',
     -        'found.'
      ELSE
          PRINT*, '*** ERROR Parameters file (procheck_comp.prm) not ',
     -        'found.'
      ENDIF
      GO TO 990

 901  CONTINUE
      IF (NMR) THEN
          PRINT*, '*** Old version of parameter file, ',
     -        'procheck_nmr.prm, found'
      ELSE
          PRINT*, '*** Old version of parameter file, ',
     -        'procheck_comp.prm, found'
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'
      GO TO 990

902   CONTINUE
      IF (NMR) THEN
          PRINT*, '*** Premature end in parameter file, ',
     -        'procheck_nmr.prm, at line', LINE
      ELSE
          PRINT*, '*** Premature end in parameter file, ',
     -        'procheck_comp.prm, at line', LINE
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'
      GO TO 990

904   CONTINUE
      IF (NMR) THEN
          PRINT*, '*** Error reading parameter file, ',
     -        'procheck_nmr.prm, at line', LINE
      ELSE
          PRINT*, '*** Error reading parameter file, ',
     -        'procheck_comp.prm, at line', LINE
      ENDIF
      PRINT*, '*** Please delete the file and re-run the program'
      PRINT*, '*** ---------------------------------------------'

      GO TO 990

C---- Close the parameter file
 990  CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE GETFIL  -  Read through the list of files in mplot.in,
C                        picking up information about each one (such
C                        as x-coord, marker-type, label, etc)
C
C----------------------------------------------------------------------+---
      
      SUBROUTINE GETFIL(NFILE)
      
      INCLUDE 'vplot.inc'
      
      CHARACTER*3   NUMSTR
      CHARACTER*10  NAME
      CHARACTER*80  FNAME
      INTEGER       IPOS, MARKER, NFILE
      REAL          NUMBER
      
C---- Initialise variables
      NFILE = 0
      PRINT*
      PRINT*, 'Reading in data ...'
      PRINT*
      RESOL(1) = 2.5

C---- Open input file, mplot.in
      OPEN(UNIT=2, FILE='mplot.in', STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)
      
C---- Read through the file
 100  CONTINUE
      
C----     Read in the next filename
          READ(2,20,END=500,ERR=902) FNAME
 20       FORMAT(A)
          IF (FNAME(1:1).EQ.' ') GO TO 100
          NFILE = NFILE + 1
          IF (NFILE.GT.MXFILE) GO TO 908

C----     Search the line for an x-axis value and description
          NUMBER = NFILE
          CALL GETNOD(FNAME,NUMBER,NAME,MARKER,NLABEL,IEND,NFOUND,
     -        ASTSTR,AVESTR,ENASTR)
          MKNAME(NFILE) = NAME
          MKTYPE(NFILE) = MARKER
          XVALUE(NFILE) = NUMBER
          RESOL(NFILE) = NUMBER

C----     Store maximum and minimum values
          IF (NFILE.EQ.1) THEN
              MINX = NUMBER
              MAXX = NUMBER
          ELSE
              MINX = MIN(NUMBER,MINX)
              MAXX = MAX(NUMBER,MAXX)
          ENDIF

C----     Peel off directory path and extension
          PDBFIL = FNAME(1:IEND)
          CALL GETNAM(PDBFIL,ISTART,IEND,IFAIL)
          IF (IFAIL) GO TO 999
      
C----     Form names of other files that will be required in default directory
          ILEN = IEND - ISTART + 1
          BRCODE(NFILE) = PDBFIL(ISTART:IEND)
          FILRIN(NFILE) = PDBFIL(1:IEND) // '.rin'

C----     Store identifying code
          LENID(NFILE) = IEND - ISTART + 1
          IF (LENID(NFILE).GT.MXLEND) THEN
              LENID(NFILE) = MXLEND
              FILID(NFILE) = PDBFIL(IEND - MXLEND + 1:IEND)
          ELSE
              FILID(NFILE) = PDBFIL(ISTART:IEND)
          ENDIF

      GO TO 100

C---- Close the mplot.in file
 500  CONTINUE
      CLOSE(2)
      IF (NFILE.EQ.0) GO TO 910
      NMODEL = NFILE

C---- Add number of models to plot title
      IF (TLEN.LT.65) THEN
          WRITE(NUMSTR,520) NFILE
 520      FORMAT(I3)
          IPOS = 1
          IF (NUMSTR(1:1).EQ.' ') IPOS = 2
          IF (NUMSTR(2:2).EQ.' ') IPOS = 3
          TITLE = TITLE(1:TLEN) // ' (' // NUMSTR(IPOS:) // ' models)'
          TLEN = TLEN + 14 - IPOS
      ENDIF

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** Unable to open input file, mplot.in'
      GO TO 990
 
 902  CONTINUE
      PRINT*, '**** File error reading file mplot.in at line',
     -    NFILE + 1
      GO TO 990
 
 908  CONTINUE
      PRINT*, '**** Maximum number of files exceeded. Amend parameter ',
     -    'MXFILE =', MXFILE
      GO TO 990
 
 910  CONTINUE
      PRINT*, 'No files found in mplot.in list'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.
 
 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C  SUBROUTINE GETNOD  -  Search for an x-axis value, protein description and
C                        marker-type at the end of the line containing the
C                        name of the .rin file
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE GETNOD(INLINE,NUMBER,NAME,MARKER,NLABEL,IEND,NFOUND,
     -    ASTSTR,AVESTR,ENASTR)

      SAVE

      INTEGER       MXLET
      PARAMETER    (MXLET = 10)

      CHARACTER*1   CQUOTE, DQUOTE, INCHAR, QUOTE
      CHARACTER*(MXLET) NAME
      CHARACTER*20  CHNUMB
      CHARACTER*80  INLINE
      INTEGER       ASTSTR, AVESTR, ENASTR, CURMRK, IEND, IFROM, ILET,
     -              INUM, IPOS, ISTATE, ITO, MARKER, NDECPT,
     -              NFILE, NFOUND, NLABEL, RERROR
      REAL          NUMBER, VALUE

      DATA CURMRK / 1 /
      DATA DQUOTE, QUOTE / '"', '''' /

C---- Initialise variables
      IEND = 80
      ITO = IEND
      IPOS = 0
      MARKER = CURMRK
      NAME = ' '
      NFILE = NUMBER

C---- Find where the file-name ends
 100  CONTINUE
          IPOS = IPOS + 1
          IF (INLINE(IPOS:IPOS).EQ.' ') THEN
              IEND = IPOS - 1
              GO TO 200
          ENDIF
      IF (IPOS.LT.IEND) GO TO 100

C---- No end to filename found, so no other details located
      GO TO 999

C---- End of filename located
 200  CONTINUE
      IFROM = IEND + 1

C---- Initialise variables
      ISTATE = 1
      IPOS = IFROM - 1

C---- Loop through remaining positions in the line for any marker types,
C     labels, or x-positions
 300  CONTINUE
          IPOS = IPOS + 1
          INCHAR = INLINE(IPOS:IPOS)

C----     State 1 - Searching for M, A, E, opening quote, or number
          IF (ISTATE.EQ.1) THEN

C----         Check whether this is one of the characters of interest
              IF (INCHAR.EQ.QUOTE .OR. INCHAR.EQ.DQUOTE) THEN
                  ISTATE = 2
                  ILET = 0
                  CQUOTE = INCHAR
                  NAME = ' '
              ELSE IF (INCHAR.EQ.'*') THEN
                  ASTSTR = NFILE
              ELSE IF (INCHAR.EQ.'A' .OR. INCHAR.EQ.'a') THEN
                  AVESTR = NFILE
              ELSE IF (INCHAR.EQ.'E' .OR. INCHAR.EQ.'e') THEN
                  ENASTR = NFILE
              ELSE IF (INCHAR.EQ.'M' .OR. INCHAR.EQ.'m') THEN
                  ISTATE = 3
              ELSE IF ((INCHAR.LE.'9' .AND. INCHAR.GE.'0') .OR.
     -            INCHAR.EQ.'-') THEN
                  ISTATE = 4
                  CHNUMB = INCHAR
                  NDECPT = 0
                  INUM = 1
              ELSE IF (INCHAR.EQ.'.') THEN
                  ISTATE = 4
                  CHNUMB = '0.'
                  NDECPT = 1
                  INUM = 2
              ENDIF

C----     State 2 - Storing label text (up to maximum of 10 chars), while
C                   waiting for closing quotes
          ELSE IF (ISTATE.EQ.2) THEN

C----         Check for closing quote
              IF (INCHAR.EQ.CQUOTE) THEN
                  ISTATE = 1
                  IF (ILET.GT.0) NLABEL = NLABEL + 1

C----         Otherwise, store the character
              ELSE
                  ILET = ILET + 1
                  IF (ILET.LE.MXLET) THEN
                      NAME(ILET:ILET) = INCHAR
                  ENDIF
              ENDIF

C----     State 3 - Determining what required the marker type is
          ELSE IF (ISTATE.EQ.3) THEN
              IF (INCHAR.LE.'9' .AND. INCHAR.GE.'1') THEN
                  READ(INCHAR,320) MARKER
 320              FORMAT(I1)
                  CURMRK = MARKER
              ENDIF
              ISTATE = 1

C----     State 4 - Storing characters making up the number representing
C                   x-axis value
          ELSE IF (ISTATE.EQ.4) THEN
              IF (INCHAR.EQ.' ') THEN
                  IF (NDECPT.EQ.0 .AND. INUM.LT.20) THEN
                      CHNUMB(INUM+1:INUM+1) = '.'
                  ENDIF
                  CALL READCH(CHNUMB,VALUE,RERROR)
                  IF (RERROR.EQ.0) THEN
                      NUMBER = VALUE
                      NFOUND = NFOUND + 1
                  ENDIF
                  ISTATE = 1
              ELSE IF (INCHAR.EQ.'.') THEN
                  INUM = INUM + 1
                  IF (INUM.LE.20) CHNUMB(INUM:INUM) = INCHAR
                  NDECPT = 1
              ELSE IF (INCHAR.LE.'9' .AND. INCHAR.GE.'0') THEN
                  INUM = INUM + 1
                  IF (INUM.LE.20) CHNUMB(INUM:INUM) = INCHAR
              ENDIF
          ENDIF

      IF (IPOS.LT.ITO) GO TO 300

 999  CONTINUE
      RETURN
      END

C----------------------------------------------------------------------+--- 
C**************************************************************************
C
C  SUBROUTINE READCH  -  Routine to convert character string to real number
C
C--------------------------------------------------------------------------
 
      SUBROUTINE READCH(NUMB,A,RERROR)

      CHARACTER*4   EXPO
      CHARACTER*20  NUMB
      REAL          A, RPOWER
      INTEGER       EPOS, IPOWER, RERROR

      RERROR = 0
      EPOS = INDEX(NUMB,'E')
      IF (EPOS.GT.0) THEN
          READ(NUMB(1:EPOS - 1),160,ERR=904) A
160       FORMAT(F20.0)
          EXPO = NUMB(EPOS + 1:)
          EPOS = INDEX(EXPO,' ')
          IF (EPOS.GT.0) EXPO(EPOS:EPOS) = '.'
          READ(EXPO,160,ERR=904) RPOWER
          IPOWER = RPOWER
          A = A * 10.0 ** IPOWER
      ELSE
          READ(NUMB,160,ERR=904) A
      ENDIF

      GO TO 999

904   CONTINUE
      RERROR = 1

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE OPNEDT  -   Open the input .edt file
C
C----------------------------------------------------------------------+---

      SUBROUTINE OPNEDT

      INCLUDE 'vplot.inc'

C---- Initialise variables
      IFAIL = .FALSE.

C---- Open the output .edt file
      OPEN(UNIT=13,FILE=FILEDT,STATUS='OLD',ERR=900,
CVAX     -     CARRIAGECONTROL='LIST',READONLY,
     -     FORM='FORMATTED',ACCESS='SEQUENTIAL')

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Unable to open output .edt file: '
      PRINT*, FILEDT(1:PSLEN), '*'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE GETVAL  -  Read through all the .rin files to pick up the
C                        data for the distributions
C
C----------------------------------------------------------------------+---
      
      SUBROUTINE GETVAL(NFILE)

      SAVE

      INCLUDE 'vplot.inc'

      CHARACTER*1   SECSTR(3)
      INTEGER       ICOL, IFILE, IMODEL, IRES, ISTRUC, MCOUNT,
     -              NFILE, TSTRUC
      LOGICAL       RESAME

      DATA SECSTR / 'H', 'E', 'C' / 

C---- Initialise valiables
      IMODEL = 0
      RESAME = .TRUE.

C---- Loop through all the .rin files
      DO 100, IFILE = 1, NFILE

C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN

C----         Read in the residue-by-residue torsion angle data from
C             the corresponding .rin file
              IMODEL = IMODEL + 1
              CALL GETRIN(IFILE,IMODEL)
              IF (IFAIL) GO TO 999
          ENDIF
 100  CONTINUE

C---- Show sequence statistics
      PRINT*
      PRINT 110, 'Ensemble comprises            ', NFILE, ' files'
      IF (NMODEL.LT.NFILE) THEN
          PRINT 110, '   Selected:                  ', NMODEL, ' models'
      ENDIF
 110  FORMAT(1X,A,I4,A)
      PRINT*
      PRINT 110, 'Minimum sequence length       ', MINLEN
      PRINT 110, 'Maximum sequence length       ', MAXLEN
      PRINT*
      PRINT 110, 'Total no. of unique residues  ', NRES
      PRINT*

C---- Adjust Ooi-number maximum and minimum if equal
      IF (OOIMAX.LE.OOIMIN) OOIMAX = OOIMIN + 1.0

C---- Determine the consensus secondary structure assignment for
C     each residue and calculate the accessibilities from the Ooi
C     numbers
      DO 200, IRES = 1, NRES
          MCOUNT = 0
          TSTRUC = 3

C----     Find which secondary structure type has been assigned most
C         often for this residue
          DO 150, ISTRUC = 1, 3
              IF (SSTCNT(ISTRUC,IRES).GT.MCOUNT) THEN
                  MCOUNT = SSTCNT(ISTRUC,IRES)
                  TSTRUC = ISTRUC
              ENDIF
 150      CONTINUE

C----     Store the consensus secondary structure type
          CONSST(IRES) = SECSTR(TSTRUC)

C----     Calculate the average Ooi value for this residue
          IF (NOOI(IRES).NE.0) THEN
              VALOOI(IRES) = VALOOI(IRES) / REAL(NOOI(IRES))
              VALOOI(IRES) = 100.0 * (OOIMAX - VALOOI(IRES))
     -            / (OOIMAX - OOIMIN)
              DO 180, IMODEL = 1, NMODEL
                  SAVOOI(IRES,IMODEL)
     -                = 100.0 * (OOIMAX - SAVOOI(IRES,IMODEL))
     -                / (OOIMAX - OOIMIN)
 180          CONTINUE
          ELSE
              VALOOI(IRES) = 0.0
          ENDIF
 200  CONTINUE

C---- Calculate mean values of the parameters
      DO 600, ICOL = 1, NQUALP
          MEAVAL(ICOL) = MEAVAL(ICOL) / REAL(NMODEL)

C----     Determine which value will be used for the plot statistics
          STATVL(ICOL) = MEAVAL(ICOL)
          IF (PLSTAT.EQ.2) THEN
              IF (AVESTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,AVESTR)
              ELSE
                  PRINT*, '**** Warning. "A" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
          IF (PLSTAT.EQ.3) THEN
              IF (ENASTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,ENASTR)
              ELSE
                  PRINT*, '**** Warning. "E" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
          IF (PLSTAT.EQ.4) THEN
              IF (ASTSTR.GT.0) THEN
                  STATVL(ICOL) = SVALUE(ICOL,ASTSTR)
              ELSE
                  PRINT*, '**** Warning. "*" structure not found ',
     -                'in mplot.in file. Plot statistics will be '
                  PRINT*, '**** for average of all structures'
                  PLSTAT = 1
              ENDIF
          ENDIF
 600  CONTINUE

C---- If not all resolutions are the same, then print warning message
      IF (.NOT.RESAME) THEN
          PRINT*
          PRINT*, '**** Warning. Resolution is not the same for all ',
     -        'files. Comparisons statistics will be '
          PRINT*, '**** calculated for minimum resolution:', RESMIN
          PRINT*
      ENDIF

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE GETRIN  -  Read in the information from the current .rin
C                        file
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETRIN(IFILE,IMODEL)

      SAVE
      
      INCLUDE 'vplot.inc'
      
      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

      CHARACTER*1   BRKCH, INCHN, SECSTR
      CHARACTER*3   RESDUE
      CHARACTER*5   SEQNO
      CHARACTER*6   SNO
      CHARACTER*9   SNOKEY
      INTEGER       IFILE, IMODEL, IPOS, IPROPT, IRES, ISTRUC, JPOS,
     -              JRES, LINE, LPOS, OOI1, OOI2, ORES, SERNO
      LOGICAL       DUPLIC, FIRST, INRANG, WANTED
      REAL          CGAMB, CHI1, CHI2, CHI3, CHI4,
     -              DIHANG, DISULF, ENHB, MCBVAL, OMEGA, PHI, PSI,
     -              SCBVAL
      REAL          ALLOWP, GENERP, OUTSIP

C---- Initialise variables
      DO 100, IRES = 1, MXRES
          DO 50, IPROPT = 1, NPROPT
              VALUE(IPROPT,IRES,IMODEL) = 999.9
 50       CONTINUE
 100  CONTINUE
      FIRST = .TRUE.
      IPOS = 0
      IRES = 0
      LINE = 0
      LPOS = 0
      ORES = NRES

C---- Open the corresponding .rin file
      OPEN(UNIT=4, FILE=FILRIN(IFILE), STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Loop through the records storing the required data
 300  CONTINUE

C----     Read in the data
          READ(4,310,END=500,ERR=902) SERNO, RESDUE, BRKCH, INCHN,
     -        SEQNO, SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4,
     -        ENHB, DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
 310      FORMAT(I4,A3,A1,A1,A5,A1,11F7.2,2F7.3,2I3)
          SNO = INCHN // SEQNO
          SNOKEY = SNO // RESDUE
          DUPLIC = .FALSE.
          LINE = LINE + 1

C----     Test whether the current residue is within one of the
C         user-defined ranges
          WANTED = INRANG(SEQNO,INCHN,RESFRM,RESTO,MAXRNG,NRANGE)

C----     Process this residue only if it is within the user-specified
C         ranges
          IF (WANTED .OR. .NOT.BOTHND) THEN

C----         Step to the next residue position
              IPOS = IPOS + 1
              IF (IPOS.GT.MXRES) GO TO 904

C----         If this is the first instance of this residue, then store
C             it and update the appropriate pointer
              IF (IPOS.GT.NRES) THEN
                  IRES = IPOS
                  IF (LPOS.GT.0) THEN
                      NXTRES(LPOS) = IPOS
                  ENDIF
                  LPOS = IPOS

C----         Otherwise, check whether have met this residue in a
C             previous .rin file
              ELSE
                  IRES = 0
                  DO 400, JPOS = 1, NRES

C----                 Get the pointer to the next residue
                      IF (JPOS.EQ.1) THEN
                          JRES = FSTRES
                      ELSE
                          JRES = NXTRES(JRES)
                      ENDIF

C----                 Check whether current residue fits in here
                      IF (SNOKEY.EQ.VALSNO(JRES)) THEN
                          IRES = JRES
                          LPOS = JRES
                          GO TO 410

C----                 If residue doesn't match exactly, see whether the
C                     residue number is right, but just the residue type
C                     that is different
                      ELSE
                          IF (SNOKEY(1:6).EQ.VALSNO(JRES)(1:6)) THEN
                              LPOS = JRES
                              DUPLIC = .TRUE.
                              DOUBL(JRES) = .TRUE.
                          ENDIF
                      ENDIF
 400              CONTINUE
 410              CONTINUE

C----             If existing slot has not been been found, then put
C                 residue at end of list and adjust pointers accordingly
C                 so that it "slots in" between the last matched residue
C                 and the one that follows it
                  IF (IRES.EQ.0) THEN
                      NRES = NRES + 1
                      IF (NRES.GT.MXRES) GO TO 904
                      IRES = NRES
                      IF (LPOS.EQ.0) THEN
                          NXTRES(IRES) = FSTRES
                          FSTRES = IRES
                      ELSE
                          NXTRES(IRES) = NXTRES(LPOS)
                          NXTRES(LPOS) = IRES
                      ENDIF
                      LPOS = IRES
                      IF (DUPLIC) DOUBL(IRES) = .TRUE.
                  ENDIF
              ENDIF

C----         Store the residue type and the required values for
C             plotting
              IF (IRES.GT.0) THEN

C----             Store whether this residue is wanted or not
                  RESWNT(IRES) = WANTED

C----             Call the routine to accumulate all the mean-values
CYYY                  CALL MEANS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,
CYYY     -                CHI2,CHI3,ENHB,DISULF,DIHANG,OOI2,FIRST)

C----             Accumulate maximum and minimum Ooi numbers
                  OOIMIN = MIN(OOI2,OOIMIN)
                  OOIMAX = MAX(OOI2,OOIMAX)

C----             Adjust Phi and Psi values
                  IF (PHI.LT.900.0) PHI = PHI + 180.0
                  IF (PSI.LT.900.0) PSI = PSI + 180.0

C----             Adjust chi1 and chi2 values
                  IF (RESDUE.EQ.'PRO') CHI1 = 999.9
                  IF (CHI1.LT.0.0) CHI1 = CHI1 + 360.0
                  IF (CHI1.EQ.360.0) CHI1 = 0.0
                  IF (CHI2.LE.0.0) CHI2 = CHI2 + 360.0

C----             Save the data that will be required for the distributions
                  VALUE(LOCPHI,IRES,IMODEL) = PHI
                  VALUE(LOCPSI,IRES,IMODEL) = PSI
                  VALUE(LOCHI1,IRES,IMODEL) = CHI1
                  VALUE(LOCHI2,IRES,IMODEL) = CHI2
                  VALUE(LOCOME,IRES,IMODEL) = OMEGA
                  VALUE(LOCZET,IRES,IMODEL) = DIHANG

C----             Save the residue ID
                  IF (VALRES(IRES).EQ.' ') VALRES(IRES) = RESDUE
                  VALSNO(IRES) = INCHN // SEQNO // RESDUE

C----             Mark this model as containing this residue
                  RESMOD(IRES,IMODEL) = .TRUE.

C----             Save the Kabsch & Sander secondary structure definition
                  IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'G') THEN
                      ISTRUC = HELIX
                  ELSE IF (SECSTR.EQ.'E') THEN
                      ISTRUC = STRAND
                  ELSE IF (SECSTR.EQ.'=') THEN
                      ISTRUC = BLANK
                  ELSE
                      ISTRUC = COIL
                  ENDIF
                  IF (ISTRUC.NE.BLANK) THEN
                      SSTCNT(ISTRUC,IRES) = SSTCNT(ISTRUC,IRES) + 1
                  ENDIF
                  STOSST(IRES,IMODEL) = SECSTR

C----             Store the chain break
                  IF (CHNBRK(IRES).EQ.' ') THEN
                      CHNBRK(IRES) = BRKCH
                  ENDIF

C----             Ooi number
                  VALOOI(IRES) = VALOOI(IRES) + OOI2
                  NOOI(IRES) = NOOI(IRES) + 1
                  SAVOOI(IRES,IMODEL) = OOI2
              ENDIF

C----     Otherwise, if the residue is not wanted, mark the last-stored
C         residue as being at the end of a chain-break
          ELSE
              IF (IRES.GT.0) THEN
                  CHNBRK(IRES) = 'x'
              ENDIF
          ENDIF

C---- Loop back
      GO TO 300

C---- End of file reached
 500  CONTINUE

C---- Adjust the maximum and minimum sequence length
      IF (NRES.EQ.0) THEN
          NRES = IRES
      ENDIF
      IF (IPOS.GT.0) THEN
          IF (MAXLEN.EQ.0) THEN
              MINLEN = IPOS
              MAXLEN = IPOS
          ELSE
              MINLEN = MIN(IPOS,MINLEN)
              MAXLEN = MAX(IPOS,MAXLEN)
          ENDIF
      ENDIF

C---- Calculate percentages for residues in the different regions of the
C     Ramachandran plot
      IF (NONPG.GT.0) THEN
          ALLOWP = 100.0 * REAL(NALLOW) / REAL(NONPG)
          COREPC = 100.0 * REAL(NCORE) / REAL(NONPG)
          GENERP = 100.0 * REAL(NGENER) / REAL(NONPG)
          OUTSIP = 100.0 * REAL(NOUTSI) / REAL(NONPG)
      ELSE
          ALLOWP = 0.0
          COREPC = 0.0
          GENERP = 0.0
          OUTSIP = 0.0
      ENDIF

C---- Calculate the mean values of the various properties
CYYY      CALL CALCS

C---- Rewind the .rin file
      REWIND(4)
      LINE = 0

C---- Read through the residues a second time to accumulate standard
C     deviations
 600  CONTINUE

C----     Read in the data
          READ(4,310,END=800,ERR=902) SERNO, RESDUE, BRKCH, INCHN,
     -        SEQNO, SECSTR, PHI, PSI, OMEGA, CHI1, CHI2, CHI3, CHI4,
     -        ENHB, DISULF, DIHANG, CGAMB, MCBVAL, SCBVAL, OOI1, OOI2
          LINE = LINE + 1

C----     Accumulate the data for calculation of standard deviations
CYYY          CALL STDEVS(RESDUE,INCHN,SECSTR,PHI,PSI,OMEGA,CHI1,CHI2,
CYYY     -        CHI3,ENHB,DISULF,DIHANG)
      GO TO 600

C---- Calculate the standard deviations and store all the values
C     required for the Quality Plots
 800  CONTINUE
CYYY      CALL SCALCS(IMODEL)

C---- Close the .rin file
      CLOSE(4)

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** Unable to open .rin file:'
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 902  CONTINUE
      PRINT*, '*** Data error reading .rin file at line', LINE + 1
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 904  CONTINUE
      PRINT*, '*** Maximum number of residues exceeded:', MXRES
      PRINT*, '*** ', FILRIN(IFILE)(1:70)
      GO TO 990
 
 990  CONTINUE
      IFAIL = .TRUE.
 
 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETCON  -  Read through the Aqua output files to pick up
C                        all the distance restraints
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCON(ACDIST,VIOLAT,NFILE,MAXCON)

      INCLUDE 'vplot.inc'

      CHARACTER*4   ATTYP(2)
      CHARACTER*9   RESDET(2)
      CHARACTER*80  FNAME
      CHARACTER*512 IREC
      INTEGER       IATNO(2), IATTYP, ICONST, ICTYPE, IERR, IFILE,
     -              IMODEL, IRES, IRESNO(2), ITYPE, JERR, LCOUNT, LINE,
     -              NFILE, MAXCON, UCOUNT
      LOGICAL       ENDFIL, INRANG, OUTRNG, START, WANT1, WANT2
      REAL          ACDIST(NFILE + 2,MAXCON), DIFF, LOWER, UPPER,
     -              VIOLAT(NFILE + 2,MAXCON)

C---- Initialise variables
      ENDFIL = .FALSE.
      IFAIL = .FALSE.
      LINE = 0
      DO 100, ICTYPE = 1, NCTYPE
          NCONST(ICTYPE) = 0
 100  CONTINUE
      DO 200, ICONST = 1, MXCONS
          RESLMS(ICONST) = ' '
          RESTYP(ICONST) = ' '
          VIOATM(1,ICONST) = 0
          VIOATM(2,ICONST) = 0
          VIORES(1,ICONST) = 0
          VIORES(2,ICONST) = 0
 200  CONTINUE
      ICONST = 0

C---- Loop through the various restraint violation files
      DO 800, ICTYPE = 1, NCTYPE

C----     Get the appropriate filename
          FNAME = FILVIO(ICTYPE) 
          PRINT*, '*'
          PRINT*, '* Restraints read in from file:'
          PRINT*, '* ', FNAME(1:76)

C----     Open the restraints file
          OPEN(UNIT=12, FILE=FNAME, STATUS='OLD', FORM='FORMATTED',
     -         ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST', READONLY,
     -         IOSTAT=IERR)
          START = .FALSE.

C----     If restraints file not found, then just print a warning
C         message
          IF (IERR.NE.0) THEN
              PRINT*, '* Warning. Restraints file not found:'

C----     Otherwise, read in the restraints
          ELSE

C----         Loop through the records in the file until get to the start
C             if the restraints data
 300          CONTINUE
                  READ(12,320,END=700,IOSTAT=IERR) IREC
 320              FORMAT(A)
                  LINE = LINE + 1
                  IF (IERR.NE.0) THEN
                      PRINT*, '*  File-read error at line', LINE
                      IREC = ' '
                  ENDIF

C----             Check whether have reached the start of the data
                  IF (IREC(1:17).EQ.'$ DATA  DISTANCES') THEN

C----                 Skip the next two lines
                      READ(12,*,END=700,ERR=700)
                      READ(12,*,END=700,ERR=700)
                      START = .TRUE.
                  ENDIF

C----         If still not found start of data, loop back for next record
              IF (.NOT.START) GO TO 300

C----         Read in the data from the file
              ENDFIL = .FALSE.
 400          CONTINUE
                  READ(12,320,END=700,IOSTAT=IERR) IREC
                  LINE = LINE + 1
                  IF (IERR.NE.0) THEN
                      PRINT*, '*  File-read error at line', LINE
                      IREC = ' '

C----             Check for the end of the data
                  ELSE IF (IREC(1:5).EQ.'$ END') THEN
                      ENDFIL = .TRUE.

C----             If not end, then store this restraint
                  ELSE

C----                 Extract the two residues involved
                      RESDET(1) = IREC(2:2) // IREC(9:13) // IREC(4:6)
                      RESDET(2) = IREC(22:22) // IREC(29:33) //
     -                    IREC(24:26)

C----                 Check whether both residue fall within the specified
C                     residue range
                      WANT1 = INRANG(RESDET(1)(2:6),RESDET(1)(1:1),
     -                    RESFRM,RESTO,MAXRNG,NRANGE)
                      WANT2 = INRANG(RESDET(2)(2:6),RESDET(2)(1:1),
     -                    RESFRM,RESTO,MAXRNG,NRANGE)

C----                 Determine whether to keep the restraint
                      IF (BOTHND) THEN
                          IF (WANT1 .AND. WANT2) THEN
                              OUTRNG = .FALSE.
                          ELSE
                              OUTRNG = .TRUE.
                          ENDIF
                      ELSE IF (WANT1 .OR. WANT2) THEN
                          OUTRNG = .FALSE.
                      ELSE
                          OUTRNG = .TRUE.
                      ENDIF

C----                 Locate the two residues involved
                      IRESNO(1) = 0
                      IRESNO(2) = 0
                      IF (.NOT.OUTRNG) THEN
                          DO 450, IRES = 1, NRES
                              IF (RESDET(1).EQ.VALSNO(IRES)) THEN
                                  IRESNO(1) = IRES
                              ENDIF
                              IF (RESDET(2).EQ.VALSNO(IRES)) THEN
                                  IRESNO(2) = IRES
                              ENDIF
 450                      CONTINUE
                      ENDIF

C----                 If have locted both residues, then store restraint
                      IF (IRESNO(1).NE.0 .AND.IRESNO(2).NE.0) THEN

C----                     Increment restraints count
                          ICONST = ICONST + 1
                          IF (ICONST.GT.MAXCON) THEN
                              PRINT*, '* Warning. Maximum restraint-vi',
     -                            'olations array MAXARR exceeded',
     -                            MAXARR
                              PRINT*, '* Some restraint information ha',
     -                            's been lost'
                              GO TO 700
                          ENDIF
                          IF (ICONST.GT.MXCONS) THEN
                              PRINT*, '* Warning. Restraint-violations',
     -                            ' array MXCONS exceeded', MXCONS
                              PRINT*, '* Some restraint information ha',
     -                            's been lost'
                              GO TO 700
                          ENDIF

C----                     Read in the restraint violations for all the models
                          READ(IREC,460,IOSTAT=IERR)
     -                        (ACDIST(IFILE,ICONST), IFILE = 1, NFILE)
 460                      FORMAT(57X,60F7.2)

C----                     Extract the data for just those models that
C                         have been selected by the user
                          IMODEL = 0
                          DO 470, IFILE = 1, NFILE
                              IF (MWANT(IFILE)) THEN
                                  IMODEL = IMODEL + 1
                                  ACDIST(IMODEL,ICONST)
     -                                = ACDIST(IFILE,ICONST)
                              ENDIF
 470                      CONTINUE

C----                     Read in the upper- and lower-bounds
                          READ(IREC,480,IOSTAT=JERR) LOWER, UPPER
 480                      FORMAT(45X,F5.0,2X,F5.0)
                          ACDIST(NFILE + 1,ICONST) = LOWER
                          ACDIST(NFILE + 2,ICONST) = UPPER

C----                     Initialise counts of upper- and lower-bound
C                         violations
                          LCOUNT = 0
                          UCOUNT = 0

C----                     Compute all the violations
                          DO 500, IMODEL = 1, NMODEL
                              DIFF = ACDIST(IMODEL,ICONST) - LOWER
                              IF (DIFF.GT.0.0) THEN
                                  DIFF = ACDIST(IMODEL,ICONST) - UPPER
                                  IF (DIFF.LE.0.0) THEN
                                      DIFF = 0.0
                                  ELSE
                                      UCOUNT = UCOUNT + 1
                                  ENDIF
                              ELSE IF (DIFF.LT.0.0) THEN
                                  LCOUNT = LCOUNT + 1
                              ENDIF
                              VIOLAT(IMODEL,ICONST) = DIFF
 500                      CONTINUE

C----                     Store the counts of upper- and lower-bound
C                         violations
                          VIOLAT(NFILE + 1,ICONST) = LCOUNT
                          VIOLAT(NFILE + 2,ICONST) = UCOUNT

C----                     If all values read in OK, then store
                          IF (IERR.EQ.0 .AND. JERR.EQ.0) THEN
                              VIORES(1,ICONST) = IRESNO(1)
                              VIORES(2,ICONST) = IRESNO(2)

C----                         Get the atom types
                              ATTYP(1) = IREC(15:18)
                              ATTYP(2) = IREC(35:38)

C----                         For each atom, search to see if already
C                             have that atom type
                              DO 600, ITYPE = 1, 2
                                  IATNO(ITYPE) = 0

C----                             Search through the atom types already
C                                 stored
                                  DO 550, IATTYP = 1, NATTYP
                                      IF (ATTYP(ITYPE).EQ.
     -                                    ATTYPE(IATTYP)) THEN
                                          IATNO(ITYPE) = IATTYP
                                      ENDIF
 550                              CONTINUE

C----                             If atom type not found, then add it to
C                                 the list
                                  IF (IATNO(ITYPE).EQ.0) THEN
                                      IF (NATTYP.GE.MXATYP) THEN
                                          PRINT*, '*** WARNING. Maximu',
     -                                        'm number of atom types ',
     -                                        'exceeded. Some data los',
     -                                        't.', MXATYP
                                      ELSE
                                          NATTYP = NATTYP + 1
                                          ATTYPE(IATTYP) = ATTYP(ITYPE)
                                          IATNO(ITYPE) = NATTYP
                                      ENDIF
                                  ENDIF

C----                             Store the atom type making this restraint
                                  VIOATM(ITYPE,ICONST) = IATNO(ITYPE)
 600                          CONTINUE

C----                         Determine whether this restraint is
C                             long-, medium- or short-range
                              CALL GETCLS(VALSNO(IRESNO(1)),
     -                            VALSNO(IRESNO(2)),UPPER,DCLASS,CLASS,
     -                            RESLMS(ICONST))

C----                         Check whether restraint has both a lower-
C                             and upper-bound, or just one of these
                              RESTYP(ICONST) = 'B'
                              IF (IREC(45:49).EQ.' 0.  ')
     -                            RESTYP(ICONST) = 'L'
                              IF (IREC(38:42).EQ.' 0.  ')
     -                            RESTYP(ICONST) = 'U'

C----                     If there's an error, reject this restraint
                          ELSE
                              PRINT*, '* Warning. Error reading restr',
     -                            'aint on line', LINE
                              ICONST = ICONST - 1
                          ENDIF

C----                 Otherwise print warning message
                      ELSE IF (.NOT.OUTRNG) THEN
                          PRINT*, '* Warning. Restraint residues not',
     -                        ' found [', RESDET(1), ']  [',
     -                        RESDET(2), ']'
                      ENDIF
                  ENDIF

C----         Loop back for next record
              IF (.NOT.ENDFIL) GO TO 400
          ENDIF

C----     End of file reached
 700      CONTINUE

C----     Print stats on restraints read in
          IF (ICONST.GT.MAXCON) ICONST = MAXCON
          IF (ICONST.GT.MXCONS) ICONST = MXCONS
          IF (ICTYPE.EQ.1) THEN
              NCONST(ICTYPE) = ICONST
          ELSE
              NCONST(ICTYPE) = ICONST - NCONST(ICTYPE - 1)
          ENDIF
          PRINT*, '* Number of restraints read in:      ',
     -        NCONST(ICTYPE)

 800  CONTINUE

C---- Total number of restraints
      NCONN = NCONST(1)
      NCONH = NCONN + NCONST(2)
      NCONS = NCONH + NCONST(3)
      TCONST = ICONST
      PRINT*, '*'
      PRINT*, '* Total number of restraints read in:', TCONST
      PRINT*, '*'
      IF (TCONST.EQ.0) THEN
          PRINT*, '**** No distance restraints found'
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETCLS  -  Detemine whether the current restraint is
C                        short, medium or long-range
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCLS(RES1,RES2,UPPER,DCLASS,CLASS,LMSTYP)

      CHARACTER*1   DTYPES(3), LMSTYP
      CHARACTER*9   RES1, RES2
      INTEGER       ICLASS, IERR, RNO1, RNO2, RSEP
      LOGICAL       DCLASS
      REAL          CLASS(2,3),UPPER

      DATA DTYPES / 'S', 'M', 'L' /

C---- Initialise variables
      LMSTYP = 'L'

C---- If restraint class is determined on the basis of distance,
C     find which range the upper-bound restraint falls into
      IF (DCLASS) THEN

C----     Loop through the distance ranges
          DO 100, ICLASS = 1, 3
              IF (UPPER.GE.CLASS(1,ICLASS) .AND.
     -            UPPER.LT.CLASS(2,ICLASS)) THEN
                  LMSTYP = DTYPES(ICLASS)
              ENDIF
 100      CONTINUE

C---- Otherwise, use the sequence separation to classify the restraint
      ELSE

C----     Get the residue numbers
          READ(RES1,120,IOSTAT=IERR) RNO1
 120      FORMAT(1X,I4)
          IF (IERR.NE.0) RNO1 = 0
          READ(RES2,120,IOSTAT=IERR) RNO2
          IF (IERR.NE.0) RNO2 = 0

C----     Determine the residue separation between
C         the two residues and hence restraint type
          RSEP = ABS(RNO1 - RNO2)
          IF (RSEP.EQ.0) THEN
              LMSTYP = 'S'
          ELSE IF (RSEP.LE.4) THEN
              LMSTYP = 'M'
          ELSE
              LMSTYP = 'L'
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETORS  -  Read through the Aqua output files to pick up
C                        the dihedral angle restraints
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETORS(NFILE)

      INCLUDE 'vplot.inc'

      CHARACTER*1   INCHN
      CHARACTER*4   TORTYP
      CHARACTER*10  RESDET
      CHARACTER*80  IREC, TMPREC
      INTEGER       ICONST, IERR, IPOS, IRES, IRESID, ITORS, LINE, NFILE
      REAL          LOWER, UPPER

C---- Initialise variables
      IFAIL = .FALSE.
      LINE = 0
      ACONST = 0
      ICONST = 0

C---- Open the restraints file
      OPEN(UNIT=12, FILE=FILTOR, STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Read in the data from the file
 100  CONTINUE
          READ(12,120,END=500,IOSTAT=IERR) IREC
 120      FORMAT(A)
          LINE = LINE + 1
          IF (IERR.NE.0) THEN
              PRINT*, '*  File-read error at line', LINE
              IREC = ' '

C----     If this is an ANGLE record, read in and store the restraint
          ELSE IF (IREC(1:5).EQ.'ANGLE') THEN

C----         Check whether the line contains a chain identifier
              INCHN = ' '
              IPOS = INDEX(IREC,'CHAIN')
              IF (IPOS.GT.0) THEN
                  INCHN = IREC(15:15)
                  TMPREC = IREC(1:8) // IREC(17:)
                  IREC = TMPREC
              ENDIF

C----         Get the residue ID
              RESDET = IREC(9:11) // IREC(13:17)

C----         Find the relevant residue number
              IRESID = 0
              DO 200, IRES = 1, NRES
                  IF (INCHN.EQ.VALSNO(IRES)(1:1) .AND.
     -                RESDET(4:8).EQ.VALSNO(IRES)(2:6) .AND.
     -                (RESDET(1:3).EQ.VALSNO(IRES)(7:9) .OR.
     -                 RESDET(1:3).EQ.'UNK')) THEN
                      IRESID = IRES
                  ENDIF
 200          CONTINUE

C----         If have located the relevant residue, then store the
C             restraint
              IF (IRESID.NE.0) THEN

C----             Read in the upper- and lower-bounds
                  READ(IREC,220,IOSTAT=IERR) TORTYP, UPPER, LOWER
 220              FORMAT(17X,A4,1X,2F9.3)
                  IF (IERR.EQ.0) THEN
                      ITORS = 0
                      IF (TORTYP.EQ.'PHI ') ITORS = 1
                      IF (TORTYP.EQ.'PSI ') ITORS = 2
                      IF (TORTYP.EQ.'CHI1') ITORS = 3
                      IF (TORTYP.EQ.'CHI2') ITORS = 4

C----                 If this is a valid torsion angle, then store
                      IF (ITORS.GT.0) THEN

C----                     Adjust upper-bound, if necessary
                          IF (UPPER.LT.LOWER) THEN
                              UPPER = UPPER + 360.0
                          ENDIF

C----                     Increment restraints count
                          ICONST = ICONST + 1
                          IF (ICONST.GT.MXRES) THEN
                              PRINT*, '*** Maximum no. of dihedral ',
     -                            'angle restraints exceeded ', MXRES
                              PRINT*, '*   Some will have been lost'

C----                     Store upper- and lower-bounds
                          ELSE
                              IF (ITORS.EQ.3 .OR. ITORS.EQ.4) THEN
                                  IF (LOWER.LT.UPPER .AND.
     -                                (LOWER.LE.0.0 .OR.
     -                                UPPER.LE.0.0)) THEN
                                      LOWER = LOWER + 360.0
                                      UPPER = UPPER + 360.0
                                  ENDIF
                              ENDIF
                              DIHCON(1,ITORS,IRESID) = LOWER
                              DIHCON(2,ITORS,IRESID) = UPPER
                              HAVANG = .TRUE.

C----                         Check through the models to count how many
C                             times this restraint is violated
                              CALL CVIOL(NFILE,ITORS,IRESID,LOWER,UPPER)
                          ENDIF
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF

C---- Loop back for next record
      GO TO 100

C---- End of file reached
 500  CONTINUE
      CLOSE(12)

C---- Total number of dihedral angle restraints
      ACONST = ICONST
      PRINT*, '*'
      PRINT*, '* Dihedral angle restraints read in: ', ACONST
      PRINT*, '*'

      GO TO 999

C---- Errors
900   CONTINUE
      PRINT*, '**** No torsion angle restraints found'
      GO TO 999

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CVIOL  -  Count the number of times a given torsion angle
C                       restraint is violated in the models of interest
C
C----------------------------------------------------------------------+---

      SUBROUTINE CVIOL(NFILE,ITORS,IRESID,LOWER,UPPER)

      INCLUDE 'vplot.inc'

      INTEGER       IFILE, IRESID, ITORS, NFILE
      LOGICAL       OUTSID
      REAL          DIHVAL, LOWER, UPPER

C---- Loop through the models to count how many times the given
C     restraint is violated
      DO 400, IFILE = 1, NFILE

C----     Process only if this is one of the selected models
          IF (MWANT(IFILE)) THEN

C----         Pick off the appropriate value
              IF (ITORS.EQ.1) THEN
                  DIHVAL = VALUE(LOCPHI,IRESID,IFILE) - 180.0
              ELSE IF (ITORS.EQ.2) THEN
                  DIHVAL = VALUE(LOCPSI,IRESID,IFILE) - 180.0
              ELSE IF (ITORS.EQ.3) THEN
                  DIHVAL = VALUE(LOCHI1,IRESID,IFILE)
              ELSE IF (ITORS.EQ.4) THEN
                  DIHVAL = VALUE(LOCHI2,IRESID,IFILE)
              ENDIF

C----         Check is value falls within restraint range
              IF (DIHVAL.GE.LOWER .AND. DIHVAL.LE.UPPER) THEN
                  OUTSID = .FALSE.
              ELSE
                  OUTSID = .TRUE.
              ENDIF

C----         If still outside, add 360 and try again
              IF (OUTSID) THEN
                  DIHVAL = DIHVAL + 360.0
                  IF (DIHVAL.GE.LOWER .AND. DIHVAL.LE.UPPER) THEN
                      OUTSID = .FALSE.
                  ENDIF
              ENDIF
                                      
C----         If the value is outside the restraint bounds increment
C             the number of restraint violations
              IF (OUTSID) THEN
                  DVIOL(ITORS,IRESID) = DVIOL(ITORS,IRESID) + 1
                  DVIOLM(ITORS,IRESID,IFILE) = 1.0
              ELSE
                  DVIOLM(ITORS,IRESID,IFILE) = 0.0
              ENDIF
          ENDIF
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PRESRT  -   Presort all the restraints according to residue,
C                         atom type, and whether long, medium or short
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE PRESRT(MAXCON,SINDEX)

      INCLUDE 'vplot.inc'

      INTEGER       MAXCON
      INTEGER       ICON, SINDEX(2 * MAXCON)

C---- Initialise sort index
      DO 100, ICON = 1, TCONST
          SINDEX(ICON) = ICON
          SINDEX(TCONST + ICON) = -ICON
 100  CONTINUE

C---- Sort all the restraints
      CALL RESORT(2 * TCONST,SINDEX)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RESORT  -  Sort of restraints, using the SHELL sort method.
C
C                        [Adapted from Numerical Recipes, Press et al.]
C
C--------------------------------------------------------------------------

      SUBROUTINE RESORT(NSIZE,SINDEX)

      INCLUDE 'vplot.inc'

      REAL          ALN2I, TINY
      PARAMETER (ALN2I=1.4426950, TINY=1.E-5)

      CHARACTER*1   RTYPE
      CHARACTER*4   ATYPE1, ATYPE2
      CHARACTER*30  STRNG1, STRNG2
      INTEGER       NSIZE
      INTEGER       IATOM1, IATOM2, ICONST, IRES1, IRES2, JCONST,
     -              SINDEX(NSIZE)

      INTEGER       I, ISWAP, J, K, L, LOGNB2, M, N, NN

C---- Initialise variables

C---- Perform the sort
      N = NSIZE
      LOGNB2 = INT(ALOG(FLOAT(N)) * ALN2I + TINY)
      M = N
      DO 12, NN = 1, LOGNB2
          M = M / 2
          K = N - M
          DO 11, J = 1, K
              I = J
3             CONTINUE
              L = I + M

C----         Prepare the first compare-string
              ICONST = ABS(SINDEX(L))
              RTYPE = ' '
              IF (ICONST.LE.NCONS) RTYPE = 'S'
              IF (ICONST.LE.NCONH) RTYPE = 'H'
              IF (ICONST.LE.NCONN) RTYPE = 'N'
              IF (SINDEX(L).GT.0) THEN
                  IRES1 = VIORES(1,ICONST)
                  IRES2 = VIORES(2,ICONST)
                  IATOM1 = VIOATM(1,ICONST)
                  IATOM2 = VIOATM(2,ICONST)
              ELSE
                  IRES2 = VIORES(1,ICONST)
                  IRES1 = VIORES(2,ICONST)
                  IATOM2 = VIOATM(1,ICONST)
                  IATOM1 = VIOATM(2,ICONST)
              ENDIF
              IF (IATOM1.GT.0) THEN
                  ATYPE1 = ATTYPE(IATOM1)
              ELSE
                  ATYPE1 = ' '
              ENDIF
              IF (IATOM2.GT.0) THEN
                  ATYPE2 = ATTYPE(IATOM2)
              ELSE
                  ATYPE2 = ' '
              ENDIF
              STRNG1 = VALSNO(IRES1) // ATYPE1 // RESLMS(ICONST) //
     -            VALSNO(IRES2) // ATYPE2 // RTYPE

C----         Prepare the second compare-string
              JCONST = ABS(SINDEX(I))
              RTYPE = ' '
              IF (JCONST.LE.NCONS) RTYPE = 'S'
              IF (JCONST.LE.NCONH) RTYPE = 'H'
              IF (JCONST.LE.NCONN) RTYPE = 'N'
              IF (SINDEX(I).GT.0) THEN
                  IRES1 = VIORES(1,JCONST)
                  IRES2 = VIORES(2,JCONST)
                  IATOM1 = VIOATM(1,JCONST)
                  IATOM2 = VIOATM(2,JCONST)
              ELSE
                  IRES2 = VIORES(1,JCONST)
                  IRES1 = VIORES(2,JCONST)
                  IATOM2 = VIOATM(1,JCONST)
                  IATOM1 = VIOATM(2,JCONST)
              ENDIF
              IF (IATOM1.GT.0) THEN
                  ATYPE1 = ATTYPE(IATOM1)
              ELSE
                  ATYPE1 = ' '
              ENDIF
              IF (IATOM2.GT.0) THEN
                  ATYPE2 = ATTYPE(IATOM2)
              ELSE
                  ATYPE2 = ' '
              ENDIF
              STRNG2 = VALSNO(IRES1) // ATYPE1 // RESLMS(JCONST) //
     -            VALSNO(IRES2) // ATYPE2 // RTYPE

C----         If order the wrong way round, swap the indices
              IF (LLT(STRNG1,STRNG2)) THEN
                  ISWAP = SINDEX(I)
                  SINDEX(I) = SINDEX(L)
                  SINDEX(L) = ISWAP
                  I = I - M
                  IF (I.GE.1) GO TO 3
              ENDIF
11        CONTINUE
12    CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSTPLT  -   Produce the restraints plots showing each
C                         distance restraint and its violation, grouped
C                         by residue, atom type and whether long, medium
C                         or short
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE RSTPLT(PLTYPE,ACDIST,VIOLAT,NFILE,MAXCON,SINDEX)

      INCLUDE 'vplot.inc'

      INTEGER       NGRAPH
      PARAMETER    (NGRAPH = 3)

      REAL          MAXTOP, MINBOT, MKSIZE, YRORIG, YRSEP, YRWID
      PARAMETER    (
     -              MAXTOP =   10.0,
     -              MINBOT =  -10.0,
     -              MKSIZE =    5.0,
     -              YRORIG =  170.0,
     -              YRSEP  =   85.0,
     -              YRWID  =  100.0
     -             )

      INTEGER       MAXCON, NFILE

      CHARACTER*1   DTYPE, PINMK(MXFILE,MXPINS), RTYPE
      CHARACTER*4   ATYPE1, ATYPE2
      CHARACTER*9   HANDLE(2)
      CHARACTER*28  RESTRN(MXPINS)
      CHARACTER*30  PLDESC(2)
      CHARACTER*60  PTITLE(2)
      INTEGER       IATOM1, IATOM2, FPIN, ICONS, ICONST, IFILE, IGRAPH,
     -              IMODEL, IRES1, IRES2, NPAGE, NPIN, NYGAP,
     -              PINVCT(MXPINS), PINVLB(MXPINS), PLOTNO, PLTYPE,
     -              SINDEX(2 * MAXCON), THEPIN
      LOGICAL       FIRST, PINOPE, WANTED
      REAL          ACDIST(NFILE + 2,MAXCON), DIFF, LOWER, PINBOT,
     -              PINLOW(MXPINS), PINTOP, PINUPP(MXPINS),
     -              PINVAL(MXFILE,MXPINS), UPPER,
     -              VIOLAT(NFILE + 2,MAXCON), XCENTR, YLAST

      DATA  HANDLE / 'rstraints',
     -               'restdiffs' /
      DATA  PLDESC / 'Distance restraints',
     -               'Restraint differences' /
      DATA  PTITLE / 'Distance restraints',
     -               'Restraint differences' /

C---- Initialise variables
      FIRST = .TRUE.
      FPIN = 0
      IGRAPH = 0
      NPAGE = 0
      DO 100, NPIN = 1, MXPINS
CHECK v.3.4.3-->
C          PINLOW(NPIN) = ' '
C          PINUPP(NPIN) = ' '
          PINLOW(NPIN) = 0.0
          PINUPP(NPIN) = 0.0
CHECK v.3.4.3<--
          RESTRN(NPIN) = ' '
          PINVCT(NPIN) = 0
          PINVLB(NPIN) = 0
          DO 20, IFILE = 1, MXFILE
              PINVAL(IFILE,NPIN) = 0.0
 20       CONTINUE
 100  CONTINUE
      NPIN = 0
      PINOPE = .FALSE.
      PLOTNO = PLTYPE
      THEPIN = MXPINS
      XCENTR = XPORIG + XPWID / 2.0

C---- Calculate maximum and minimum values for the plot
      PINTOP = 0.0
      PINBOT = 0.0

C---- Loop through all the sorted restraints to plot out
      DO 300, ICONS = 1, 2 * TCONST

C----     Get pointer to the next restraint
          ICONST = ABS(SINDEX(ICONS))

C----     Determine whether this restraint is wanted
          CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -        SINDEX(ICONS),IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,
     -        WANTED)

C----     Include this restraint in computing the limits only if it is
C         required for the graph
          IF (WANTED) THEN

C----         For restraints plot include upper-bound in calculating
C             maximum
              IF (PLOTNO.EQ.1) PINTOP = MAX(UPPER,PINTOP)

C----         Loop over each model, calculating the difference
C             between the actual distance and restraint
              DO 200, IMODEL = 1, NMODEL

C----             For restraints plot, increase upper bound if
C                 necessary
                  IF (PLOTNO.EQ.1) THEN
                      PINTOP = MAX(ACDIST(IMODEL,ICONST),PINTOP)

C----             For restraint differences plot, get the size of
C                 the violation or, if no violation. the difference
C                 between the actual distance and upper-bound
                  ELSE
                      DIFF = ACDIST(IMODEL,ICONST) - LOWER
                      IF (DIFF.GT.0.0) THEN
                          DIFF = UPPER - ACDIST(IMODEL,ICONST)
                      ENDIF

C----                 If this value is outside the current limits, then
C                     adjust the limits
                      IF (DIFF.GT.PINBOT) PINBOT = DIFF
                      IF (DIFF.LT.PINTOP) PINTOP = DIFF
                  ENDIF
 200          CONTINUE
          ENDIF
 300  CONTINUE

C---- If plotting the restraints, set the lower limit to zero and extend
C     upper limit
      IF (PLOTNO.EQ.1) THEN
          PINBOT = 0.0
          PINTOP = PINTOP + 1.0
          IF (PINTOP.LT.2.0) PINTOP = 2.0

C----     If the upper limit is excessively large, then truncate
          IF (PINTOP.GT.MAXTOP) PINTOP = MAXTOP - 0.001

C---- For restraint difference plot, extend the graph limits
      ELSE
          PINTOP = - (PINTOP - 0.5)
          PINBOT = - (PINBOT + 0.5)
          IF (PINTOP.LT.2.0) PINTOP = 2.0
          IF (PINBOT.GT.-2.0) PINBOT = -2.0

C----     If the upper- or lower- limit is excessively large, then truncate
          IF (PINBOT.LT.MINBOT) PINBOT = MINBOT + 0.001
          IF (PINTOP.GT.MAXTOP) PINTOP = MAXTOP - 0.001
      ENDIF

C---- Adjust the graph limits for use on the graph
      CALL ADJLIM(PINBOT,PINTOP,NYGAP,.FALSE.)

C---- Loop through all the sorted restraints to plot out
      DO 800, ICONS = 1, 2 * TCONST

C----     Get pointer to the next restraint
          ICONST = ABS(SINDEX(ICONS))

C----     Determine whether this restraint is wanted
          CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -        SINDEX(ICONS),IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,
     -        WANTED)

C----     If the restraint is within the same residue, then keep only
C         the lower-numbered atom if want to exclude duplicates
          IF (EXDUPL .AND. IRES1.EQ.IRES2) THEN
              IF (IATOM2.GT.IATOM1) WANTED = .FALSE.
          ENDIF

C----     Process only if this restraint is wanted
          IF (WANTED) THEN
              IF (IATOM1.GT.0) THEN
                  ATYPE1 = ATTYPE(IATOM1)
              ELSE
                  ATYPE1 = ' '
              ENDIF
              IF (IATOM2.GT.0) THEN
                  ATYPE2 = ATTYPE(IATOM2)
              ELSE
                  ATYPE2 = ' '
              ENDIF

C----         Increment x-position of this item on the current graph
              NPIN = NPIN + 1

C----         Store the restraint details
              RESTRN(NPIN) = VALSNO(IRES1) // ATYPE1 //
     -            RESLMS(ICONST) // VALSNO(IRES2) // ATYPE2 // RTYPE

C----         Store the upper and lower bounds for this restraint
              PINLOW(NPIN) = LOWER
              PINUPP(NPIN) = UPPER

C----         Loop over all the models and extract the data points
              DO 400, IMODEL = 1, NMODEL

C----             Initialise violation-type marker
                  PINMK(IMODEL,NPIN) = ' '

C----             Calculate the difference in actual minus restraint
C                 distances
                  DIFF = ACDIST(IMODEL,ICONST) - LOWER

C----             If difference is negative, have a lower-bound violation
                  IF (DIFF.LT.0.0) THEN
                      PINMK(IMODEL,NPIN) = 'L'

C----             Otherwise, check for an upper-bound violationm
                  ELSE IF (DIFF.GT.0.0) THEN
                      DIFF = UPPER - ACDIST(IMODEL,ICONST)

C----                 If difference is negative, have an upper-bound
C                     violation
                      IF (DIFF.LT.0.0) THEN
                          PINMK(IMODEL,NPIN) = 'U'
                      ELSE
                          PINMK(IMODEL,NPIN) = '-'
                      ENDIF
                  ENDIF

C----             If this is a violation, increment appropriate count
                  IF (PINMK(IMODEL,NPIN).EQ.'U') THEN
                      PINVCT(NPIN) = PINVCT(NPIN) + 1
                  ENDIF
                  IF (PINMK(IMODEL,NPIN).EQ.'L') THEN
                      PINVLB(NPIN) = PINVLB(NPIN) + 1
                  ENDIF

C----             For restraints plot, store the actual distance and
C                 upper- and lower-bounds
                  IF (PLOTNO.EQ.1) THEN
                      PINVAL(IMODEL,NPIN) = ACDIST(IMODEL,ICONST)

C----             Otherwise, store the computed difference between actual
C                 distance and restraint
                  ELSE
                      PINVAL(IMODEL,NPIN) = -DIFF
                  ENDIF
 400          CONTINUE

C----         If have a graph-full of data, print this graph
              IF (NPIN.EQ.THEPIN) THEN
                  IF (PLOTRS) THEN

C----                 Increment current graph-number
                      IGRAPH = IGRAPH + 1

C----                 If this is the first graph of the page then need to
C                     start a new page
                      IF (IGRAPH.EQ.1 .OR. IGRAPH.GT.NGRAPH) THEN

C----                     If current PostScript file is open, close it
                          IF (PINOPE) THEN

C----                         Plot key to diagram
                              CALL PLTKEY(YLAST,MKSIZE,NFILE,PLTYPE,
     -                            PLOTNO)

C----                         Write closing line to PostScript file
                              CALL PSENDP
                              IF (.NOT.COMBPS) THEN
                                  CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,
     -                                BBOXY2)
                              ENDIF
                          ENDIF

C----                     Reset graph number
                          IGRAPH = 1
                          PINOPE = .TRUE.

C----                     Open new PostScript file
                          CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE(PLTYPE),
     -                        PLDESC(PLTYPE),HANDLE(PLTYPE),XCENTR)
                      ENDIF
                  ENDIF

C----             Plot current graph
                  CALL PINRPT(PLTYPE,PLOTNO,THEPIN,NPIN,FPIN,IGRAPH,
CHECK v.3.4.3-->
C     -                NGRAPH,NFILE,PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,
     -                NGRAPH,PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,
CHECK v.3.4.3<--
     -                PINVCT,PINVLB,RESTRN,MKSIZE,YRORIG,YRSEP,
     -                YRWID,NYGAP,YLAST)

C----             Reinitialise variables
                  FPIN = FPIN + THEPIN
                  DO 600, NPIN = 1, MXPINS
CHECK v.3.4.3-->
C                      PINLOW(NPIN) = ' '
C                      PINUPP(NPIN) = ' '
                      PINLOW(NPIN) = 0.0
                      PINUPP(NPIN) = 0.0
CHECK v.3.4.3<--
                      RESTRN(NPIN) = ' '
                      PINVCT(NPIN) = 0
                      PINVLB(NPIN) = 0
                      DO 500, IFILE = 1, MXFILE
                          PINVAL(IFILE,NPIN) = 0.0
 500                  CONTINUE
 600              CONTINUE
                  NPIN = 0
              ENDIF
          ENDIF
 800  CONTINUE

C---- If any more data left to be printed, then produce the plot
      IF (PLOTRS .AND. NPIN.GT.0) THEN

C----     Increment current graph-number
          IGRAPH = IGRAPH + 1

C----     If this is the first graph of the page then need to
C         start a new page
          IF (IGRAPH.EQ.1 .OR. IGRAPH.GT.NGRAPH) THEN

C----         If current PostScript file is open, close it
              IF (PINOPE) THEN

C----             Plot key to diagram
                  CALL PLTKEY(YLAST,MKSIZE,NFILE,PLTYPE,PLOTNO)

C----             Write closing line to PostScript file
                  CALL PSENDP
                  IF (.NOT.COMBPS) THEN
                      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                  ENDIF
              ENDIF

C----         Reset graph number
              IGRAPH = 1
              PINOPE = .TRUE.

C----         Open new PostScript file
              CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE(PLTYPE),
     -            PLDESC(PLTYPE),HANDLE(PLTYPE),XCENTR)
          ENDIF
              
C----     Produce current graph
          CALL PINRPT(PLTYPE,PLOTNO,THEPIN,NPIN,FPIN,IGRAPH,NGRAPH,
CHECK v.3.4.3-->
C     -        NFILE,PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,PINVCT,
     -        PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,PINVCT,
CHECK v.3.4.3<--
     -        PINVLB,RESTRN,MKSIZE,YRORIG,YRSEP,YRWID,NYGAP,
     -        YLAST)
      ENDIF

C---- Close the PotScript file
      IF (PLOTRS .AND. PINOPE) THEN

C----     Plot key to diagram
          CALL PLTKEY(YLAST,MKSIZE,NFILE,PLTYPE,PLOTNO)

C----     Write closing line to PostScript file
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSWANT  -   Determine whether the current restraint is
C                         wanted
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -    SINDEX,IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,WANTED)

      INCLUDE 'vplot.inc'

      INTEGER       MAXCON, NFILE

      CHARACTER*1   DTYPE, RTYPE
      INTEGER       IATOM1, IATOM2, ICONST, IRES1, IRES2, SINDEX
      LOGICAL       WANTED
      REAL          ACDIST(NFILE + 2,MAXCON), LOWER, UPPER,
     -              VIOLAT(NFILE + 2,MAXCON)

C---- Initialise variables
      WANTED = .FALSE.

C---- Get the upper and lower bounds for this restraint
      LOWER = ACDIST(NFILE + 1,ICONST)
      UPPER = ACDIST(NFILE + 2,ICONST)

C---- Check whether this restraint is wanted for the plots
      WANTED = .TRUE.
      IF (VIONLY) THEN
          IF (VIOLAT(NFILE + 1,ICONST).EQ.0.0 .AND.
     -        VIOLAT(NFILE + 2,ICONST).EQ.0.0) WANTED = .FALSE.
      ENDIF

C---- Get the corresponding residues and atoms
      IF (SINDEX.GT.0) THEN
          IRES1 = VIORES(1,ICONST)
          IRES2 = VIORES(2,ICONST)
          IATOM1 = VIOATM(1,ICONST)
          IATOM2 = VIOATM(2,ICONST)
      ELSE
          IRES2 = VIORES(1,ICONST)
          IRES1 = VIORES(2,ICONST)
          IATOM2 = VIOATM(1,ICONST)
          IATOM1 = VIOATM(2,ICONST)
      ENDIF

C---- Check whether restraint is excluded because of residue-range
C     selection
      IF (BOTHND) THEN
          IF (.NOT.RESWNT(IRES1) .OR. .NOT.RESWNT(IRES2)) THEN
              WANTED = .FALSE.
          ENDIF
      ELSE
          IF (.NOT.RESWNT(IRES1)) THEN
              WANTED = .FALSE.
          ENDIF
      ENDIF

C---- Get the restraint type and see if this is one of the ones
C     wanted
      RTYPE = ' '
      IF (ICONST.LE.NCONS) RTYPE = 'S'
      IF (ICONST.LE.NCONH) RTYPE = 'H'
      IF (ICONST.LE.NCONN) RTYPE = 'N'
      IF (RTYPE.EQ.'N' .AND. .NOT.TYPENO) WANTED = .FALSE.
      IF (RTYPE.EQ.'H' .AND. .NOT.TYPEHB) WANTED = .FALSE.
      IF (RTYPE.EQ.'S' .AND. .NOT.TYPESS) WANTED = .FALSE.
      DTYPE = RESLMS(ICONST)
      IF (DTYPE.EQ.'L' .AND. .NOT.INCLUL) WANTED = .FALSE.
      IF (DTYPE.EQ.'M' .AND. .NOT.INCLUM) WANTED = .FALSE.
      IF (DTYPE.EQ.'S' .AND. .NOT.INCLUS) WANTED = .FALSE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PGOPEN  -   Open new PostScript page
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,HANDLE,XCENTR)

      SAVE

      INCLUDE 'vplot.inc'

      CHARACTER*2   PAGENO
      CHARACTER*7   PAGE
      CHARACTER*9   HANDLE
      CHARACTER*30  PLDESC
      CHARACTER*60  PTITLE
      INTEGER       LENSTR, NPAGE, PLTYPE
      LOGICAL       FIRST
      REAL          XCENTR

C---- Open new PostScript file
      IF (.NOT.COMBPS .OR. FIRST) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,HANDLE,WITHAN)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,
     -        NPAGE + 1)
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
     -    INCOLR(PLTYPE),COLPLT(1,PLTYPE),NPAGE + 1,PLABEL,RSELEC)
      PLDESC = ' '
      CALL PSLWID(0.1)

C---- Main graph heading
      CALL PSCTXT(XCENTR,BBOXY2 - 38.0,30.0,PTITLE(1:LENSTR(PTITLE)))
      CALL PSCTXT(XCENTR,BBOXY2 - 66.0,25.0,TITLE(1:TLEN))

C---- Print the page number on the plot
      NPAGE = NPAGE + 1
      WRITE(PAGENO,'(I2)') NPAGE
      PAGE = 'Page ' // PAGENO      
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

C---- Print program name in top left-hand corner
      IF (NMR) THEN
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-NMR')
      ELSE
          CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK-COMP')
      ENDIF

C---- Reset flag
      FIRST = .FALSE.

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINRPT  -   Plot the distance restraints graph
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINRPT(PLTYPE,PLOTNO,THEPIN,NPIN,FPIN,IGRAPH,NGRAPH,
CHECK v.3.4.3-->
C     -    NFILE,PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,PINVCT,PINVLB,
     -    PINBOT,PINTOP,PINVAL,PINLOW,PINUPP,PINVCT,PINVLB,
CHECK v.3.4.3<--
     -    RESTRN,MKSIZE,YRORIG,YRSEP,YRWID,NYGAP,YLAST)

      INCLUDE 'vplot.inc'

      CHARACTER*1   DTYPE(MXFILE), LMS, RTYPE(MXFILE)
      CHARACTER*3   NUMBER, NVIOL
      CHARACTER*4   ATNAM1, ATNAM2, LSTATM
      CHARACTER*9   LSTRES
      CHARACTER*12  RESNAM
      CHARACTER*28  RESTRN(MXPINS)
      CHARACTER*60  PLTHED, PLTYH1, PLTYH2
      INTEGER       FPIN, ICOLR, IGRAPH, IMODEL, IPIN, IPOS,
CHECK v.3.4.3-->
C     -              LABNUM(MXFILE), LMID, LSTUPD, NFILE, NGRAPH, NMID,
     -              LABNUM(MXFILE), LMID, LSTUPD, NGRAPH, NMID,
CHECK v.3.4.3<--
     -              NOFFDN, NOFFUP, NPIN, NYGAP, PINVCT(MXPINS),
CHECK v.3.4.3-->
C     -              PINVLB(MXPINS), PLOTNO, PLTHLN, PLTYLN, PLTYPE,
C     -              RLEN, THEPIN, UPDOWN
     -              PINVLB(MXPINS), PLOTNO, PLTHLN, PLTY, PLTYLN,
     -              PLTYL1, PLTYPE, RLEN, THEPIN, UPDOWN
CHECK v.3.4.3<--
      REAL          DX, MKSIZE, PINBOT, PINLOW(MXPINS), PINTOP,
     -              PINUPP(MXPINS), PINVAL(MXFILE,MXPINS), SCALEX,
     -              SCALEY, STEPX, TSIZE, X, XCENTR, XMID, XT1, XT2,
     -              X1, X2, X3, Y, YDIFF, YLAST, YLET, YLLAST, YP,
     -              YRORIG, YRSEP, YRWID, YT1, YT2, YULAST, Y1, Y2

      DATA DX     / 1.5 /
CHECK v.3.4.3-->
C      DATA PLTYH1 / 'Actual distance' /
      DATA PLTYH1 / 'Actual distance (A)' /
CHECK v.3.4.3<--
      DATA PLTYH2 / '- restraint (A)' /
CHECK v.3.4.3-->
C      DATA PLTYLN / 15 /
      DATA PLTYLN, PLTYL1 / 15, 19 /
CHECK v.3.4.3<--

C---- Initialise variables
      PLTHED = ' '
      PLTHLN = 1
      XCENTR = XPORIG + XPWID / 2.0
      SCALEX = XPWID / THEPIN
      STEPX = SCALEX

C---- Determine position on page
      YP = YRORIG + (NGRAPH - IGRAPH) * (YRWID + YRSEP)
      YLAST = YP
CHECK v.3.4.3-->
      IF (PLOTNO.EQ.1) THEN
          PLTY = PLTYL1
      ELSE
          PLTY = PLTYLN
      ENDIF
CHECK v.3.4.3<--

C---- Plot the graph box and axes
      CALL PINGBX(XPORIG,YP,XPWID,YRWID,BSHADE(PLTYPE),PINBOT,PINTOP,
CHECK v.3.4.3-->
C     -    FPIN,FPIN + THEPIN,PLTHED,PLTHLN,PLTYH1,PLTYLN,PLTYH2,PLTYLN,
     -    FPIN,FPIN + THEPIN,PLTHED,PLTHLN,PLTYH1,PLTY,PLTYH2,PLTYLN,
CHECK v.3.4.3<--
     -    INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(2,PLTYPE),COLPLT(3,PLTYPE),
     -    NYGAP,SCALEY,PLOTNO)

C---- Print marker showing violation region
      Y = YP - PINBOT * SCALEY
      IF (PLOTNO.NE.1) THEN
          CALL PSRTXT(XPORIG + XPWID + 8.0,Y,8.0,'VIOLATION')
      ENDIF

C---- Initialise variables
      UPDOWN = 0
      LSTATM = ' '
      LSTRES = ' '
      LSTUPD = UPDOWN
      XMID = 0.0
      LMID = 0
      NMID = 0
      YLLAST = 0.0
      YULAST = 0.0

C---- Loop through all the data points
      DO 600, IPIN = 1, NPIN

C----     For restraints print, shade in the regions outside the
C         upper and lower boundaries
          IF (PLOTNO.EQ.1) THEN
              X = XPORIG + (REAL(IPIN) - 0.5) * SCALEX
              X1 = X - STEPX / 2.0
              X2 = X + STEPX / 2.0
              Y1 = YP + (PINLOW(IPIN) - PINBOT) * SCALEY
              Y2 = YP + (PINUPP(IPIN) - PINBOT) * SCALEY

C----         Check that not off end of graph
              IF (Y1.LT.YP) Y1 = YP
              IF (Y2.GT.YP + YRWID) Y2 = YP + YRWID

C----         Lower-bound
              CALL PSHADE(0.8,COLPLT(4,PLTYPE),RGB,MXCOLR,
     -            INCOLR(PLTYPE))
              CALL PSUBOX(X1,YP,X1,Y1,X2,Y1,X2,YP)

C----         Draw line corresponding to lower-bound position and
C             join to previous lower-bound position, if there was one
              CALL PSLINE(X1,Y1,X2,Y1)
              IF (YLLAST.NE.0.0) THEN
                  CALL PSLINE(X1,YLLAST,X1,Y1)
              ENDIF
              YLLAST = Y1

C----         Upper-bound
              CALL PSHADE(0.9,COLPLT(3,PLTYPE),RGB,MXCOLR,
     -            INCOLR(PLTYPE))
              CALL PSUBOX(X1,Y2,X1,YP + YRWID,X2,YP + YRWID,X2,Y2)

C----         Draw line corresponding to upper-bound position and
C             join to previous upper-bound position, if there was one
              CALL PSLINE(X1,Y2,X2,Y2)
              IF (YULAST.NE.0.0) THEN
                  CALL PSLINE(X1,YULAST,X1,Y2)
              ENDIF
              YULAST = Y2
          ENDIF

C----     If residue has changed, then draw line to indicate the change
          IF (LSTRES.NE.' ' .AND. RESTRN(IPIN)(1:9).NE.LSTRES) THEN

C----         Write name of previous residue
              IF (NMID.GT.0) THEN
                  XMID = XMID / NMID

C----             Extract and format the name of the previous residue
                  CALL FMTRES(LSTRES,RESNAM,RLEN)
                  IF (LMID.NE.0 .AND. LMID + NMID.LT.7) THEN
                      UPDOWN = 1 - LSTUPD
                  ELSE
                      UPDOWN = 0
                  ENDIF
                  LSTUPD = UPDOWN
                  YDIFF = 24.0 + UPDOWN * 9.0
                  CALL PSCTXT(XMID,YP - YDIFF,9.0,RESNAM(1:RLEN))
              ENDIF

C----         Get x-coordinates for line and plot it
              X = XPORIG + (IPIN - 1) * SCALEX
              CALL PSLINE(X,YP - 14.0,X,YP + YRWID)

C----         Reinitialise variables
              XMID = 0.0
              LMID = NMID
              NMID = 0

C----     If atom has changed within this residue, then draw a short line
C         to indicate the change
          ELSE IF (LSTATM.NE.' ' .AND.
     -        RESTRN(IPIN)(10:13).NE.LSTATM) THEN

C----         Get x-coordinates for line and plot it
              X = XPORIG + (IPIN - 1) * SCALEX
              CALL PSLINE(X,YP - 3.0,X,YP + 8.0)
          ENDIF

C----     Calculate x-position
          X = XPORIG + (REAL(IPIN) - 0.5) * SCALEX
          XMID = XMID + X
          NMID = NMID + 1

C----     Extract the two atom-names and print
          ATNAM1 = RESTRN(IPIN)(10:13)
          ATNAM2 = RESTRN(IPIN)(24:27)
CHECK v.3.4.3-->
C         CALL PSRTXT(X + DX,YP - 14.0,6.0,ATNAM1)
          CALL PSRTXT(X + DX,YP - 17.0,6.0,ATNAM1)
CHECK v.3.4.3<--
          CALL PSRTXT(X + DX,YP + YRWID + 3.0,6.0,ATNAM2)

C----     Get the second residue name and print
          CALL FMTRES(RESTRN(IPIN)(15:23),RESNAM,RLEN)
CHECK v.3.4.3-->
C          CALL PSRTXT(X + DX,YP + YRWID + 18.0,6.0,RESNAM(1:RLEN))
          CALL PSRTXT(X + DX,YP + YRWID + 20.0,6.0,RESNAM(1:RLEN))
CHECK v.3.4.3<--

C----     Print whether restraint is long/medium/short
          LMS = RESTRN(IPIN)(14:14)
          Y = YP + 4.0
          IF ((LMS.EQ.'L' .OR. LMS.EQ.'M') .AND. INCLUS) Y = Y + 2.0
          IF (LMS.EQ.'L' .AND. INCLUM) Y = Y + 2.0
          YLET = Y
          ICOLR = 1
          IF (LMS.EQ.'L') ICOLR = COLPNT(1)
          IF (LMS.EQ.'M') ICOLR = COLPNT(2)
          IF (LMS.EQ.'S') ICOLR = COLPNT(3)
          IF (INCOLR(PLTYPE)) THEN
              CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
          ENDIF
          CALL PSCTXT(X,Y,6.0,LMS)

C----     Reset text colour
          IF (INCOLR(PLTYPE)) THEN
              CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
          ENDIF

C----     Print number of upper-bound restraint violations
          IF (PINVCT(IPIN).GT.0) THEN

C----         Calculate coordinates of caret 
              X1 = X - 0.5 * MKSIZE
              X2 = X + 0.5 * MKSIZE
              X3 = (X1 + X2) / 2.0
              Y1 = YP + YRWID - 4.0 + 0.3 * MKSIZE
              Y2 = YP + YRWID - 4.0 + 0.6 * MKSIZE

C----         If in colour, plot a triangle of the approriate colour
              IF (INCOLR(PLTYPE)) THEN
                  CALL PSLWID(0.6)
                  CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
                  CALL PSLINE(X1,Y1,X3,Y2)
                  CALL PSLINE(X3,Y2,X2,Y1)
                  CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
                  CALL PSLWID(0.2)
              ENDIF

C----         Print the number of violations
              WRITE(NVIOL,220) PINVCT(IPIN)
 220          FORMAT(I3)
              IPOS = 1
              IF (NVIOL(1:1).EQ.' ') IPOS = 2
              IF (NVIOL(2:2).EQ.' ') IPOS = 3
              IF (NMODEL.LT.10) THEN
                  TSIZE = 6.0
              ELSE
CHECK v.3.4.3-->
C                  TSIZE = 4.0
                  TSIZE = 5.5
CHECK v.3.4.3<--
              ENDIF
              CALL PSCTXT(X,YP + YRWID - 5.0,TSIZE,NVIOL(IPOS:3))

C----         Print caret above the L/M/S symbol
              Y1 = YLET + 0.75 + 0.3 * MKSIZE
              Y2 = YLET + 0.75 + 0.6 * MKSIZE
              CALL PSLWID(0.6)
              CALL PSLINE(X1,Y1,X3,Y2)
              CALL PSLINE(X3,Y2,X2,Y1)
              CALL PSLWID(0.2)
          ENDIF

C----     Print number of lower-bound restraint violations
          IF (PINVLB(IPIN).GT.0) THEN

C----         Calculate coordinates of upside-down caret 
              X1 = X - 0.5 * MKSIZE
              X2 = X + 0.5 * MKSIZE
              X3 = (X1 + X2) / 2.0
              Y1 = YP + YRWID - 6.0 - TSIZE - 0.3 * MKSIZE
              Y2 = YP + YRWID - 6.0 - TSIZE - 0.6 * MKSIZE

C----         If in colour, plot an arrow of the approriate colour
              IF (INCOLR(PLTYPE)) THEN
                  CALL PSLWID(0.6)
                  CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
                  CALL PSLINE(X1,Y1,X3,Y2)
                  CALL PSLINE(X3,Y2,X2,Y1)
                  CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
                  CALL PSLWID(0.2)
              ENDIF

C----         Print the number of violations
              WRITE(NVIOL,220) PINVLB(IPIN)
              IPOS = 1
              IF (NVIOL(1:1).EQ.' ') IPOS = 2
              IF (NVIOL(2:2).EQ.' ') IPOS = 3
              IF (NMODEL.LT.10) THEN
                  TSIZE = 6.0
              ELSE
                  TSIZE = 4.0
              ENDIF
              CALL PSCTXT(X,YP + YRWID - 5.0 - TSIZE,TSIZE,
     -            NVIOL(IPOS:3))

C----         Print caret below the L/M/S symbol
              Y1 = YLET - 0.75 - 0.3 * MKSIZE
              Y2 = YLET - 0.75 - 0.6 * MKSIZE
              CALL PSLWID(0.6)
              CALL PSLINE(X1,Y1,X3,Y2)
              CALL PSLINE(X3,Y2,X2,Y1)
              CALL PSLWID(0.2)
          ENDIF

C----     Initialise all the point labels and types
          DO 500, IMODEL = 1, NMODEL
              LABNUM(IMODEL) = ACTNUM(IMODEL)
              DTYPE(IMODEL) = RESTRN(IPIN)(14:14)
              RTYPE(IMODEL) = RESTRN(IPIN)(28:28)
 500      CONTINUE

C----     Print all the data points for this restraint
          CALL PLTPTS(PINVAL(1,IPIN),NMODEL,X,YP,PINBOT,PINTOP,MKSIZE,
     -        DTYPE,RTYPE,SCALEY,PLTYPE,.TRUE.,LABNUM,TOPMOD,NOFFDN,
     -        NOFFUP)

C----     If any points off the graph, show appropriate symbols
          XT1 = X - MKSIZE / 2.0
          XT2 = X + MKSIZE / 2.0
          IF (NOFFUP.GT.0) THEN
              YT1 = YP + YRWID + 38.0
              YT2 = YT1 + MKSIZE
              CALL PSHADE(0.0,1,RGB,MXCOLR,.FALSE.)
              CALL PSTRIA(XT1,YT1,(XT1 + XT2) / 2.0,YT2,XT2,YT1)
              WRITE(NUMBER,520) NOFFUP
 520          FORMAT(I3)
              IPOS = 1
              IF (NUMBER(1:1).EQ.' ') IPOS = 2
              IF (NUMBER(2:2).EQ.' ') IPOS = 3
              CALL PSCTXT((XT1 + XT2) / 2.0,YT2 + 4.0,6.0,
     -            NUMBER(IPOS:3))
          ELSE IF (NOFFDN.GT.0) THEN
              YT1 = YP - 15.0
              YT2 = YT1 - MKSIZE
              CALL PSHADE(0.0,1,RGB,MXCOLR,.FALSE.)
              CALL PSTRIA(XT1,YT1,(XT1 + XT2) / 2.0,YT2,XT2,YT1)
              WRITE(NUMBER,520) NOFFDN
              IPOS = 1
              IF (NUMBER(1:1).EQ.' ') IPOS = 2
              IF (NUMBER(2:2).EQ.' ') IPOS = 3
              CALL PSCTXT((XT1 + XT2) / 2.0,YT2 - 4.0,6.0,
     -            NUMBER(IPOS:3))
          ENDIF

C----     Store current residue and atom names
          LSTATM = RESTRN(IPIN)(10:13)
          LSTRES = RESTRN(IPIN)(1:9)

 600  CONTINUE

C---- Write name of last residue
      IF (NMID.GT.0) THEN
          XMID = XMID / NMID

C----     Extract and format the name of the previous residue
          CALL FMTRES(LSTRES,RESNAM,RLEN)
          IF (LMID.NE.0 .AND. LMID + NMID.LT.7) THEN
              UPDOWN = 1 - LSTUPD
          ELSE
              UPDOWN = 0
          ENDIF
          LSTUPD = UPDOWN
          YDIFF = 24.0 + UPDOWN * 9.0
          CALL PSCTXT(XMID,YP - YDIFF,9.0,RESNAM(1:RLEN))
      ENDIF

C---- Redraw outer border
      CALL PSLWID(0.6)
      CALL PSLINE(XPORIG,YP,XPORIG,YP + YRWID)
      CALL PSLINE(XPORIG,YP + YRWID,XPORIG + XPWID,YP + YRWID)
      CALL PSLINE(XPORIG + XPWID,YP + YRWID,XPORIG + XPWID,YP)
      CALL PSLINE(XPORIG + XPWID,YP,XPORIG,YP)
      CALL PSLWID(0.2)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINGBX  -  Print current graph for distance restraints plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINGBX(XPORIG,YP,XPWID,YPWID,BSHADE,YMIN,YMAX,FPIN,
     -    LPIN,IREC,LIREC,JREC,LJREC,KREC,LKREC,INCOLR,MXCOLR,RGB,
     -    BCOL,SHDCOL,NYGAP,SCALEY,PLOTNO)

      CHARACTER*60  IREC, JREC, KREC
      INTEGER       BCOL, FPIN, INTRL, LPIN, LIREC, LJREC, LKREC,
     -              MXCOLR, NYGAP, PLOTNO, SHDCOL
      LOGICAL       BSHADE, INCOLR
      REAL          RGB(3,MXCOLR), SCALEY, XCENTR, XP, XPORIG, XPWID,
     -              Y, YCENTR, YMAX, YMIN, YP, YPWID, YSPAN

C---- Calculate y-scale
      SCALEY = YPWID / (ABS(YMIN) + YMAX)
      Y = YP + SCALEY * ABS(YMIN)
      YSPAN = YMAX - YMIN

C---- Draw box and axis labels
      XP = XPORIG
      IF (BSHADE) THEN
          IF (PLOTNO.EQ.1) THEN
              CALL PSHADE(0.996,BCOL,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(XP,YP,XP,YP + YPWID,XP + XPWID,YP + YPWID,
     -            XP + XPWID,YP)
          ELSE
              CALL PSHADE(0.996,BCOL,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(XP,YP,XP,Y,XP + XPWID,Y,XP + XPWID,YP)
              CALL PSHADE(0.9,SHDCOL,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(XP,Y,XP,YP + YPWID,XP + XPWID,YP + YPWID,
     -            XP + XPWID,Y)
          ENDIF
      ENDIF

C---- Draw x-axis as dotted line
      IF (PLOTNO.NE.1) THEN
          CALL PSDASH(2)
          CALL PSLINE(XP,Y,XP + XPWID,Y)
          CALL PSDASH(0)
      ENDIF

C---- Plot graph-box and axes
      XCENTR = XPORIG + XPWID / 2.0
      YCENTR = YP + YPWID / 2.0
      INTRL = 0
      IF (YSPAN.LE.3.0) INTRL = 1
      CALL AXES(XP,XP + XPWID,YP,YP + YPWID,0,NYGAP,REAL(FPIN),
     -    REAL(LPIN),YMIN,YMAX,10.0,0,INTRL,15.0,.TRUE.,.TRUE.,
     -    .FALSE.,.FALSE.,.FALSE.)

C---- Sub-heading and x-axis title
      CALL PSCTXT(XCENTR,YP + YPWID + 10.0,15.0,IREC(1:LIREC))
C      CALL PSCTXT(XCENTR,YP - 25.0,12.0,'Residue')

C---- y-axis headings
      IF (PLOTNO.EQ.1) THEN
          CALL PSRCTX(XPORIG - 30.0,YP + YPWID / 2.0,10.0,
     -        JREC(1:LJREC))
      ELSE 
          CALL PSRCTX(XPORIG - 40.0,YP + YPWID / 2.0,10.0,
     -        JREC(1:LJREC))
          CALL PSRCTX(XPORIG - 30.0,YP + YPWID / 2.0,10.0,
     -        KREC(1:LKREC))
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLTPTS  -   Plot the current set of data points
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PLTPTS(PLTVAL,NPOINT,X,YP,YMIN,YMAX,MKSIZE,DTYPE,
     -    RTYPE,SCALEY,PLTYPE,LABPT,LABNUM,TOPNUM,NOFFDN,NOFFUP)

      INCLUDE 'vplot.inc'

      INTEGER       NPOINT

      CHARACTER*1   DTYPE(NPOINT), RTYPE(NPOINT)
      CHARACTER*3   NUMBER
      INTEGER       ICOLR, IENTRY, IPOINT, IPOS, LABNUM(NPOINT),
     -              NOFFDN, NOFFUP, PINDEX(MXPNT), PLTYPE, TOPNUM
      LOGICAL       LABPT
      REAL          MKSIZE, PLTVAL(NPOINT), SCALEY, SHADE, TSIZE, X,
     -              XMID, X1, X2, Y, YMAX, YMID, YMIN, YP, Y1, Y2

C---- Initialise sort index array
      DO 100, IPOINT = 1, MXPNT
          PINDEX(IPOINT) = IPOINT
 100  CONTINUE
      NOFFDN = 0
      NOFFUP = 0

C---- Sort the data points according to their y-value
      CALL SHSORT(NPOINT,PLTVAL,NPOINT,PINDEX)

C---- Loop over all the models in the ensemble
      DO 400, IPOINT = 1, NPOINT

C----     Get the next file number
          IENTRY = PINDEX(NPOINT - IPOINT + 1)

C----     Process only if within the limits of the graph
          IF (PLTVAL(IENTRY).LE.YMAX .AND. PLTVAL(IENTRY).GE.YMIN) THEN

C----         Calculate the y-value for this data point
              Y = YP + (PLTVAL(IENTRY) - YMIN) * SCALEY

C----         Get the colour according to the restraint type
              ICOLR = 1
              IF (DTYPE(IENTRY).EQ.'L') ICOLR = COLPNT(1)
              IF (DTYPE(IENTRY).EQ.'M') ICOLR = COLPNT(2)
              IF (DTYPE(IENTRY).EQ.'S') ICOLR = COLPNT(3)

C----         If this is an NOE restraint, plot as a box
              IF (RTYPE(IENTRY).EQ.'N') THEN

C----             Plot the box
                  CALL PSLWID(0.2)
                  SHADE = 1.0
                  X1 = X - MKSIZE / 2.0
                  X2 = X + MKSIZE / 2.0
                  Y1 = Y - MKSIZE / 2.0
                  Y2 = Y + MKSIZE / 2.0
                  CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
                  CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----         If this is a hydrogen-bond restraint, plot as a circle
              ELSE IF (RTYPE(IENTRY).EQ.'H') THEN

C----             Plot the circle
                  CALL PSLWID(0.05)
                  IF (INCOLR(PLTYPE)) THEN
                      CALL PSCCOL(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ELSE
                      CALL PSCSHD(1.0)
                  ENDIF
                  CALL PSCIRC(X,Y,0.6 * MKSIZE)
                  CALL PSLWID(0.2)

C----         If this is a disulphide restraint, plot as a diamond
              ELSE IF (RTYPE(IENTRY).EQ.'S') THEN

C----             Plot the box
                  CALL PSLWID(0.1)
                  SHADE = 1.0
                  X1 = X - 0.7 * MKSIZE
                  X2 = X + 0.7 * MKSIZE
                  XMID = (X1 + X2) / 2.0
                  Y1 = Y - 0.7 * MKSIZE
                  Y2 = Y + 0.7 * MKSIZE
                  YMID = (Y1 + Y2) / 2.0
                  CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
                  CALL PSBBOX(X1,YMID,XMID,Y2,X2,YMID,XMID,Y1)
              ENDIF

C----         Label point with its model number, if required
              IF (LABPT) THEN
                  WRITE(NUMBER,310) LABNUM(IENTRY)
 310              FORMAT(I3)
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  IF (TOPNUM.LT.10) THEN
                      TSIZE = 5.0
                  ELSE
                      TSIZE = 4.0
                  ENDIF
                  CALL PSCTXT(X,Y,TSIZE,NUMBER(IPOS:))

C----         Otherwise, label it with its range: Long, Medium or Short
              ELSE
                  TSIZE = 6.0
                  CALL PSCTXT(X,Y,TSIZE,DTYPE(IENTRY))
              ENDIF

C----     Otherwise, increment counts of points off the graph
          ELSE IF (PLTVAL(IENTRY).GT.YMAX) THEN 
              NOFFUP = NOFFUP + 1
          ELSE IF (PLTVAL(IENTRY).LT.YMIN) THEN
              NOFFDN = NOFFDN + 1
          ENDIF
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE FMTRES  -   Format the given residue name from name, sequence
C                         and chain-ID
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE FMTRES(RESIN,RESNAM,RLEN)

      CHARACTER*1   A, RCHAR
      CHARACTER*3   CHNAME, RESDUE
      CHARACTER*5   RESNUM
      CHARACTER*9   RESIN
      CHARACTER*12  RESNAM
      CHARACTER*26  LOWER
      INTEGER       FPOS, IPOS, LPOS, N, RLEN

      DATA  A      / 'A' /
      DATA  LOWER / 'abcdefghijklmnopqrstuvwxyz' /

C---- Convert residue name into upper- and lower-case
      RESDUE = RESIN(7:9)
      RCHAR = RESDUE(2:2)
      N = ICHAR(RCHAR) - ICHAR(A) + 1
      IF (N.GE.1 .AND. N.LE.26) RESDUE(2:2) = LOWER(N:N)
      RCHAR = RESDUE(3:3)
      N = ICHAR(RCHAR) - ICHAR(A) + 1
      IF (N.GE.1 .AND. N.LE.26) RESDUE(3:3) = LOWER(N:N)

C---- Remove blanks from residue number
      FPOS = 0
      LPOS = 0
      RESNUM = RESIN(2:6)
      DO 100, IPOS = 1, 5
          IF (RESNUM(IPOS:IPOS).NE.' ') THEN
              IF (FPOS.EQ.0) THEN
                  FPOS = IPOS
              ENDIF
              LPOS = IPOS
          ENDIF
 100  CONTINUE
      RLEN = 4 + (LPOS - FPOS + 1)

C---- If there is a chain-ID, add that
      CHNAME = ' '
      IF (RESIN(1:1).NE.' ') THEN
          CHNAME = '(' // RESIN(1:1) // ')'
          RLEN = RLEN + 3
      ENDIF

C---- Form the full residue name and print
      RESNAM = RESDUE // ' ' // RESNUM(FPOS:LPOS) // CHNAME

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLTKEY  -   Plot the explanatory key below last graph plotted
C                         on current page
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PLTKEY(YLAST,MKSIZE,NFILE,PLTYPE,PLOTNO)

      INCLUDE 'vplot.inc'

      CHARACTER*1   LSM
      CHARACTER*110 TEXT
      INTEGER       BCOL, COLLOW, COLUPP, ICOLR, LENSTR, NFILE, PLOTNO,
     -              PLTYPE, PT1, PT2
      REAL          MKSIZE, SHADE, TSIZE, XMID, X, X1, X2, X3, Y, YBOT,
     -              YLAST, YMID, YORG, YTEXT, YTOP, Y1, Y2

C---- Initialise variables
      BCOL = COLPLT(2,PLTYPE)
      COLUPP = COLPLT(3,PLTYPE)
      COLLOW = COLPLT(4,PLTYPE)
      IF (NFILE.LT.10) THEN
          TSIZE = 6.0
      ELSE
          TSIZE = 4.0
      ENDIF
      LSM = 'S'
      ICOLR = COLPNT(3)
      IF (.NOT.INCLUS) THEN
          LSM = 'M'
          ICOLR = COLPNT(2)
          IF (.NOT.INCLUM) THEN
              LSM = 'L'
              ICOLR = COLPNT(1)
          ENDIF
      ENDIF

C---- Plot heading
      CALL PSCTXT(XPORIG + 10.0,YLAST - 55.0,12.0,'Key:-')

C---- Print descriptions of shading regions
      YBOT = YLAST - 100.0
      YTOP = YLAST -  50.0
      YORG = YLAST -  70.0
      X1 = XPORIG + 51.0
      Y1 = YTOP - 8.0
      IF (PLOTNO.EQ.1) THEN
          CALL PSCTXT(X1,Y1,6.0,'Upper-bound')
          Y1 = Y1 - 6.0
          CALL PSCTXT(X1,Y1,6.0,'restraint')
          Y1 = YBOT + 10.0
          CALL PSCTXT(X1,Y1,6.0,'Lower-bound')
          Y1 = Y1 - 6.0
          CALL PSCTXT(X1,Y1,6.0,'restraint')
      ELSE
          CALL PSCTXT(X1,Y1,6.0,'Restraint')
          Y1 = Y1 - 6.0
          CALL PSCTXT(X1,Y1,6.0,'violation')
          Y1 = YBOT + 22.0
          CALL PSCTXT(X1,Y1,6.0,'Within')
          Y1 = Y1 - 6.0
          CALL PSCTXT(X1,Y1,6.0,'upper-bound')
      ENDIF

C---- Plot graph-section
      X1 = XPORIG + 71.0
      X2 = X1 + 8.0
      XMID = (X1 + X2) / 2.0
      X = XMID
      IF (PLOTNO.EQ.1) THEN
          CALL PSHADE(0.996,BCOL,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSUBOX(X1,YBOT,X1,YTOP,X2,YTOP,X2,YBOT)
          CALL PSHADE(0.9,COLUPP,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSUBOX(X1,YORG,X1,YTOP,X2,YTOP,X2,YORG)
          CALL PSLINE(X1,YORG,X2,YORG)
          CALL PSHADE(0.8,COLLOW,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSUBOX(X1,YORG - 20.0,X1,YBOT,X2,YBOT,X2,YORG - 20.0)
          CALL PSLINE(X1,YORG - 20.0,X2,YORG - 20.0)
      ELSE IF (BSHADE(PLTYPE)) THEN
          CALL PSHADE(0.996,BCOL,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSUBOX(X1,YBOT,X1,YORG,X2,YORG,X2,YBOT)
          CALL PSHADE(0.9,COLUPP,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSUBOX(X1,YORG,X1,YTOP,X2,YTOP,X2,YORG)
      ENDIF

C---- Draw box around the section
      CALL PSLINE(X1,YBOT,X1,YTOP)
      CALL PSLINE(X1,YTOP,X2,YTOP)
      CALL PSLINE(X2,YTOP,X2,YBOT)
      CALL PSLINE(X2,YBOT,X1,YBOT)

C---- Draw x-axis as dotted line
      IF (PLOTNO.NE.1) THEN
          CALL PSDASH(2)
          CALL PSLINE(X1,YORG,X2,YORG)
          CALL PSDASH(0)
      ENDIF

C---- Write in no. of upper- and lower-bound violations
      Y = YTOP - 5.0
      CALL PSCTXT(X,Y,TSIZE,'3')
      CALL PSTEXT(X + 10.0,Y,6.0,'Number of upper-bound violations')
      Y = Y - TSIZE
      CALL PSCTXT(X,Y,TSIZE,'2')
      CALL PSTEXT(X + 10.0,Y,6.0,'Number of lower-bound violations')

C---- If in colour, plot the triangles of the appropriate colour
      IF (INCOLR(PLTYPE)) THEN
          X1 = X - 0.5 * MKSIZE
          X2 = X + 0.5 * MKSIZE
          X3 = (X1 + X2) / 2.0
          Y1 = YTOP - 4.0 + 0.3 * MKSIZE
          Y2 = YTOP - 4.0 + 0.6 * MKSIZE
          CALL PSLWID(0.6)
          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
          CALL PSLINE(X1,Y1,X3,Y2)
          CALL PSLINE(X3,Y2,X2,Y1)
          X1 = X - 0.5 * MKSIZE
          X2 = X + 0.5 * MKSIZE
          X3 = (X1 + X2) / 2.0
          Y1 = YTOP - 6.0 - TSIZE - 0.3 * MKSIZE
          Y2 = YTOP - 6.0 - TSIZE - 0.6 * MKSIZE
          CALL PSLINE(X1,Y1,X3,Y2)
          CALL PSLINE(X3,Y2,X2,Y1)
          CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
          CALL PSLWID(0.2)
      ENDIF

C---- Write in restraint type: long/medium/short
      IF (INCOLR(PLTYPE)) THEN
          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
      ENDIF
      Y = YBOT + 4.0
      CALL PSCTXT(X,Y,6.0,LSM)
      IF (INCOLR(PLTYPE)) THEN
          CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
      ENDIF
      TEXT = 'L=Long-range (sequence sep. > 4 residues), M=medium (s' //
     -    'ep.<= 4 residues), S=short (same residue)'
      IF (DCLASS) THEN
          WRITE(TEXT,220) CLASS(1,1), CLASS(2,1), CLASS(1,2),
     -        CLASS(2,2), CLASS(1,3), CLASS(2,3)
 220      FORMAT('S=short-range (',F5.2,' -',F5.2,' A), M=Medium (',
     -        F5.2,' -',F5.2,' A), L=Long (',F5.2,' -',F5.2,' A)')
          PT1 = 32
          PT2 = 59
      ELSE
          TEXT = 'S=short-range (same residue), M=Medium (sep. <= 4 ' //
     -        'residues), L=Long (sequence sep. > 4 residues)'
          PT1 = 30
          PT2 = 61
      ENDIF
      IF (INCOLR(PLTYPE)) THEN
          ICOLR = COLPNT(3)
          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
      ENDIF
      CALL PSTEXT(X + 10.0,Y,6.0,TEXT(1:PT1))
      IF (INCOLR(PLTYPE)) THEN
          ICOLR = COLPNT(2)
          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
      ENDIF
      CALL PSTEXT(X + 86.0,Y,6.0,TEXT(PT1 + 1:PT2))
      IF (INCOLR(PLTYPE)) THEN
          ICOLR = COLPNT(1)
          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
      ENDIF
      CALL PSTEXT(X + 165.0,Y,6.0,TEXT(PT2 + 1:LENSTR(TEXT)))
      IF (INCOLR(PLTYPE)) THEN
          CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
      ENDIF
      Y = Y - 6.0

C---- Show symbols for upper- and lower-bound violations
      X1 = X + 14.0 - 0.5 * MKSIZE
      X2 = X + 14.0 + 0.5 * MKSIZE
      X3 = (X1 + X2) / 2.0
      Y1 = Y + 0.3 * MKSIZE - 1.0
      Y2 = Y + 0.6 * MKSIZE - 1.0
      CALL PSLINE(X1,Y1,X3,Y2)
      CALL PSLINE(X3,Y2,X2,Y1)
      TEXT = 'indicates upper-bound violation,'
      CALL PSTEXT(X + 20.0,Y,6.0,TEXT(1:LENSTR(TEXT)))
      X1 = X + 104.0 - 0.5 * MKSIZE
      X2 = X + 104.0 + 0.5 * MKSIZE
      X3 = (X1 + X2) / 2.0
      Y1 = Y - 0.3 * MKSIZE + 1.0
      Y2 = Y - 0.6 * MKSIZE + 1.0
      CALL PSLINE(X1,Y1,X3,Y2)
      CALL PSLINE(X3,Y2,X2,Y1)
      TEXT = 'indicates lower-bound violation.'
      CALL PSTEXT(X + 112.0,Y,6.0,TEXT(1:LENSTR(TEXT)))

C---- Plot two boxes in the unviolated regions

C---- Box 1
      CALL PSLWID(0.2)
      SHADE = 1.0
      Y = YORG - 6.0
      X1 = X - MKSIZE / 2.0
      X2 = X + MKSIZE / 2.0
      Y1 = Y - MKSIZE / 2.0
      Y2 = Y + MKSIZE / 2.0
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSCTXT(X,Y,TSIZE,'1')

C---- Box 2
      Y = YORG - 4.0
      Y1 = Y - MKSIZE / 2.0
      Y2 = Y + MKSIZE / 2.0
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSCTXT(X,Y,TSIZE,'2')

C---- Write explanatory text
      IF (PLOTNO.EQ.1) THEN
          TEXT = 'Actual distance between the given atoms in the dif' //
     -        'ferent models of the ensemble'
          CALL PSTEXT(X + 10.0,Y,6.0,TEXT(1:79))
      ELSE
          TEXT = 'Difference between actual distance and upper-bound' //
     -        ' restraint (or lower-bound, if violated)'
          CALL PSTEXT(X + 10.0,Y,6.0,TEXT(1:90))
      ENDIF
      Y = Y - 6.0
      YTEXT = Y - 1.0
      CALL PSTEXT(X + 10.0,YTEXT,6.0,'for:-')
      X = X + 35.0

C---- Plot box for NOEs
      X1 = X - MKSIZE / 2.0
      X2 = X + MKSIZE / 2.0
      Y1 = Y - MKSIZE / 2.0
      Y2 = Y + MKSIZE / 2.0
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSCTXT(X,Y,TSIZE,'1')
      X = X + 8.0
      CALL PSTEXT(X,YTEXT,6.0,'NOE')
      X = X + 30.0

C---- Plot circle for H-bonds
      CALL PSLWID(0.05)
      IF (INCOLR(PLTYPE)) THEN
          CALL PSCCOL(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
      ELSE
          CALL PSCSHD(1.0)
      ENDIF
      CALL PSCIRC(X,Y,0.6 * MKSIZE)
      CALL PSLWID(0.2)
      CALL PSCTXT(X,Y,TSIZE,'1')
      X = X + 8.0
      CALL PSTEXT(X,YTEXT,6.0,'H-bond')
      X = X + 39.0

C---- Plot diamond for disulphides
      CALL PSLWID(0.1)
      SHADE = 1.0
      X1 = X - 0.7 * MKSIZE
      X2 = X + 0.7 * MKSIZE
      X3 = (X1 + X2) / 2.0
      Y1 = Y - 0.7 * MKSIZE
      Y2 = Y + 0.7 * MKSIZE
      YMID = (Y1 + Y2) / 2.0
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,YMID,X3,Y2,X2,YMID,X3,Y1)
      CALL PSCTXT(X,Y,TSIZE,'1')
      X = X + 8.0
      CALL PSTEXT(X,YTEXT,6.0,'disulphide')

C---- Print explanation of shading
      X = XMID
      Y = Y - 8.0
      IF (PLOTNO.EQ.1) THEN
          TEXT = 'Shading indicates regions outside restraint bounda' //
     -        'ries'
          CALL PSTEXT(X + 10.0,Y,6.0,TEXT(1:54))
      ENDIF

C---- If any restraint types have been excluded, then show this on the plot
      X = XPORIG + XPWID - 118.0
      Y = YTOP + 2.0
      CALL PLEXCL(X,Y)
      IF (EXDUPL) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Same-residue duplicates excluded')
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLEXCL  -   Plot the explanatory note about excluded
C                         restraint types
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PLEXCL(X,Y)

      INCLUDE 'vplot.inc'

      REAL          X, Y

C---- Print exclusion information
      IF (VIONLY) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Note: only violated restraints shown')
      ENDIF
      X = X + 19.0
      IF (.NOT.INCLUS) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Short-range restraints excluded')
      ENDIF
      IF (.NOT.INCLUM) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Medium-range restraints excluded')
      ENDIF
      IF (.NOT.INCLUL) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Long-range restraints excluded')
      ENDIF
      IF (.NOT.TYPENO) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* NOE restraints excluded')
      ENDIF
      IF (.NOT.TYPEHB) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* H-bond restraints excluded')
      ENDIF
      IF (.NOT.TYPESS) THEN
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'* Disulphide restraints excluded')
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSUMPL  -   Produce the restraints summary plots showing
C                         numbers of restraints, violations at different
C                         distances for long, medium and short-range
C                         restraints, and violation frequencies
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE RSUMPL(PLTYPE,ACDIST,NFILE,MAXCON,PLTREQ)

      INCLUDE 'vplot.inc'

      INTEGER       NGRAPH
      PARAMETER    (NGRAPH = 4)

      REAL          BARWID, XMORIG, XMWID, YMORIG, YMSEP, YMWID, XSORIG,
     -              XSWID, YSORIG, YSSEP, YSWID
      PARAMETER    (
     -              BARWID =    0.1,
     -              XMORIG =   78.0,
     -              XMWID  =  452.0,
     -              YMORIG =  120.0,
     -              YMSEP  =   55.0,
     -              YMWID  =   90.0,
     -              XSORIG =  164.0,
     -              XSWID  =  300.0,
     -              YSORIG =  120.0,
     -              YSSEP  =    0.0,
     -              YSWID  =  130.0
     -             )

      INTEGER       MAXCON, NFILE

CHECK v.3.4.3-->
C      CHARACTER*1   BRLMS(MXBAR), BRTYPE(MXBAR), BRUPLO(MXBAR),
C     -              DTYPES(3), RTYPES(NCTYPE), UPPLOW(2)
      CHARACTER*1   BRLMS(MXBAR), BRTYPE(MXBAR), BRUPLO(MXBAR)
CHECK v.3.4.3<--
      CHARACTER*12  RGDESC(4)
      CHARACTER*6   NUMBER
      CHARACTER*9   HANDLE(3)
      CHARACTER*26  LOWLET
      CHARACTER*30  PLDESC(3)
      CHARACTER*50  RDESC(NCTYPE + 1,3)
      CHARACTER*60  PTITLE(3), SUBSUB, SUBTIT
      INTEGER       BARMAX, BARNO(MXBAR), BCOUNT(MXBAR), BINDEX(MXBAR),
     -              BVIOL(MXBAR), ICTYPE, IGRAPH, INTRL, IPOS, ITICK,
     -              JGRAPH, LENSTR, NBAR, NGAPSX, NGAPSY, NPAGE, NPOINT,
     -              NPTS(NCTYPE), NTOTAL, PLOTNO, PLTYPE, TOPTYP
      LOGICAL       FIRST, NOEND, NUMBEX, NUMBEY, PINOPE, PLTREQ, ZEROS
      REAL          ACDIST(NFILE + 2,MAXCON), DX, GWIDX, LSIZE, SCALEX,
     -              SCALEY, TSIZE, X, XCENTR, XLEFT, XMIN, XMAX, XORIG,
     -              XRIGHT, Y, YMIN, YMAX, YP, YWID

      DATA RDESC  / 
     -              'Numbers of NOE distance restraints',
     -              'Numbers of H-bond distance restraints',
     -              'Numbers of Disulphide distance restraints',
     -              'Numbers of all distance restraints',
     -              'NOE distance restraints',
     -              'H-bond distance restraints',
     -              'Disulphide distance restraints',
     -              'All distance restraints',
     -              'NOE distance restraints',
     -              'H-bond distance restraints',
     -              'Disulphide distance restraints',
     -              'All distance restraints' /
      DATA RGDESC / 'Short-range', 'Medium-range', 'Long-range',
     -              'Total' /
      DATA LOWLET / 'abcdefghijklmnopqrstuvwxyz' /
      DATA HANDLE / 'restrnsum',
     -              'resdifsum',
     -              'resvifreq' /
      DATA PLDESC / 'Numbers of distance restraints',
     -              'Restraint differences summary',
     -              'Restraint violation frequency' /
      DATA PTITLE / 'Numbers of distance restraints',
     -              'Restraint differences summary',
     -              'Restraint violation frequency' /

CHECK v.3.4.3-->
C      DATA UPPLOW / 'L', 'U' /
C      DATA DTYPES / 'S', 'M', 'L' /
C      DATA RTYPES / 'N', 'H', 'S' /
CHECK v.3.4.3<--

C---- Initialise variables
      FIRST = .TRUE.
      GWIDX  =  XMWID / 4.0
      IF (SUMSEP) GWIDX  =  XSWID
      YWID = YMWID
      IF (SUMSEP) YWID = YSWID
      PINOPE = .FALSE.
      PLOTNO = PLTYPE - 2
      DX = BARWID
      IF (PLOTNO.EQ.3) DX = 1.0
      IGRAPH = 0
      NPAGE = 0
      XCENTR = XMORIG + XMWID / 2.0
      IF (SUMSEP) XCENTR = XSORIG + XSWID / 2.0

C---- Accumulate the data for the bar plots on this page
CHECK v.3.4.3-->
C      CALL BRCALC(PLTYPE,PLOTNO,ACDIST,NFILE,MAXCON,DX,MXBAR,NBAR,
      CALL BRCALC(PLOTNO,ACDIST,NFILE,MAXCON,DX,NBAR,
CHECK v.3.4.3<--
     -    BRLMS,BRTYPE,BRUPLO,BARMAX,BARNO,BCOUNT,BINDEX,BVIOL,NPTS,
     -    NTOTAL,XMIN,XMAX,NGAPSX,YMIN,YMAX,NGAPSY)

C---- If plot not required, then exit
      IF (.NOT.PLTREQ) GO TO 999

C---- Calculate all the required graph parameters
      SCALEX = GWIDX / (XMAX - XMIN)
      SCALEY = YMWID / (YMAX - YMIN)
      IF (SUMSEP) SCALEY = YSWID / (YMAX - YMIN)

C---- Open new PostScript file
      CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE(PLOTNO),PLDESC(PLOTNO),
     -    HANDLE(PLOTNO),XCENTR)
      PINOPE = .TRUE.
      FIRST = .TRUE.

C---- For restraint differences plot, add an extra subheading
      IF (PLOTNO.EQ.2) THEN
          SUBSUB = 'Differences between actual distance and restrain' //
     -        't distance'
          CALL PSCTXT(XCENTR,BBOXY2 - 90.0,15.0,
     -        SUBSUB(1:LENSTR(SUBSUB)))

C---- For restraint differences plot, add an extra subheading
      ELSE IF (PLOTNO.EQ.3 .AND. NMODEL.GT.1) THEN
          IF (NMODEL.EQ.2) THEN
              SUBSUB = 'Numbers of restraints violated in 0, 1 or 2 ' //
     -            'models'
          ELSE IF (NMODEL.EQ.3) THEN
              SUBSUB = 'Numbers of restraints violated in 0, 1, 2 or' //
     -            ' 3 models'
          ELSE
              WRITE(NUMBER,120) NMODEL
 120          FORMAT(I3)
              IPOS = 1
              IF (NUMBER(1:1).EQ.' ') IPOS = 2
              IF (NUMBER(2:2).EQ.' ') IPOS = 3
              SUBSUB = 'Numbers of restraints violated in 0, 1, 2 ..' //
     -            '. ' // NUMBER(IPOS:3) // ' models'
          ENDIF
          CALL PSCTXT(XCENTR,BBOXY2 - 90.0,15.0,
     -        SUBSUB(1:LENSTR(SUBSUB)))
      ENDIF

C---- Determine whether "All distance" plots required (ie not required
C     if there is only one type of plot - eg just NOE distances)
      TOPTYP = NCTYPE + 1
      IF (NGOTYP.LE.1) THEN
          TOPTYP = NCTYPE
      ENDIF

C---- Loop over all the different restraint types
      DO 500, ICTYPE = 1, TOPTYP

C----     Check whether there are any data points of this type
          IF (ICTYPE.LE.NCTYPE) THEN
              NPOINT = NPTS(ICTYPE)
          ELSE
              NPOINT = 1
          ENDIF

C----     If there are any points to be plotted, then prepare graphs
          IF (NPOINT.GT.0) THEN

C----         If plotting each set of graphs on a separate page, then
C             close old page (if any) and open new one
              IF (SUMSEP .AND. .NOT.FIRST) THEN

C----             If have an open page, then close it
                  IF (PINOPE) THEN

C----                 Plot key to diagram
                      CALL SUMKEY(YSORIG,6.0,PLTYPE,PLOTNO)

C----                 Close this page
                      CALL PSENDP
                      IF (.NOT.COMBPS) THEN
                          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,
     -                        BBOXY2)
                      ENDIF
                  ENDIF

C----             Open a new page
                  CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE(PLOTNO),
     -                PLDESC(PLOTNO),HANDLE(PLOTNO),XCENTR)
                  PINOPE = .TRUE.

C----             For restraint differences plot, add an extra subheading
                  IF (PLOTNO.EQ.2) THEN
                      CALL PSCTXT(XCENTR,BBOXY2 - 90.0,15.0,
     -                    SUBSUB(1:LENSTR(SUBSUB)))
                  ENDIF
              ENDIF

C----         Increment graph number and compute its position
              IGRAPH = IGRAPH + 1
              YP = YMORIG + (NGRAPH - IGRAPH) * (YMWID + YMSEP)
              IF (SUMSEP) YP = YSORIG + 3.0 * (YSWID + YSSEP)

C----         Print the subtitle
              IF (TOPTYP.GT.NCTYPE) THEN
                  SUBTIT = LOWLET(IGRAPH:IGRAPH) // '. ' //
     -                RDESC(ICTYPE,PLOTNO)
              ELSE
                  SUBTIT = RDESC(ICTYPE,PLOTNO)
              ENDIF
              X = XMORIG - 30.0
              Y = YP + YMWID + 20.0
              IF (SUMSEP) THEN
                  Y = YP + YSWID + 20.0
              ENDIF
              CALL PSTEXT(X,Y,12.0,SUBTIT)
              NOEND = .TRUE.
              NUMBEY = .TRUE.
              ZEROS = .TRUE.

C----         Loop over the four graphs plotted across the page for
C             short, medium, long-range and total for the current
C             restraint type
              DO 400, JGRAPH = 1, 4

C----             Calculate start of graph
                  XLEFT = XMORIG + (JGRAPH - 1) * GWIDX
                  IF (SUMSEP) THEN
                      XLEFT = XSORIG
                      YP = YSORIG + (4 - JGRAPH) * (YSWID + YSSEP)
                  ENDIF

C----             Shade in the graph area, if required
                  IF (BSHADE(PLTYPE)) THEN
                      CALL PSHADE(0.996,COLPLT(2,PLTYPE),RGB,MXCOLR,
     -                    INCOLR(PLTYPE))
                      CALL PSUBOX(XLEFT,YP,XLEFT,YP + YWID,
     -                    XLEFT + GWIDX,YP + YWID,XLEFT + GWIDX,YP)
                  ENDIF

C----             Plot Graph heading and axis-labels
                  X = XLEFT + GWIDX / 2.0
                  Y = YP + YMWID + 6.0
                  TSIZE = 10.0
                  IF (SUMSEP) THEN
                      X = XLEFT - 100.0
                      Y = YP + YSWID - 10.0
                      TSIZE = 12.0
                      CALL PSTEXT(X,Y,TSIZE,
     -                    RGDESC(JGRAPH)(1:LENSTR(RGDESC(JGRAPH))))
                  ELSE
                      CALL PSCTXT(X,Y,TSIZE,
     -                    RGDESC(JGRAPH)(1:LENSTR(RGDESC(JGRAPH))))
                  ENDIF
                  Y = YP - 15.0
                  TSIZE = 8.0
                  IF (SUMSEP) THEN
                      X = XLEFT + GWIDX / 2.0
                      Y = YP - 20.0
                      TSIZE = 10.0
                  ENDIF
                  IF (PLOTNO.EQ.1) THEN
                      CALL PSCTXT(X,Y,TSIZE,'Distance (A)')
                  ELSE IF (PLOTNO.EQ.2) THEN
                      CALL PSCTXT(X,Y,TSIZE,'Actual - restraint (A)')
                  ELSE IF (PLOTNO.EQ.3) THEN
                      CALL PSCTXT(X,Y,TSIZE,'No. of models violated')
                  ENDIF
CHECK v.3.4.3-->
C                  X = XLEFT - 25.0
                  X = XLEFT - 32.0
CHECK v.3.4.3<--
                  Y = YP + YWID / 2.0
                  IF (SUMSEP .OR. NUMBEY) THEN
CHECK v.3.4.3-->
C                      IF (PLOTNO.EQ.3) THEN
C                          CALL PSRCTX(X,Y,TSIZE,'Occurrence')
C                      ELSE
CHECK v.3.4.3<--
                      CALL PSRCTX(X,Y,TSIZE,'No. of restraints')
CHECK v.3.4.3-->
C                      ENDIF
CHECK v.3.4.3<--
                  ENDIF

C----             Calculate x-axis origin position
                  XORIG = XLEFT - XMIN * SCALEX
                  XRIGHT = XLEFT + GWIDX

C----             Plot all the data on the current graph
CHECK v.3.4.3-->
C                  CALL BRPLOT(PLTYPE,PLOTNO,NFILE,DX,MXBAR,NBAR,BRLMS,
                  CALL BRPLOT(PLTYPE,PLOTNO,DX,NBAR,BRLMS,
CHECK v.3.4.3<--
     -                BRTYPE,BRUPLO,BARNO,BCOUNT,BINDEX,BVIOL,ICTYPE,
     -                JGRAPH,XLEFT,XORIG,XRIGHT,SCALEX,YP,YMIN,YMAX,
     -                SCALEY)

C----             Plot the graph axes
                  IF (PLOTNO.EQ.3) THEN
                      INTRL = 0
                  ELSE
                      INTRL = 1
                  ENDIF
                  IF (JGRAPH.EQ.4) NOEND = .FALSE.
                  LSIZE = 8.0
                  NUMBEX = .TRUE.
                  TSIZE = 12.0
                  IF (SUMSEP) THEN
                      LSIZE = 10.0
                      NOEND = .TRUE.
                      IF (JGRAPH.EQ.1) NOEND = .FALSE.
                      IF (JGRAPH.LT.4) THEN
                          NUMBEX = .FALSE.
                          ZEROS = .TRUE.
                      ELSE
                          NUMBEX = .TRUE.
                          ZEROS = .TRUE.
                      ENDIF
                      NUMBEY = .TRUE.
                      TSIZE = 14.0
                  ENDIF
                  CALL AXES(XLEFT,XLEFT + GWIDX,YP,YP + YWID,
     -                NGAPSX,NGAPSY,XMIN,XMAX,YMIN,YMAX,
     -                LSIZE,INTRL,0,TSIZE,NUMBEX,NUMBEY,ZEROS,
     -                NOEND,.TRUE.)

C----             Draw dotted line at origin
                  IF (XMIN.LT.0.0 .AND. XMAX.GT.0.0) THEN
                      X = XLEFT - XMIN * SCALEX
                      CALL PSDASH(2)
                      CALL PSLINE(X,YP,X,YP + YWID)
                      CALL PSDASH(0)
                  ENDIF

C----             For the separate graphs plot, add ticks to top of graph
                  IF (SUMSEP .AND. JGRAPH.NE.1 .AND. NGAPSX.GT.1) THEN
                      DO 350, ITICK = 1, NGAPSX - 1

C----                     Calculate x-position
                          X = XLEFT + GWIDX
     -                        * REAL(ITICK) / REAL(NGAPSX)
                          CALL PSLINE(X,YP + YWID - 4.0,X,
     -                        YP + YWID + 2.0)
 350                  CONTINUE
                  ENDIF

C----             Reinitialise for next graph
                  NUMBEY = .FALSE.
                  ZEROS = .FALSE.
 400          CONTINUE

C----         Have done at least one set of graphs
              FIRST = .FALSE.
          ENDIF
 500  CONTINUE

C---- Close the PotScript file
      IF (PINOPE) THEN

C----     Plot key to diagram
          CALL SUMKEY(YSORIG,6.0,PLTYPE,PLOTNO)

C----     Write closing line to PostScript file
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE BRCALC  -   Accumulate the data for the relevant histogram
C                         bar plot
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE BRCALC(PLTYPE,PLOTNO,ACDIST,NFILE,MAXCON,DX,MXBAR,NBAR,
      SUBROUTINE BRCALC(PLOTNO,ACDIST,NFILE,MAXCON,DX,NBAR,
CHECK v.3.4.3<--
     -    BRLMS,BRTYPE,BRUPLO,BARMAX,BARNO,BCOUNT,BINDEX,BVIOL,NPTS,
     -    NTOTAL,XMIN,XMAX,NGAPSX,YMIN,YMAX,NGAPSY)

      INCLUDE 'vplot.inc'

      REAL          MAXTOP, MINBOT
      PARAMETER    (
     -              MAXTOP =   10.0,
     -              MINBOT =  -10.0
     -             )
      INTEGER       MAXCON, NFILE

      CHARACTER*1   BRLMS(MXBAR), BRTYPE(MXBAR), BRUPLO(MXBAR), DTYPE,
     -              DTYPES(3), LIMTYP, RTYPE, RTYPES(NCTYPE), UPPLOW(2)
      INTEGER       BARMAX, BARMIN, BARNO(MXBAR), BCOUNT(MXBAR),
     -              BINDEX(MXBAR), BVIOL(MXBAR), GOTBAR(2), IBAR,
     -              IBOUND, ICONST, ICTYPE, IMODEL, IPOS, LMSTYP,
     -              LSTBAR, NBAR, NGAPSX, NGAPSY, NPTS(NCTYPE), NTOTAL,
CHECK v.3.4.3-->
C     -              NUMBAR, NVILOW, NVIOLA, NVIUPP, PLOTNO, PLTYPE
     -              NUMBAR, NVILOW, NVIOLA, NVIUPP, PLOTNO
CHECK v.3.4.3<--
      LOGICAL       HAVTYP(NCTYPE), MUSTIN, VIOL
      REAL          ACDIST(NFILE + 2,MAXCON), BARSUM, DIFF, DX,
     -              LIMVAL(2), LOWER, PLTMAX, UPPER, XMIN, XMAX, YMIN,
     -              YMAX

      DATA UPPLOW / 'L', 'U' /
      DATA DTYPES / 'S', 'M', 'L' /
      DATA RTYPES / 'N', 'H', 'S' /

C---- Initialise variables
      BARMAX = 0
      BARMIN = 0
      DO 10, IBAR = 1, MXBAR
          BARNO(IBAR) = 0
          BCOUNT(IBAR) = 0
          BINDEX(IBAR) = IBAR
          BRLMS(IBAR) = ' '
          BRTYPE(IBAR) = ' '
          BRUPLO(IBAR) = ' '
          BVIOL(IBAR) = 0
 10   CONTINUE
      PLTMAX = 0.0
      NBAR = 0
      NGOTYP = 0
      NTOTAL = 0
      DO 60, ICTYPE = 1, NCTYPE
          HAVTYP(ICTYPE) = .FALSE.
          NPTS(ICTYPE) = 0
 60   CONTINUE

C---- Loop over all the restraints to accumulate the data to be plotted
      DO 800, ICONST = 1, TCONST

C----     Get the upper and lower bounds for this restraint
          LOWER = ACDIST(NFILE + 1,ICONST)
          UPPER = ACDIST(NFILE + 2,ICONST)
          LIMVAL(1) = LOWER
          LIMVAL(2) = UPPER

C----     Get the restraint type in terms of NOE, H-bond, or S-S
          ICTYPE = 1
          IF (ICONST.LE.NCONS) ICTYPE = 3
          IF (ICONST.LE.NCONH) ICTYPE = 2
          IF (ICONST.LE.NCONN) ICTYPE = 1
          IF (.NOT.HAVTYP(ICTYPE)) THEN
              HAVTYP(ICTYPE) = .TRUE.
              NGOTYP = NGOTYP + 1
          ENDIF
          RTYPE = RTYPES(ICTYPE)

C----     Get the restraint type in terms of long, medium or short
          LMSTYP = 1
          IF (RESLMS(ICONST).EQ.'M') LMSTYP = 2
          IF (RESLMS(ICONST).EQ.'L') LMSTYP = 3
          DTYPE = DTYPES(LMSTYP)

C----     Update the accumulated counts of distance restraints for the
C         upper and lower values
          IF (PLOTNO.EQ.1) THEN
              DO 300, IBOUND = 1, 2

C----             Initialise store of which bars found here
                  GOTBAR(IBOUND) = 0

C----             If zero, then skip
                  IF (LIMVAL(IBOUND).GT.0.0) THEN

C----                 Get whether upper- or lower-limit
                      LIMTYP = UPPLOW(IBOUND)

C----                 Get the bar-number into which this point falls
                      CALL GETBAR(LIMVAL(IBOUND),DX,BARMAX,BARMIN,MXBAR,
     -                    BRLMS,BRTYPE,BRUPLO,BARNO,DTYPE,LIMTYP,RTYPE,
     -                    NBAR,NUMBAR,IFAIL)
                      IF (IFAIL) GO TO 999

C----                 Increment the count of points within this bar
                      BCOUNT(NUMBAR) = BCOUNT(NUMBAR) + 1
                      GOTBAR(IBOUND) = NUMBAR

C----                 Update counts for the different restraint type
C                     categories
                      NPTS(ICTYPE) = NPTS(ICTYPE) + 1

C----                 Update counts for statistics
                      IPOS = 2 * IBOUND - 1
                      RCOUNT(IPOS,LMSTYP,ICTYPE)
     -                    = RCOUNT(IPOS,LMSTYP,ICTYPE) + 1
                  ENDIF
 300          CONTINUE
          ENDIF

C----     Loop over each model to count number of times the
C         restraint has been violated between the actual distance
C         and restraint
          NVILOW = 0
          NVIUPP = 0
          DO 500, IMODEL = 1, NMODEL

C----         Determine whether this restraint has been violated
              DIFF = ACDIST(IMODEL,ICONST) - LOWER

C----         If this is a lower-bound violation, update count
              LIMTYP = 'U'
              VIOL = .FALSE.
              IF (DIFF.LT.0.0) THEN

C----             Check that have a stored bar-number for this restraint
                  IF (PLOTNO.EQ.1) THEN
                      NUMBAR = GOTBAR(1)
                      IF (NUMBAR.GT.0) THEN
                          BVIOL(NUMBAR) = BVIOL(NUMBAR) + 1

C----                     Update counts for statistics
                          IPOS = 2
                          RCOUNT(IPOS,LMSTYP,ICTYPE)
     -                        = RCOUNT(IPOS,LMSTYP,ICTYPE) + 1
                      ENDIF
                  ENDIF
                  LIMTYP = 'L'
                  VIOL = .TRUE.
                  NVILOW = NVILOW + 1

C----         Check for upper-bound violation
              ELSE IF (DIFF.GT.0.0) THEN
                  DIFF = UPPER - ACDIST(IMODEL,ICONST)

C----             If upper-bound violation, increment count
                  IF (DIFF.LT.0.0) THEN
                      VIOL = .TRUE.
                      NVIUPP = NVIUPP + 1
                      IF (PLOTNO.EQ.1) THEN
                          NUMBAR = GOTBAR(2)
                          IF (NUMBAR.GT.0) THEN
                              BVIOL(NUMBAR) = BVIOL(NUMBAR) + 1

C----                     Update counts for statistics
                          IPOS = 4
                          RCOUNT(IPOS,LMSTYP,ICTYPE)
     -                        = RCOUNT(IPOS,LMSTYP,ICTYPE) + 1
                          ENDIF
                      ENDIF
                  ENDIF
              ENDIF

C----         If plotting (actual - restraint) differences, determine
C             which bar this value falls under and update
              IF (PLOTNO.EQ.2) THEN

C----             Get the bar-number into which this point falls
                  DIFF = - DIFF
                  CALL GETBAR(DIFF,DX,BARMAX,BARMIN,MXBAR,BRLMS,
     -                BRTYPE,BRUPLO,BARNO,DTYPE,LIMTYP,RTYPE,NBAR,
     -                NUMBAR,IFAIL)
                  IF (IFAIL) GO TO 999

C----             Increment the count of points within this bar
                  BCOUNT(NUMBAR) = BCOUNT(NUMBAR) + 1

C----             Update counts for the different restraint type
C                 categories
                  IF (LIMTYP.EQ.'L') THEN
                      IBOUND = 1
                  ELSE
                      IBOUND = 2
                  ENDIF
                  NPTS(ICTYPE) = NPTS(ICTYPE) + 1

C----             If this is a violation, then increment count of
C                 violations
                  IF (VIOL) THEN
                      BVIOL(NUMBAR) = BVIOL(NUMBAR) + 1
                  ENDIF
              ENDIF
 500      CONTINUE

C----     If plotting the violations frequency, determine
C         which bar this value falls under and update
          IF (PLOTNO.EQ.3) THEN

C----         If no lower-bound, then remove from data
              IF (LOWER.EQ.0.0) NVILOW = -9

C----         Process the upper- and lower-bound cases
              DO 600, IBOUND = 1, 2

C----             Get the number of models in which this restraint
C                 was violated
                  IF (IBOUND.EQ.1) THEN
                      NVIOLA = NVILOW
                  ELSE
                      NVIOLA = NVIUPP
                  ENDIF
                  DIFF = NVIOLA + 0.1

C----             Get whether upper- or lower-limit
                  LIMTYP = UPPLOW(IBOUND)

CHECK v.3.4.3-->
C----             Special case of zero violations
                  IF (IBOUND.EQ.2 .AND. NVIOLA.EQ.0) THEN
                      LIMTYP = '0'
                  ENDIF
CHECK v.3.4.3<--

C----             Process only if a valid value
                  IF (NVIOLA.GE.0) THEN

C----                 Get the bar-number into which this point falls
                      CALL GETBAR(DIFF,DX,BARMAX,BARMIN,MXBAR,BRLMS,
     -                    BRTYPE,BRUPLO,BARNO,DTYPE,LIMTYP,RTYPE,NBAR,
     -                    NUMBAR,IFAIL)
                      IF (IFAIL) GO TO 999

C----                 Increment the count of points within this bar
C                     (store unviolated lower-bounds as a negative
C                     total so that these are not printed)
                      IF (IBOUND.EQ.1 .AND. NVIOLA.EQ.0) THEN
                          BCOUNT(NUMBAR) = BCOUNT(NUMBAR) - 1
                      ELSE
                          BCOUNT(NUMBAR) = BCOUNT(NUMBAR) + 1
                      ENDIF

C----                 Update counts for the different restraint type
C                     categories
                      NPTS(ICTYPE) = NPTS(ICTYPE) + 1

C----                 If this is a violation, then increment count of
C                     violations
                      IF (NVIOLA.GT.0) THEN
                          BVIOL(NUMBAR) = BVIOL(NUMBAR) + 1
                      ENDIF
                  ENDIF
 600          CONTINUE
          ENDIF
 800  CONTINUE

C---- Sort all the bar numbers
      CALL INSORT(MXBAR,BARNO,NBAR,BINDEX)

C---- Initialise variables
      LSTBAR = 0
      BARSUM = 0.0

C---- Loop through the stored bar-data to calculate maximum and minimum
C     values for all the plots 
      DO 1000, IPOS = 1, NBAR

C----     Get pointer to next bar
          IBAR = BINDEX(IPOS)

C----     For calculating maximum values, store only if this is an
C         upper-bound violation
          IF (BRUPLO(IBAR).EQ.'U') THEN

C----         Retrieve the bar-number
              NUMBAR = BARNO(IBAR)

C----         If this is a new bar, then check whether last bar's sum is the
C             largest so far
              IF (NUMBAR.NE.LSTBAR) THEN
                  PLTMAX = MAX(BARSUM,PLTMAX)
                  BARSUM = 0.0
              ENDIF

C----         Store the current bar number and increment sum
              LSTBAR = NUMBAR
              IF (PLOTNO.EQ.1) THEN
                  BARSUM = BARSUM + BCOUNT(IBAR)
              ELSE IF (PLOTNO.EQ.2) THEN
                  BARSUM = BARSUM + REAL(BCOUNT(IBAR)) / REAL(NMODEL)
              ELSE IF (PLOTNO.EQ.3) THEN
                  BARSUM = BARSUM + BCOUNT(IBAR)
              ENDIF
          ENDIF
 1000 CONTINUE

C---- Check whether last sum was the highest
      PLTMAX = MAX(BARSUM,PLTMAX)

C---- Calculate the x-limits for the plots
      IF (BARMIN.LT.0) THEN
          XMIN = DX * (BARMIN - 1)
      ELSE
          XMIN = 0.0
      ENDIF
      XMAX = DX * BARMAX
      MUSTIN = .FALSE.

C---- For violation frequency, set maximum x to number of models
      IF (PLOTNO.EQ.3) THEN
          XMAX = NMODEL + 0.9
          MUSTIN = .TRUE.

C---- For other plots, limits x-extent if it is too large
      ELSE
          IF (XMAX.GE.MAXTOP) XMAX = MAXTOP - 0.0001
          IF (XMIN.LE.MINBOT) XMIN = MINBOT + 0.0001
      ENDIF
      CALL ADJLIM(XMIN,XMAX,NGAPSX,MUSTIN)
C      IF (PLOTNO.EQ.3 .AND. NGAPSX.GT.NMODEL + 1) THEN
C          NGAPSX = NMODEL + 1
C          XMAX = NMODEL + 1
C      ENDIF

C---- Calculate the y-limits for the plots
      YMIN = 0.0
      YMAX = PLTMAX * 1.1
      CALL ADJLIM(YMIN,YMAX,NGAPSY,.FALSE.)

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETBAR  -   Find within which bar the current point falls
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE GETBAR(LIMVAL,DX,BARMAX,BARMIN,MXBAR,BRLMS,BRTYPE,
     -    BRUPLO,BARNO,DTYPE,LIMTYP,RTYPE,NBAR,NUMBAR,IFAIL)

      INTEGER       MXBAR

      CHARACTER*1   BRLMS(MXBAR), BRTYPE(MXBAR), BRUPLO(MXBAR), DTYPE,
     -              LIMTYP, RTYPE
      INTEGER       BARMAX, BARMIN, BARNO(MXBAR), IBAR, IGAP, NBAR,
     -              NUMBAR
      LOGICAL       FOUND, IFAIL
      REAL          DX, LIMVAL

C---- Calculate which bar along the axis this point falls into
      IGAP = (LIMVAL - 0.0001) / DX + 1

C---- Update maximum value
      BARMIN = MIN(IGAP,BARMIN)
      BARMAX = MAX(IGAP,BARMAX)

C---- Search all the stored bar-data to see if already have
C     this bar
      FOUND = .FALSE.
      NUMBAR = 0
      DO 200, IBAR = 1, NBAR

C----     Check whether the details match
          IF (IGAP.EQ.BARNO(IBAR) .AND.
     -        LIMTYP.EQ.BRUPLO(IBAR) .AND.
     -        DTYPE.EQ.BRLMS(IBAR) .AND.
     -        RTYPE.EQ.BRTYPE(IBAR)) THEN
              FOUND = .TRUE.
              NUMBAR = IBAR
          ENDIF
 200  CONTINUE

C---- If existing bar not found, then create a new one
      IF (.NOT.FOUND) THEN
          NBAR = NBAR + 1
          IF (NBAR.GT.MXBAR) GO TO 900
          NUMBAR = NBAR
          BARNO(NBAR) = IGAP
          BRUPLO(NBAR) = LIMTYP
          BRLMS(NBAR) = DTYPE
          BRTYPE(NBAR) = RTYPE
      ENDIF

      GO TO 999

 900  CONTINUE
      PRINT*, '*** Maximum number of histogram bars exceeded:', MXBAR
      GO TO 990
 
 990  CONTINUE
      IFAIL = .TRUE.
 
 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE BRPLOT  -   Plot the bars making up the current graph
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE BRPLOT(PLTYPE,PLOTNO,NFILE,DX,MXBAR,NBAR,BRLMS,BRTYPE,
      SUBROUTINE BRPLOT(PLTYPE,PLOTNO,DX,NBAR,BRLMS,BRTYPE,
CHECK v.3.4.3<--
     -    BRUPLO,BARNO,BCOUNT,BINDEX,BVIOL,ICTYPE,LMSTYP,XLEFT,XORIG,
     -    XRIGHT,SCALEX,YBOT,YMIN,YMAX,SCALEY)

      INCLUDE 'vplot.inc'

      CHARACTER*1   BRLMS(MXBAR), BRTYPE(MXBAR), BRUPLO(MXBAR), DTYPE,
CHECK v.3.4.3-->
C     -              DTYPES(4), RTYPE, RTYPES(NCTYPE + 1), UPPLOW(2)
     -              DTYPES(4), RTYPE, RTYPES(NCTYPE + 1)
CHECK v.3.4.3<--
      CHARACTER*3   NUMBER
      INTEGER       BARNO(MXBAR), BCOUNT(MXBAR), BINDEX(MXBAR),
     -              BVIOL(MXBAR), IBAR, ICTYPE, IPOS, LMSTYP, LSTBAR,
CHECK v.3.4.3-->
C     -              NBAR, NFILE, NUMBAR, PLOTNO, PLTYPE
     -              NBAR, NUMBAR, PLOTNO, PLTYPE
CHECK v.3.4.3<--
      REAL          DX, NOFFLF, NOFFRT, SCALEX, SCALEY, SUMLOW, SUMUPP,
     -              SUMVLO, SUMVUP, VIOLAV, XLEFT, XORIG, XRIGHT, XT1,
     -              XT2, YBOT, YMIN, YMAX, YT1, YT2

CHECK v.3.4.3-->
C      DATA UPPLOW / 'L', 'U' /
CHECK v.3.4.3<--
      DATA DTYPES / 'S', 'M', 'L', '*' /
      DATA RTYPES / 'N', 'H', 'S', '*' /

C---- Initialise variables
      DTYPE = DTYPES(LMSTYP)
      RTYPE = RTYPES(ICTYPE)
      LSTBAR = -99999
      NOFFLF = 0.0
      NOFFRT = 0.0
      SUMLOW = 0.0
      SUMUPP = 0.0
      SUMVLO = 0.0
      SUMVUP = 0.0

C---- Loop through the stored bar-data and plot each bar required
      DO 1000, IPOS = 1, NBAR

C----     Get pointer to next bar
          IBAR = BINDEX(IPOS)

C----     Where plotting numbers of restraints only, take average
          IF (PLOTNO.EQ.3) THEN
              VIOLAV = BVIOL(IBAR)
          ELSE
              VIOLAV = REAL(BVIOL(IBAR)) / REAL(NMODEL)
          ENDIF

C----     Check whether this bar is required for this graph
          IF ((BRTYPE(IBAR).EQ.RTYPE .OR. RTYPE.EQ.'*') .AND.
     -        (BRLMS(IBAR).EQ.DTYPE .OR. DTYPE.EQ.'*')) THEN

C----         Retrieve the bar-number
              NUMBAR = BARNO(IBAR)

C----         If this is a different bar, plot the previous one
              IF (NUMBAR.NE.LSTBAR .AND. LSTBAR.NE.-99999) THEN

C----             For differences file, take average across whole
C                 ensemble
                  IF (PLOTNO.EQ.2) THEN
                      SUMUPP = SUMUPP / REAL(NMODEL)
                      SUMLOW = SUMLOW / REAL(NMODEL)
                  ENDIF

C----             Plot the last bar
                  CALL DRWBAR(PLTYPE,SUMLOW,SUMUPP,SUMVLO,SUMVUP,LSTBAR,
     -                DX,SCALEX,SCALEY,XORIG,XLEFT,XRIGHT,YBOT,YMIN,
     -                YMAX,NOFFLF,NOFFRT)

C----             Reinitialise accumulators
                  SUMLOW = 0.0
                  SUMUPP = 0.0
                  SUMVLO = 0.0
                  SUMVUP = 0.0
              ENDIF

C----         Accumulate data for current bar
              IF (BRUPLO(IBAR).EQ.'L' .AND. BCOUNT(IBAR).GT.0) THEN
                  SUMLOW = SUMLOW + BCOUNT(IBAR)
                  SUMVLO = SUMVLO + VIOLAV
              ELSE IF (BRUPLO(IBAR).EQ.'U') THEN
                  SUMUPP = SUMUPP + BCOUNT(IBAR)
                  SUMVUP = SUMVUP + VIOLAV
CHECK v.3.4.3-->
C----         Special case of zero violations in violations frequency plot
              ELSE IF (BRUPLO(IBAR).EQ.'0') THEN
                  SUMLOW = SUMLOW + BCOUNT(IBAR)
CHECK v.3.4.3<--
              ENDIF

C----         Store the current bar number
              LSTBAR = NUMBAR
          ENDIF
 1000 CONTINUE

C---- Plot the last bar, if there is one
      IF (SUMUPP.GT.0.0 .OR. SUMLOW.GT.0.0) THEN

C----     For differences file, take average across whole
C         ensemble
          IF (PLOTNO.EQ.2) THEN
              SUMUPP = SUMUPP / REAL(NMODEL)
              SUMLOW = SUMLOW / REAL(NMODEL)
          ENDIF

C----     Draw the bar
          CALL DRWBAR(PLTYPE,SUMLOW,SUMUPP,SUMVLO,SUMVUP,LSTBAR,
     -        DX,SCALEX,SCALEY,XORIG,XLEFT,XRIGHT,YBOT,YMIN,YMAX,
     -        NOFFLF,NOFFRT)

      ENDIF

C---- If any of the bars have been off the graph, plot triangle symbols
C     to show how many there are
      YT1 = YBOT + 0.90 * (YMAX - YMIN) * SCALEY
      YT2 = YT1 + 2.0 * DX * SCALEX
      IF (NOFFLF.GT.0.0) THEN
          XT1 = XLEFT + 0.05 * (XRIGHT - XLEFT)
          XT2 = XT1 - DX * SCALEX
          CALL PSHADE(0.0,1,RGB,MXCOLR,.FALSE.)
          CALL PSTRIA(XT1,YT1,XT1,YT2,XT2,(YT1 + YT2) / 2.0)
          WRITE(NUMBER,520) NINT(NOFFLF)
 520      FORMAT(I3)
          IPOS = 1
          IF (NUMBER(1:1).EQ.' ') IPOS = 2
          IF (NUMBER(2:2).EQ.' ') IPOS = 3
          CALL PSCTXT(XT1 + 6.0,(YT1 + YT2) / 2.0,6.0,
     -        NUMBER(IPOS:3))
      ELSE IF (NOFFRT.GT.0.0) THEN
          XT1 = XLEFT + 0.95 * (XRIGHT - XLEFT)
          XT2 = XT1 + DX * SCALEX
          CALL PSHADE(0.0,1,RGB,MXCOLR,.FALSE.)
          CALL PSTRIA(XT1,YT1,XT1,YT2,XT2,(YT1 + YT2) / 2.0)
          WRITE(NUMBER,520) NINT(NOFFRT)
          IPOS = 1
          IF (NUMBER(1:1).EQ.' ') IPOS = 2
          IF (NUMBER(2:2).EQ.' ') IPOS = 3
          CALL PSCTXT(XT1 - 4.0,(YT1 + YT2) / 2.0,6.0,
     -        NUMBER(IPOS:3))
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DRWBAR  -   Plot the current bar
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE DRWBAR(PLTYPE,SUMLOW,SUMUPP,SUMVLO,SUMVUP,NUMBAR,DX,
     -    SCALEX,SCALEY,XORIG,XLEFT,XRIGHT,YBOT,YMIN,YMAX,NOFFLF,
     -    NOFFRT)

      INCLUDE 'vplot.inc'

      CHARACTER*5   NUMBER
      INTEGER       ICOLR, IPOS, NUMBAR, PLTYPE
      LOGICAL       CUTBAR
      REAL          CUTY, DX, NOFFLF, NOFFRT, SCALEX, SCALEY, SHADE,
     -              SUMLOW, SUMUPP, SUMVLO, SUMVUP, TOPY, XLEFT, XMID,
     -              XORIG, XRIGHT, X1, X2, YBOT, YMIN, YMAX, YTOP, Y1,
     -              Y2

C---- Calculate bar coordinates
      CUTBAR = .FALSE.
      X1 = XORIG + (NUMBAR - 1) * DX * SCALEX
      X2 = XORIG + NUMBAR * DX * SCALEX
      XMID = (X1 + X2) / 2.0
      Y1 = YBOT
      Y2 = YBOT
      YTOP = YBOT + (YMAX - YMIN) * SCALEY

C---- Check whether the bar is off the left or right of the graph
      IF (X1.LT.XLEFT) THEN
          NOFFLF = NOFFLF + SUMUPP + SUMLOW
      ELSE IF (X2.GT.XRIGHT) THEN
          NOFFRT = NOFFRT + SUMUPP + SUMLOW

C---- Otherwise, plot the required bar(s)
      ELSE

C----     Plot the upper-bound restraints, if any
          IF (SUMUPP.GT.0.0) THEN
              Y2 = Y1 + (SUMUPP - YMIN) * SCALEY

C----         Plot the bar
              SHADE = 0.8
              ICOLR = COLPLT(3,PLTYPE)
              CALL PSLWID(0.1)
              CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
              CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----         Calculate the percentage violations
              Y2 = Y1 + (SUMVUP - YMIN) * SCALEY
              SHADE = 0.0
              ICOLR = COLPLT(5,PLTYPE)
              CALL PSLWID(0.1)
              CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
              CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----         Reset bottom position to top of current bar
              Y1 = YBOT + (SUMUPP - YMIN) * SCALEY
          ENDIF

C----     Plot the lower-bound restraints, if any
          IF (SUMLOW.GT.0.0) THEN
              Y2 = Y1 + (SUMLOW - YMIN) * SCALEY

C----         Check whether the bar goes off the graph
              IF (Y2.GT.YTOP) THEN
                  CUTBAR = .TRUE.
                  TOPY = YBOT + 0.9 * (YTOP - YBOT)
                  CUTY = YBOT + 0.8 * (YTOP - YBOT)
                  Y2 = TOPY

C----             Show height of bar
                  WRITE(NUMBER,120) NINT(SUMUPP + SUMLOW)
 120              FORMAT(I5)
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  IF (NUMBER(3:3).EQ.' ') IPOS = 4
                  IF (NUMBER(4:4).EQ.' ') IPOS = 5
                  CALL PSCTXT(XMID,Y2 + 4.0,6.0,NUMBER(IPOS:))
              ENDIF

C----         Plot the bar
              SHADE = 1.0
              ICOLR = COLPLT(4,PLTYPE)
              CALL PSLWID(0.1)
              CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
              CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----         Calculate the percentage violations
              Y2 = Y1 + (SUMVLO - YMIN) * SCALEY
              IF (CUTBAR .AND. Y2.GT.CUTY) Y2 = CUTY
              SHADE = 0.9
              ICOLR = COLPLT(6,PLTYPE)
              CALL PSLWID(0.1)
              CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
              CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C----         If the bar had been over the end of the graph, need to show
C             the cut
              IF (CUTBAR) THEN

C----             Plot the slice
                  Y1 = CUTY - DX * SCALEX
                  Y2 = CUTY + DX * SCALEX
                  IF (BSHADE(PLTYPE)) THEN
                      SHADE = 0.996
                      ICOLR = COLPLT(2,PLTYPE)
                  ELSE
                      SHADE = 1.0
                      ICOLR = 1
                  ENDIF
                  CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
                  CALL PSUBOX(X1,Y1,X1,CUTY,X2,Y2,X2,CUTY)

C----             Draw the two lines delineating the slice
                  X1 = X1 - DX * SCALEX / 2.0
                  X2 = X2 + DX * SCALEX / 2.0
                  Y1 = CUTY - 1.5 * DX * SCALEX
                  Y2 = CUTY + 0.5 * DX * SCALEX
                  CALL PSLINE(X1,Y1,X2,Y2)
                  Y1 = CUTY - 0.5 * DX * SCALEX
                  Y2 = CUTY + 1.5 * DX * SCALEX
                  CALL PSLINE(X1,Y1,X2,Y2)
              ENDIF
          ENDIF 
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SUMKEY  -   Plot the explanatory key below last graph plotted
C                         on current page
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE SUMKEY(YLAST,MKSIZE,PLTYPE,PLOTNO)

      INCLUDE 'vplot.inc'

      CHARACTER*5   RNUMB1, RNUMB2
      CHARACTER*100 TEXT
      INTEGER       ICOLR, LENSTR, PLOTNO,PLTYPE
CHECK v.3.4.3-->
C      REAL          MKSIZE, SHADE, X, XMID, XTEXT, YTEXT, X1, X2,
      REAL          MKSIZE, SHADE, XTEXT, YTEXT, X1, X2,
CHECK v.3.4.3<--
     -              YLAST, Y1, Y2

C---- Initialise variables

C---- Plot heading
      CALL PSCTXT(XPORIG,YLAST - 38.0,12.0,'Key')

C---- Plot explanations of histogram shades/colours

C---- Upper-bound restraints
      CALL PSLWID(0.1)
      X1 = XPORIG + 30.0
      X2 = X1 + MKSIZE
CHECK v.3.4.3-->
C      X = XMID
CHECK v.3.4.3<--
      IF (PLOTNO.EQ.1) THEN
          Y1 = YLAST - 35.0
      ELSE IF (PLOTNO.EQ.2) THEN
          Y1 = YLAST - 43.0
      ELSE IF (PLOTNO.EQ.3) THEN
          Y1 = YLAST - 35.0
      ENDIF
      Y2 = Y1 + MKSIZE
CHECK v.3.4.3-->
      IF (PLOTNO.EQ.3) THEN
          SHADE = 1.0
          ICOLR = COLPLT(4,PLTYPE)
      ELSE
CHECK v.3.4.3<--
          SHADE = 0.8
          ICOLR = COLPLT(3,PLTYPE)
CHECK v.3.4.3-->
      ENDIF
CHECK v.3.4.3<--
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      XTEXT = X2 + 5.0
      YTEXT = Y1 + 1.0
      IF (PLOTNO.EQ.3) THEN
          TEXT = 'Number of unviolated upper-bound restraints'
      ELSE
          TEXT = 'Number of upper-bound distance restraints'
      ENDIF
      CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))

C---- Lower-bound restraints
      IF (PLOTNO.EQ.1) THEN
CHECK v.3.4.3-->
C          X = XMID
CHECK v.3.4.3<--
          Y1 = Y1 - 8.0
          Y2 = Y1 + MKSIZE
          SHADE = 1.0
          ICOLR = COLPLT(4,PLTYPE)
          CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          YTEXT = Y1 + 1.0
          TEXT = 'Number of lower-bound distance restraints'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
      ENDIF

C---- Upper-bound restraint violations
CHECK v.3.4.3-->
C      X = XMID
CHECK v.3.4.3<--
      Y1 = Y1 - 8.0
      Y2 = Y1 + MKSIZE
      SHADE = 0.0
      ICOLR = COLPLT(5,PLTYPE)
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      YTEXT = Y1 + 1.0
      IF (PLOTNO.EQ.3) THEN
          TEXT = 'Number of upper-bound violations in given no. of m' //
     -        'odels'
      ELSE
          TEXT = 'Number of upper-bound violations'
      ENDIF
      CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))

C---- Lower-bound restraint violations
CHECK v.3.4.3-->
C      X = XMID
CHECK v.3.4.3<--
      Y1 = Y1 - 8.0
      Y2 = Y1 + MKSIZE
      SHADE = 0.9
      ICOLR = COLPLT(6,PLTYPE)
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      YTEXT = Y1 + 1.0
      IF (PLOTNO.EQ.3) THEN
          TEXT = 'Number of lower-bound violations in given no. of m' //
     -        'odels'
      ELSE
          TEXT = 'Number of lower-bound violations'
      ENDIF
      CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))

C---- Additional comments for Violation Frequency plot
      IF (PLOTNO.EQ.3) THEN
          YTEXT = YTEXT - 9.0
          TEXT = 'Note: numbers of unviolated lower-bound restraints' //
     -        ' not shown'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
      ENDIF

C---- Short/medium/long categories
      XTEXT = X1 + 215.0
      YTEXT = YLAST - 33.0

C---- Restraints classed according to distance
      IF (DCLASS) THEN
          TEXT = 'Data subdivided according to upper-bound distance:-'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          XTEXT = XTEXT + 15.0
          YTEXT = YTEXT - 9.0
          TEXT = 'Short-range:'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          WRITE(RNUMB1,220) CLASS(1,1)
 220      FORMAT(F5.2)
          WRITE(RNUMB2,220) CLASS(2,1)
          CALL PSTEXT(XTEXT + 60.0,YTEXT,8.0,RNUMB1)
          CALL PSTEXT(XTEXT + 80.0,YTEXT,8.0,'-')
          CALL PSTEXT(XTEXT + 85.0,YTEXT,8.0,RNUMB2)
          CALL PSTEXT(XTEXT + 103.0,YTEXT,8.0,'A')
          YTEXT = YTEXT - 8.0
          TEXT = 'Medium-range:'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          WRITE(RNUMB1,220) CLASS(1,2)
          WRITE(RNUMB2,220) CLASS(2,2)
          CALL PSTEXT(XTEXT + 60.0,YTEXT,8.0,RNUMB1)
          CALL PSTEXT(XTEXT + 80.0,YTEXT,8.0,'-')
          CALL PSTEXT(XTEXT + 85.0,YTEXT,8.0,RNUMB2)
          CALL PSTEXT(XTEXT + 103.0,YTEXT,8.0,'A')
          YTEXT = YTEXT - 8.0
          TEXT = 'Long-range:'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          WRITE(RNUMB1,220) CLASS(1,3)
          WRITE(RNUMB2,220) CLASS(2,3)
          CALL PSTEXT(XTEXT + 60.0,YTEXT,8.0,RNUMB1)
          CALL PSTEXT(XTEXT + 80.0,YTEXT,8.0,'-')
          CALL PSTEXT(XTEXT + 85.0,YTEXT,8.0,RNUMB2)
          CALL PSTEXT(XTEXT + 103.0,YTEXT,8.0,'A')

C---- Restraints classed according to sequence separation
      ELSE
          TEXT = 'Data subdivided according to:-'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          XTEXT = XTEXT + 15.0
          YTEXT = YTEXT - 9.0
          TEXT = 'Short-range (restraints within same residue)'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          YTEXT = YTEXT - 8.0
          TEXT = 'Medium-range (sequence separation <= 4 residues)'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
          YTEXT = YTEXT - 8.0
          TEXT = 'Long-range (sequence separation > 4 residues)'
          CALL PSTEXT(XTEXT,YTEXT,8.0,TEXT(1:LENSTR(TEXT)))
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSTATS  -   Print the overall restraint statistics
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE RSTATS(PLTYPE,NFILE,MAXCON)
      SUBROUTINE RSTATS(PLTYPE)
CHECK v.3.4.3<--

      INCLUDE 'vplot.inc'

      REAL          XSORIG, YSORIG
      PARAMETER    (
     -              XSORIG =   60.0,
     -              YSORIG =  650.0
     -             )

CHECK v.3.4.3-->
C      INTEGER       MAXCON, NFILE
CHECK v.3.4.3<--

CHECK v.3.4.3-->
C      CHARACTER*1   DTYPES(3), RTYPES(NCTYPE), UPPLOW(2)
CHECK v.3.4.3<--
      CHARACTER*6   NUMBER
      CHARACTER*12  RGDESC(4)
      CHARACTER*9   HANDLE
CHECK v.3.4.3-->
C      CHARACTER*26  LOWLET
CHECK v.3.4.3<--
      CHARACTER*30  PLDESC
      CHARACTER*50  RDESC(NCTYPE + 1)
      CHARACTER*60  HEADS(2), HEAD1(2), PTITLE
      CHARACTER*100 TEXT
      INTEGER       ICLASS, ICTYPE, IBLOCK, IPOS, IPRINT, LENSTR,
     -              LMSTYP, LOOP, NPAGE, NPOINT, PLTYPE, TOPTYP
      LOGICAL       FIRST
      REAL          TOTALS(3,2), VALUES(4,2), X, XCENTR, XLEFT, Y

      DATA RDESC  / 
     -              'NOE distance restraints',
     -              'H-bond distance restraints',
     -              'Disulphide distance restraints',
     -              'All distance restraints' /
      DATA RGDESC / 'Short-range', 'Medium-range', 'Long-range',
     -              'Total' /
CHECK v.3.4.3-->
C      DATA LOWLET / 'abcdefghijklmnopqrstuvwxyz' /
CHECK v.3.4.3<--
      DATA HANDLE / 'restatist' /
      DATA HEADS  /
     -    'Lower-bound restraints',
     -    'Upper-bound restraints' /
      DATA HEAD1  /
     -    'a. Numbers of restraints',
     -    'b. Average violations   ' /
      DATA PLDESC / 'Restraint statistics' /
      DATA PTITLE / 'Restraint statistics' /

CHECK v.3.4.3-->
C      DATA UPPLOW / 'L', 'U' /
C      DATA DTYPES / 'S', 'M', 'L' /
C      DATA RTYPES / 'N', 'H', 'S' /
CHECK v.3.4.3<--

C---- Initialise variables
      FIRST = .TRUE.
      IBLOCK = 0
      IPRINT = 0
      NPAGE = 0
      XCENTR = (BBOXX1 + BBOXX2) / 2.0
      XLEFT = XSORIG
      Y = YSORIG

C---- Open new PostScript file
      IF (PLOTST) THEN
          CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,HANDLE,XCENTR)
      ENDIF

C---- If any model- or residue-selection from the ranges file, then
C     print out details of the selections

C---- Restraint statistics

C---- Loop through all the blocks of statistics to be printed
      DO 800, IBLOCK = 1, 2

C----     Form the heading
          WRITE(NUMBER,20) IBLOCK
 20       FORMAT(I1)
          X = XLEFT
          TEXT = NUMBER(1:1) // '. ' // HEADS(IBLOCK)

C----     Print the heading
          IPRINT = IPRINT + 1
          CALL PSTEXT(X,Y,15.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 20.0

C----     Determine whether "All distance" plots required (ie not required
C         if there is only one type of plot - eg just NOE distances)
          TOPTYP = NCTYPE + 1
          IF (NGOTYP.LE.1) THEN
              TOPTYP = NCTYPE
          ENDIF

C----     Loop over restraint numbers and then violations
          DO 700, LOOP = 1, 2

C----         Print sub-subheading
CHECK v.3.4.3-->
C              CALL RHEADS(IPRINT,HEAD1(LOOP),12.0,XLEFT,Y,RGDESC)
              CALL RHEADS(HEAD1(LOOP),12.0,XLEFT,Y,RGDESC)
CHECK v.3.4.3<--

C----         Initialise the totals
              DO 100, LMSTYP = 1, 3
                  TOTALS(LMSTYP,1) = 0.0
                  TOTALS(LMSTYP,2) = 0.0
 100          CONTINUE

C----         Loop over the different restraint types
              DO 600, ICTYPE = 1, TOPTYP

C----             If this is the totals line, then draw underscores
                  IF (ICTYPE.EQ.NCTYPE + 1) THEN
                      Y = Y + 5.0
                      CALL PSLINE(222.0,Y,242.0,Y)
                      CALL PSLINE(303.0,Y,323.0,Y)
                      CALL PSLINE(385.0,Y,405.0,Y)
                      CALL PSLINE(467.0,Y,487.0,Y)
                      Y = Y - 10.0
                  ENDIF

C----             Check whether there are any data points of this type
                  NPOINT = 0
                  VALUES(4,1) = 0.0
                  VALUES(4,2) = 0.0
                  DO 400, LMSTYP = 1, 3

C----                 Transfer the data to be plotted
                      IPOS = 2 * IBLOCK - 1
                      IF (ICTYPE.EQ.NCTYPE + 1) THEN
                          VALUES(LMSTYP,1) = TOTALS(LMSTYP,1)
                      ELSE
                          VALUES(LMSTYP,1) = RCOUNT(IPOS,LMSTYP,ICTYPE)
                          TOTALS(LMSTYP,1) = TOTALS(LMSTYP,1)
     -                        + VALUES(LMSTYP,1)
                      ENDIF
                      IPOS = 2 * IBLOCK
                      IF (ICTYPE.EQ.NCTYPE + 1) THEN
                          VALUES(LMSTYP,2) = TOTALS(LMSTYP,2)
                      ELSE
                          VALUES(LMSTYP,2)
     -                        = REAL(RCOUNT(IPOS,LMSTYP,ICTYPE))
     -                        / REAL(NMODEL)
                          TOTALS(LMSTYP,2) = TOTALS(LMSTYP,2)
     -                        + VALUES(LMSTYP,2)
                      ENDIF
                      NPOINT = NPOINT
     -                    + VALUES(LMSTYP,1) + VALUES(LMSTYP,2)
                      VALUES(4,1) = VALUES(4,1) + VALUES(LMSTYP,1)
                      VALUES(4,2) = VALUES(4,2) + VALUES(LMSTYP,2)
 400              CONTINUE

C----             If there are any numbers then print them
                  IF (NPOINT.GT.0) THEN

C----                 Print the current line of data
CHECK v.3.4.3-->
C                      CALL RSLINE(ICTYPE,RDESC(ICTYPE),10.0,XLEFT,
                      CALL RSLINE(RDESC(ICTYPE),10.0,XLEFT,
CHECK v.3.4.3<--
     -                    Y,VALUES,LOOP,NMODEL)
                  ENDIF
 600          CONTINUE

C----         Increment y-value
              Y = Y - 20.0
 700      CONTINUE
 800  CONTINUE

C---- Print explanatory notes
      X = XLEFT
      Y = Y - 20.0
      TEXT = 'Restraints classed as follows:-'
      CALL PSTEXT(X,Y,12.0,TEXT(1:LENSTR(TEXT)))
      X = X + 20.0
      Y = Y - 12.0
      IF (DCLASS) THEN
          DO 1000, ICLASS = 1, 3
              WRITE(TEXT,840) RGDESC(ICLASS), CLASS(1,ICLASS),
     -            CLASS(2,ICLASS)
 840          FORMAT(A20,F5.2,' -',F5.2,' A')
              CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
              Y = Y - 10.0
 1000     CONTINUE
      ELSE
          TEXT = 'Short-range'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          TEXT = '- Restraints within same residue'
          CALL PSTEXT(X + 70.0,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
          TEXT = 'Medium-range'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          TEXT = '- Restraints between residues whose sequence separ' //
     -        'ation <= 4 residues'
          CALL PSTEXT(X + 70.0,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
          TEXT = 'Long-range'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          TEXT = '- Restraints between residues whose sequence separ' //
     -        'ation > 4 residues'
          CALL PSTEXT(X + 70.0,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
      ENDIF
      Y = Y - 15.0

C---- If there was a ranges files entered, show the ranges
      IF (HAVRAN) THEN
          CALL RSRANG(XLEFT,Y,MODFRM,MODTO,RESFRM,RESTO,MAXRNG,NRANGE,
     -        MRANGE,BOTHND)
      ENDIF

C---- Write closing line to PostScript file
      IF (PLOTST) THEN
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN 
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RHEADS  -   Print the block headings for the statistics
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE RHEADS(IBLOCK,HEADIN,TSIZE,XLEFT,Y,RGDESC)
      SUBROUTINE RHEADS(HEADIN,TSIZE,XLEFT,Y,RGDESC)
CHECK v.3.4.3<--

      CHARACTER*12  RGDESC(4)
      CHARACTER*80  TEXT
      CHARACTER*(*) HEADIN
CHECK v.3.4.3-->
C      INTEGER       IBLOCK, ICOL, LENSTR
      INTEGER       ICOL, LENSTR
CHECK v.3.4.3<--
      REAL          TSIZE, X, XCOL(4), XLEFT, Y

      DATA XCOL   / 218.0, 285.0, 375.0, 465.0 /

C---- Initialise variables
      X = XLEFT + 10.0

C---- Form the heading
      TEXT = HEADIN
      CALL PSTEXT(X,Y,TSIZE,TEXT(1:LENSTR(TEXT)))
      Y = Y - TSIZE

C---- Plot the column headings
      DO 100, ICOL = 1, 4
          X = XCOL(ICOL)
          CALL PSTEXT(X,Y,10.0,RGDESC(ICOL))
 100  CONTINUE
      Y = Y - 20.0

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSLINE  -   Print the current statistics line
C
C----------------------------------------------------------------------+--- 

CHECK v.3.4.3-->
C      SUBROUTINE RSLINE(ICTYPE,HEADIN,TSIZE,XLEFT,Y,VALUES,LOOP,NMODEL)
      SUBROUTINE RSLINE(HEADIN,TSIZE,XLEFT,Y,VALUES,LOOP,NMODEL)
CHECK v.3.4.3<--

      CHARACTER*15  NUMBER
      CHARACTER*80  TEXT
      CHARACTER*(*) HEADIN
CHECK v.3.4.3-->
C      INTEGER       ICOL, ICTYPE, IPOS, IVALUE, LENSTR, LOOP, NMODEL
      INTEGER       ICOL, IPOS, IVALUE, LENSTR, LOOP, NMODEL
CHECK v.3.4.3<--
      REAL          PERCEN, TSIZE, VALUES(4,2), X, XCOL(4), XLEFT, Y

      DATA XCOL   / 220.0, 301.0, 382.0, 465.0 /

C---- Initialise variables
      X = XLEFT

C---- Write the restraint-type
      TEXT = HEADIN
      CALL PSTEXT(X,Y,TSIZE,TEXT(1:LENSTR(TEXT)))

C---- Plot the numbers
      IF (LOOP.EQ.1) THEN
          DO 100, ICOL = 1, 4
              X = XCOL(ICOL)
              IVALUE = NINT(VALUES(ICOL,1))
              WRITE(NUMBER,20) IVALUE
 20           FORMAT(I6)
              IF (IVALUE.EQ.0) NUMBER = '     -'
              CALL PSTEXT(X,Y,TSIZE,NUMBER)
 100      CONTINUE
          Y = Y - 10.0

C---- Plot the numbers of restraint violations
      ELSE
          DO 200, ICOL = 1, 4
              X = XCOL(ICOL)
              IF (VALUES(ICOL,1).GT.0.0) THEN
                  WRITE(NUMBER,120) VALUES(ICOL,2)
 120              FORMAT(F8.2)
                  IF (NMODEL.EQ.1) THEN
                      IVALUE = NINT(VALUES(ICOL,2))
                      WRITE(NUMBER,20) IVALUE
                  ENDIF
                  IF (VALUES(ICOL,2).EQ.0.0) THEN
                      NUMBER = '     -'
                  ENDIF
                  CALL PSTEXT(X,Y,TSIZE,NUMBER)

C----             Calculate percentage violation
                  IF (VALUES(ICOL,2).GT.0.0) THEN
                      PERCEN = 100.0 * VALUES(ICOL,2) / VALUES(ICOL,1)
                      WRITE(NUMBER,140) PERCEN
 140                  FORMAT(F6.2)
                      IPOS = 3
                      IF (PERCEN.GE.10.0) IPOS = 2
                      IF (PERCEN.GE.100.0) IPOS = 1
                      TEXT = '(' // NUMBER(IPOS:6) // '%)'
                      CALL PSTEXT(X + 34.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  ENDIF
              ENDIF
 200      CONTINUE
          Y = Y - 10.0
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSRANG  -  Print out the model- and residue ranges
C
C----------------------------------------------------------------------+---

      SUBROUTINE RSRANG(XLEFT,Y,MODFRM,MODTO,RESFRM,RESTO,MAXRNG,NRANGE,
     -    MRANGE,BOTHND)

      INTEGER       MAXRNG

      CHARACTER*6   RESFRM(MAXRNG), RESTO(MAXRNG)
      CHARACTER*100 TEXT
      INTEGER       ILEN, IRANGE, LENSTR, MODFRM(MAXRNG), MODTO(MAXRNG),
     -              MRANGE, NRANGE
      LOGICAL       BOTHND, VALID
      REAL          X, XLEFT, Y

C---- Initialise variables
      X = XLEFT

C---- Print heading
      TEXT = 'Model- and residue-ranges selected:-'
      CALL PSTEXT(X,Y,12.0,TEXT(1:LENSTR(TEXT)))
      Y = Y - 15.0
      X = X + 20.0

C---- Model-number range
      IF (MODFRM(1).EQ.-99999 .AND. MODTO(1).EQ.99999) THEN
          TEXT = 'ALL models in the ensemble'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
      ELSE
          DO 400, IRANGE = 1, MRANGE

C----         Retrieve start of model-number range
              IF (MODFRM(IRANGE).EQ.-99999) THEN
                  TEXT = 'From FIRST model'
              ELSE
                  WRITE(TEXT,140) MODFRM(IRANGE)
 140              FORMAT('From model ',I5)
              ENDIF

C----         Retrieve end of model-number range
              IF (MODTO(IRANGE).EQ.99999) THEN
                  TEXT(17:) = ' to LAST model'
              ELSE
                  WRITE(TEXT(17:),160) MODTO(IRANGE)
 160              FORMAT(' to model ',I5)
              ENDIF

C----         Show the interpreted range
              CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
              Y = Y - 10.0
 400      CONTINUE
      ENDIF
      Y = Y - 5.0

C---- Residue-number range
      IF (RESFRM(1).EQ.'*ALL  ') THEN
          TEXT = 'ALL residues'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
      ELSE
          DO 800, IRANGE = 1, NRANGE

C----         Retrieve start of residue-number range
              IF (RESFRM(IRANGE)(2:).EQ.'ALL  ') THEN
                  TEXT = 'All residues'
                  ILEN = 12
              ELSE IF (RESFRM(IRANGE)(2:).EQ.'FIRST') THEN
                  TEXT = 'From FIRST residue'
                  ILEN = 18
              ELSE
                  WRITE(TEXT,640) RESFRM(IRANGE)(2:)
 640              FORMAT('From residue ',A5)
                  ILEN = 18
              ENDIF

C----         Add chain identifier, if required
              IF (RESFRM(IRANGE)(1:1).NE.' ') THEN
                  TEXT(ILEN + 1:) = ' in chain [' //
     -                RESFRM(IRANGE)(1:1) // ']'
                  ILEN = ILEN + 13
              ENDIF

C----         Retrieve end of residue-number range
              VALID = .FALSE.
              IF (RESTO(IRANGE)(2:).EQ.'LAST ') THEN
                  TEXT(ILEN + 1:) = ' to LAST residue'
                  ILEN = ILEN + 16
                  VALID = .TRUE.
              ELSE IF (RESTO(IRANGE)(2:).NE.'XXXXX') THEN
                  WRITE(TEXT(ILEN + 1:),660) RESTO(IRANGE)(2:)
 660              FORMAT(' to residue ',A5)
                  ILEN = ILEN + 17
                  VALID = .TRUE.
              ENDIF

C----         Add chain identifier, if required
              IF (VALID .AND. RESTO(IRANGE)(1:1).NE.' ') THEN
                  TEXT(ILEN + 1:) = ' in chain [' //
     -                RESTO(IRANGE)(1:1) // ']'
                  ILEN = ILEN + 13
              ENDIF

C----         Show the interpreted range
              CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
              Y = Y - 10.0
 800      CONTINUE
      ENDIF
      Y = Y - 5.0
      IF (BOTHND) THEN
          TEXT = 'Restraints only where both residues are selected'
          CALL PSTEXT(X,Y,10.0,TEXT(1:LENSTR(TEXT)))
          Y = Y - 10.0
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE OPTSET  -  Set the restraint-inclusion options for next
C                        set of plots
C     
C----------------------------------------------------------------------+---
      
      SUBROUTINE OPTSET
      
      INCLUDE 'vplot.inc'
      
C---- Set the options
      INCLUS = INCLS1
      INCLUM = INCLM1
      INCLUL = INCLL1
      TYPEHB = TYPEH1
      TYPENO = TYPEN1
      TYPESS = TYPES1
      VIONLY = .FALSE.

      RETURN
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE RSPANS   -   Restraint spans plot
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE RSPANS(PLTYPE,ACDIST,VIOLAT,NFILE,MAXCON)

      INCLUDE 'vplot.inc'

      INTEGER       MAXCON, NFILE

      CHARACTER*1   BRKCH, CHNEND, CIS, DAMINO, DTYPE, INCHN, LSTBRK,
     -              LSTCHN, NXTCHN, NXTCIS, NXTSST, OLDCHN,
     -              PINCIS(MXPINS), PINSST(MXPINS), RTYPE
      CHARACTER*2   PINCHN(MXPINS), TYPIN(MXFILE,MXPINS)
      CHARACTER*3   PINRES(MXPINS), RESDUE
      CHARACTER*5   PINSNO(MXPINS)
      CHARACTER*9   HANDLE
      CHARACTER*30  PLDESC
      CHARACTER*60  PTITLE
      INTEGER       BGAP, FGAP, FPIN, FRES, IATOM1, IATOM2, ICONST,
     -              IFILE, IGAP, ILEVEL, IMODEL, IPOS, IRES, IRES1,
     -              IRES2, JCONST, JRES1, JRES2, LINE, LRES, LSTRES,
     -              NGAPY, NLEVEL, NGAP, NPAGE, NPIN, PLTYPE, SWAP,
     -              THEPIN, TRESTS
      LOGICAL       BRKPOS(MXPINS), FIRST, FOUND, MUSTIN, PAGEND,
     -              PINOPE, WANTED
      REAL          ACDIST(NFILE + 2,MAXCON), CALVAL, LOWER, OMEGA,
     -              PINACC(MXPINS), PINBOT,
     -              PINTOP, TOTVIO, UPPER, VIOLAT(NFILE + 2,MAXCON),
CHECK v.3.4.3-->
C     -              XCENTR, XLAST, YLAST
     -              XCENTR, XLAST
CHECK v.3.4.3<--

      DATA  BGAP, FGAP / 2, 10 /
      DATA  HANDLE / 'restspans' /
      DATA  PLDESC / 'Restraint spans' /
      DATA  PTITLE / 'Restraint spans' /

C---- Initialise variables
      FIRST = .TRUE.
      NXTCIS = ' '
      DO 10, IRES = 1, NRES
          FINPIN(IRES) = 0
 10   CONTINUE
      DO 50, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          DO 20, IFILE = 1, MXFILE
              TYPIN(IFILE,NPIN) = ' '
 20       CONTINUE
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          PINSNO(NPIN) = ' '
 50   CONTINUE
      PINOPE = .FALSE.
      TRESTS = 0

C---- Initialise variables
      BRKCH = ' '
      CHNEND = '>'
      FPIN = 0
      INCHN = ' '
      DO 80, ICONST = 1, MXCONS
          LEVEL(ICONST) = 0
 80   CONTINUE
      LINE = 0
      LSTBRK = ' '
      LSTCHN = ' '
      NLEVEL = 0
      NPAGE = 0
      NPIN = 0
      OLDCHN = ' '
      THEPIN = MXPINS
      IF (NRES.LT.MXPINS .AND. NRES.GT.2) THEPIN = NRES
      THEPIN = MXPINS
      XCENTR = XPORIG + XPWID / 2.0

C---- Initialise the residue number
      IRES1 = 0
      LSTRES = 0
      TOTVIO = 0.0

C---- Loop through all the restraints to mark all those are required
      DO 100, ICONST = 1, TCONST

C----     Determine whether this restraint is wanted
          CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -        1,IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,
     -        WANTED)

C----     If this restraint is wanted, then assign it to level 1
          IF (WANTED .AND. IRES1.NE.IRES2) THEN
              LEVEL(ICONST) = -1
          ENDIF
 100  CONTINUE

C---- Loop through all the restraints to move them to levels where
C     they don't overlap
      DO 400, ICONST = 1, TCONST

C----     If this is a required restraint, then check whether it
C         clashes with any other restraints, raising it to higher and
C         higher levels until there are no more clashes
          IF (LEVEL(ICONST).NE.0) THEN

C----         Get the two residues making up this restraint and make sure
C             the lower-numbered one is first
              IRES1 = VIORES(1,ICONST)
              IRES2 = VIORES(2,ICONST)
              IF (IRES1.GT.IRES2) THEN
                  SWAP = IRES1
                  IRES1 = IRES2
                  IRES2 = SWAP
              ENDIF
              LEVEL(ICONST) = 1

C----         Move restraint up in levels until it no longer clashes
C             with any other restraints
              FOUND = .FALSE.
 200          CONTINUE

C----             Get the restraint's current level
                  ILEVEL = LEVEL(ICONST)

C----             Search through all the other restraints
                  DO 300, JCONST = 1, TCONST

C----                 If this restraint is not the same as the one of
C                     interest, but is at the same level, then check for
C                     a clash
                      IF (JCONST.NE.ICONST .AND.
     -                    LEVEL(JCONST).EQ.ILEVEL) THEN

C----                     Get the two residues making up this restraint
C                         and make sure the lower-numbered one is first
                          JRES1 = VIORES(1,JCONST)
                          JRES2 = VIORES(2,JCONST)
                          IF (JRES1.GT.JRES2) THEN
                              SWAP = JRES1
                              JRES1 = JRES2
                              JRES2 = SWAP
                          ENDIF

C----                     If there's a clash, then increment level and
C                         loop back
                          IF ((IRES1.GE.JRES1 .AND. IRES1.LE.JRES2) .OR.
     -                        (IRES2.GE.JRES1 .AND. IRES2.LE.JRES2) .OR.
     -                        (IRES1.LT.JRES1 .AND. IRES2.GT.JRES2))
     -                        THEN
                              LEVEL(ICONST) = LEVEL(ICONST) + 1
                              GO TO 200
                          ENDIF
                      ENDIF
 300              CONTINUE

C----             If this is the highest-numbered level so far, then store
                  NLEVEL = MAX(LEVEL(ICONST),NLEVEL)
          ENDIF
 400  CONTINUE

C---- Update maximum values to include last residue
      MUSTIN = .TRUE.
      PINBOT = 0.0
      PINTOP = 1.1 * NLEVEL
      CALL ADJLIM(PINBOT,PINTOP,NGAPY,MUSTIN)

C---- Initialise variables
      NXTCIS = ' '
      NPIN = 0

C---- Loop over all the residues in the sequence to accumulate the
C     data for all the plots
      DO 1000, IPOS = 1, NRES

C----     Get the pointer to the next residue
          IF (IPOS.EQ.1) THEN
              IRES = FSTRES
          ELSE
              IRES = NXTRES(IRES)
          ENDIF
          NPIN = NPIN + 1
          RESDUE = VALSNO(IRES)(7:9)
          FINPIN(IRES) = NPIN
          IF (NPIN.EQ.1) FRES = IRES
          LRES = IRES

C----     Initialise cis-peptide and D-amino acid markers
          CIS = NXTCIS
          NXTCIS = ' '
          DAMINO = ' '

C----     Loop through all structures in the ensemble for
C         this residue
          DO 500, IMODEL = 1, NMODEL

C----         Case of trans peptide (ie 315 > omega > 45) 
              OMEGA = VALUE(LOCOME,IRES,IMODEL)
              IF (OMEGA.GE.45.0 .AND. OMEGA.LE.315.0) THEN
                  OMEGA = ABS(OMEGA - GLOBOM)

C----         Case of cis peptide (ie abs(omega) < 45) 
              ELSE IF (ABS(OMEGA).LT.900.0) THEN
                  NXTCIS = 'c'
              ELSE
                  OMEGA = 999.9
              ENDIF
              VALUE(LOCOME,IRES,IMODEL) = OMEGA

C----         Alpha carbon chirality
              CALVAL = VALUE(LOCZET,IRES,IMODEL)
              IF (CALVAL.LT.900.0) THEN
                  IF (CALVAL.LT.0) DAMINO = 'D'
                  CALVAL = ABS(CALVAL - GLOBDH)
              ENDIF
              VALUE(LOCZET,IRES,IMODEL) = CALVAL
 500      CONTINUE

C----     Transfer the plot details for this residue into
C         the pin arrays
          PINACC(NPIN) = VALOOI(IRES)
          IF (CIS.EQ.'c' .AND. DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = 'X'
          ELSE IF (CIS.EQ.'c') THEN
              PINCIS(NPIN) = CIS
          ELSE IF (DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = DAMINO
          ENDIF
          PINRES(NPIN) = RESDUE
          PINSNO(NPIN) = VALSNO(IRES)(2:6)
          PINSST(NPIN) = CONSST(IRES)
          IF (NPIN.EQ.NRES) THEN
              NXTSST = '='
          ELSE
              NXTSST = CONSST(IRES + 1)
          ENDIF
          OLDCHN = INCHN
          INCHN = VALSNO(IRES)(1:1)
          CHNEND = ' '
          IF (IPOS.EQ.1) THEN
              CHNEND = '>'
              OLDCHN = INCHN
          ENDIF
          IF (IPOS.EQ.NRES) CHNEND = '<'
          PINCHN(NPIN) = INCHN // CHNEND
          NXTCHN = INCHN
          BRKCH = CHNBRK(IRES)

C----     Determine whether at a chain-end or chain-start
          IF (NPIN.GT.0) THEN
              IF (OLDCHN.NE.NXTCHN) THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (OLDCHN.NE.LSTCHN) THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.'!') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.' ') THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (BRKCH.EQ.'x') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
              ENDIF
              LSTBRK = BRKCH
              LSTCHN = OLDCHN
          ENDIF

C----     If have a pageful of data, then produce the pinplot
          IF (NPIN.EQ.THEPIN) THEN

C----         If current PostScript file is open, close it
              IF (PINOPE) THEN
                  CALL PSENDP
                  IF (.NOT.COMBPS) THEN
                      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                  ENDIF
              ENDIF

C----         Open new PostScript file
              CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,
     -            HANDLE,XCENTR)

C----         Produce current page
              CALL PLSPAN(THEPIN,NPIN,FPIN,PINRES,PINSST,
     -            PINCHN,PINSNO,BRKPOS,PINACC,PINCIS,
     -            PLTYPE,PINBOT,PINTOP,NGAPY,NFILE,NXTSST,
CHECK v.3.4.3-->
C     -            TYPIN,XLAST,YLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
     -            TYPIN,XLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
CHECK v.3.4.3<--
              FIRST = .FALSE.
              PINOPE = .TRUE.
              FPIN = FPIN + THEPIN
              NPIN = 0
              CHNEND = ' '
          ENDIF

C----     Check whether this residue is the end of a chain
          IF (CHNEND.EQ.'<' .OR. CHNEND.EQ.'!') THEN

C----         Leave the appropriate number of blanks between the chains
              PAGEND = .FALSE.
              IF (CHNEND.EQ.'<') THEN
                  NGAP = FGAP
              ELSE
                  NGAP = BGAP
              ENDIF
              DO 800, IGAP = 1, NGAP

C----             Add blanks providing that haven't reached end of page
                  IF (.NOT.PAGEND .AND. IRES.NE.NRES) THEN
                      NPIN = NPIN + 1
                      BRKPOS(NPIN) = .TRUE.

C----                 If have a pageful of data, then produce
C                     the plot
                      IF (NPIN.EQ.THEPIN) THEN

C----                     If current PostScript file is open, close it
                          IF (PINOPE) THEN
                              CALL PSENDP
                              IF (.NOT.COMBPS) THEN
                                  CALL PSCLOS(BBOXX1,BBOXX2,
     -                                BBOXY1,BBOXY2)
                              ENDIF
                          ENDIF

C----                     Open new PostScript file
                          CALL PGOPEN(FIRST,NPAGE,PLTYPE,
     -                        PTITLE,PLDESC,HANDLE,XCENTR)

C----                     Produce current page
                          CALL PLSPAN(THEPIN,NPIN,FPIN,PINRES,PINSST,
     -                        PINCHN,PINSNO,BRKPOS,PINACC,PINCIS,
     -                        PLTYPE,PINBOT,PINTOP,NGAPY,NFILE,NXTSST,
CHECK v.3.4.3-->
C     -                        TYPIN,XLAST,YLAST,NLEVEL,FRES,LRES,
     -                        TYPIN,XLAST,NLEVEL,FRES,LRES,
CHECK v.3.4.3<--
     -                        VIOLAT,MAXCON)
                          FIRST = .FALSE.
                          PINOPE = .TRUE.
                          FPIN = FPIN + THEPIN
                          NPIN = 0
                          CHNEND = ' '
                          PAGEND = .TRUE.
                      ENDIF
                  ENDIF
 800          CONTINUE
          ENDIF
 1000 CONTINUE

C---- If any more data left to be printed, then produce the pinplot
      IF (NPIN.GT.0) THEN

C----     If current PostScript file is open, close it
          IF (PINOPE) THEN
              CALL PSENDP
              IF (.NOT.COMBPS) THEN
                  CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
              ENDIF
          ENDIF

C----     Open new PostScript file
          CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,HANDLE,XCENTR)

C----     Produce current page
          CALL PLSPAN(THEPIN,NPIN,FPIN,PINRES,PINSST,PINCHN,PINSNO,
     -        BRKPOS,PINACC,PINCIS,PLTYPE,PINBOT,PINTOP,NGAPY,NFILE,
CHECK v.3.4.3-->
C     -        NXTSST,TYPIN,XLAST,YLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
     -        NXTSST,TYPIN,XLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
CHECK v.3.4.3<--
          FIRST = .FALSE.
          PINOPE = .TRUE.
      ENDIF

C---- Print total number of restraints and close the PotScript file
      IF (PINOPE) THEN
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PLSPAN  -  Print current page for Restraint Spans plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PLSPAN(THEPIN,NPIN,FPIN,PINRES,PINSST,PINCHN,PINSNO,
     -    BRKPOS,PINACC,PINCIS,PLTYPE,PINBOT,PINTOP,NGAPY,NFILE,
CHECK v.3.4.3-->
C     -    NXTSST,TYPIN,XLAST,YLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
     -    NXTSST,TYPIN,XLAST,NLEVEL,FRES,LRES,VIOLAT,MAXCON)
CHECK v.3.4.3<--

      SAVE

      INCLUDE 'vplot.inc'

      REAL          CONSTY, ENOTE1, ENOTE2, NOTE1Y, NOTEX1, NOTEX2,
     -              NOTEY1, NOTEY2, SECSTY, STACHT
      PARAMETER    (
     -              CONSTY =  220.0,
     -              ENOTE1 =   30.0,
     -              ENOTE2 =   22.0,
     -              NOTE1Y =   38.0,
     -              NOTEX1 =  150.0,
     -              NOTEX2 =  145.0,
     -              NOTEY1 =   17.0,
     -              NOTEY2 =   25.0,
     -              SECSTY =   50.0,
     -              STACHT =   70.0
     -             )

      REAL          MKSIZE, SIZLAB, TSIZE
      PARAMETER    (
     -              MKSIZE =    5.0,
     -              SIZLAB =   10.0,
     -              TSIZE  =   15.0
     -             )

      INTEGER       THEPIN, MAXCON, NFILE

      CHARACTER*1   A, NXTSST, PINSST(THEPIN), PINCIS(THEPIN), RCHAR
      CHARACTER*2   PINCHN(THEPIN), TYPIN(MXFILE,MXPINS)
      CHARACTER*3   CODE(20), PINRES(THEPIN)
      CHARACTER*5   PINSNO(THEPIN), TICLAB(MXPINS)
      CHARACTER*20  AMINO1
      CHARACTER*26  LOWER
      CHARACTER*60  PLTHED, PLTYHD
      INTEGER       FPIN, FRES, ICODE, ICOLR, ICONS, ICONST, IFILE,
     -              ILEVEL, IPIN, IPIN1, IPIN2, IRES, IRES1, IRES2,
     -              LRES, N, NGAPY, NLEVEL, NPIN, NSTD, PLTHLN,
     -              PLTYLN, PLTYPE, SWAP, TICLEN(MXPINS), VINDEX(MXRCON)
      LOGICAL       BRKPOS(MXPINS), OFFBTH, TICPOS(MXPINS)
      REAL          PLTDUM, PINACC(THEPIN), PINBOT, PINTOP, SCALEX,
     -              SCALEY, VIOLAT(NFILE + 2,MAXCON), VVALUE(MXRCON),
CHECK v.3.4.3-->
C     -              X, XCENTR, XLAST, X1, X2, Y, YLAST, YP, YRORIG,
C     -              YRSEP, YRWID
     -              X, XCENTR, XLAST, X1, X2, Y, YP, YRORIG, YRWID
CHECK v.3.4.3<--

      DATA  A      / 'A' /
      DATA  AMINO1 / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /

      DATA  PLTHED / 'Residue-to-residue restraint spans' /

      DATA  PLTHLN /  34 /

      DATA  PLTYHD / ' ' /

      DATA  PLTYLN /  1 /

C---- Set the size of the graph according to the number of levels to be
C     plotted
      IF (NLEVEL.LT.50) THEN
          YRORIG = 380.0
          YRWID = 200.0
      ELSE
          YRORIG = 190.0
          YRWID = 470.0
      ENDIF

C---- Initialise variables
      PLTDUM = 0.0
      XCENTR = XPORIG + XPWID / 2.0
CHECK v.3.4.3-->
C      YP = YRORIG + 2.0 * YRWID + YRSEP
      YP = YRORIG + 2.0 * YRWID
CHECK v.3.4.3<--
      SCALEX = XPWID / THEPIN
      DO 50, ICONS = 1, MXRCON
          VVALUE(ICONS) = 0.0
          VINDEX(ICONS) = ICONS
 50   CONTINUE
      CALL PSLWID(0.1)

C---- Plot the graph
      NSTD = 0

C---- Determine position on page
      YP = YRORIG

C---- Plot the graph box and axes
      CALL PINGBX(XPORIG,YP,XPWID,YRWID,BSHADE(PLTYPE),
     -    PINBOT,PINTOP,FPIN,FPIN + THEPIN,
     -    PLTHED,PLTHLN,PLTYHD,
     -    PLTYLN,PLTYHD,PLTYLN,
     -    INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(2,PLTYPE),
     -    COLPLT(2,PLTYPE),NGAPY,SCALEY,1)

C---- Print the residue numbers along the x-axis
      CALL PINRNO(XPORIG,XPORIG + XPWID,YP,PINSNO,
     -    MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)
      CALL PSCTXT(XCENTR,YP - 22.0,15.0,'Residue number')

C---- Loop over all the restraints
      DO 100, ICONST = 1, TCONST

C----     If this is a required restraint, then check whether it is
C         on this page
          IF (LEVEL(ICONST).GT.0) THEN

C----         Get the two residues making up this restraint and make sure
C             the lower-numbered one is first
              IRES1 = VIORES(1,ICONST)
              IRES2 = VIORES(2,ICONST)
              IF (IRES1.GT.IRES2) THEN
                  SWAP = IRES1
                  IRES1 = IRES2
                  IRES2 = SWAP
              ENDIF
              IPIN1 = FINPIN(IRES1)
              IPIN2 = FINPIN(IRES2)

C----         Check whether one residue is off the left-hand side of the
C             graph and the other one off the right
              OFFBTH = .FALSE.
              IF (IRES1.LT.FRES .AND. IRES2.GT.LRES) THEN
                  OFFBTH = .TRUE.
              ENDIF

C----         If either residue is on the page, get the level and
C             calculate its y-value
              IF (IPIN1.GT.0 .OR. IPIN2.GT.0 .OR. OFFBTH) THEN
                  ILEVEL = LEVEL(ICONST)
                  Y = YRORIG + ILEVEL * SCALEY

C----             Calculate the x-coords of either end of the restrain
                  IF (IPIN1.GT.0) THEN
                      X1 = XPORIG + (REAL(IPIN1) - 0.5) * SCALEX
                  ELSE
                      X1 = XPORIG
                  ENDIF
                  IF (IPIN2.GT.0) THEN
                      X2 = XPORIG + (REAL(IPIN2) - 0.5) * SCALEX
                  ELSE
                      X2 = XPORIG + XPWID
                  ENDIF

C----             Check whether this restraint is violated
                  IF (VIOLAT(NFILE + 2,ICONST).GT.0.0) THEN
                      IF (INCOLR(PLTYPE)) THEN
                          ICOLR = COLPLT(10,PLTYPE)
                          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                        RGB(3,ICOLR))
                      ELSE
                          CALL PSDASH(2)
                      ENDIF
                  ENDIF

C----             Draw in the restraint
                  CALL PSLINE(X1,Y,X2,Y)

C----             If restraint is violated, reset colour/line
                  IF (VIOLAT(NFILE + 2,ICONST).GT.0.0) THEN
                      IF (INCOLR(PLTYPE)) THEN
                          ICOLR = 1
                          CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                        RGB(3,ICOLR))
                      ELSE
                          CALL PSDASH(0)
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
 100  CONTINUE

C---- Print the "wiring diagram" showing the secondary structure, with
C     background shading giving a measure of the accessibility
      X = XPORIG
      Y = YRORIG - SECSTY
      CALL PSTEXT(XPORIG,Y,12.0,
     -    'Secondary structure & average estimated accessibility')
      Y = Y - 18.0
      CALL PSLWID(0.0)
      IF (SHOWAC) THEN
          CALL ACCSHD(THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
     -        SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(4,PLTYPE),
     -        COLPLT(3,PLTYPE))
      ENDIF
      CALL SSPLOT(THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRES,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(7,PLTYPE),
     -    COLPLT(3,PLTYPE),COLPLT(4,PLTYPE),.TRUE.,NXTSST)

C---- Add ticks at appropriate positions
      Y = Y - 33.0
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.FALSE.)

C---- Loop through the residues and print single-letter or three-letter
C     residue codes
      Y = Y - 6.0
      DO 400, IPIN = 1, NPIN
          X = XPORIG + (IPIN - 0.5) * SCALEX
          XLAST = X

C----     Find single-letter code for this residue
          ICODE = 0
          DO 300, N = 1, 20
              IF (PINRES(IPIN).EQ.CODE(N)) THEN
                  ICODE = N
                  GO TO 350
              ENDIF
 300      CONTINUE

C----     If not one of the standard 20, then print full 3-letter code
 350      CONTINUE
          IF (ICODE.EQ.0) THEN
              CALL PSCTXT(X,Y,8.0,PINRES(IPIN)(1:1))
              RCHAR = PINRES(IPIN)(2:2)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 6.0,8.0,RCHAR)
              RCHAR = PINRES(IPIN)(3:3)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 12.0,8.0,RCHAR)

C----     Otherwise, print the single-letter code
          ELSE
              RCHAR = AMINO1(ICODE:ICODE)
              CALL PSCTXT(X,Y,8.0,RCHAR)
          ENDIF
 400  CONTINUE

C---- Plot ticks and residue numbers
      Y = Y - 16.0
      CALL PINRNO(XPORIG,XPORIG + XPWID,Y,PINSNO,
     -    MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.TRUE.)

C---- If any restraint types have been excluded, then show this on the plot
      X = XPORIG + 300.0
      Y = Y + 16.0
      CALL PLEXCL(X,Y)

C---- Re-initalise arrays
      DO 810, IRES = 1, NRES
          FINPIN(IRES) = 0
 810  CONTINUE
      DO 850, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          DO 830, IFILE = 1, MXFILE
              TYPIN(IFILE,NPIN) = ' '
 830      CONTINUE
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          PINSNO(NPIN) = ' '
 850  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINVIO  -   Produce the Residue-by-residue violations plot
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINVIO(PLTYPE,ACDIST,VIOLAT,SINDEX,NFILE,MAXCON)

      INCLUDE 'vplot.inc'

      INTEGER       MAXCON, NFILE

      CHARACTER*1   BRKCH, CHNEND, CIS, DAMINO, DTYPE, INCHN, LSTBRK,
     -              LSTCHN, NXTCHN, NXTCIS, NXTSST, OLDCHN,
     -              PINCIS(MXPINS), PINSST(MXPINS), RTYPE
      CHARACTER*2   PINCHN(MXPINS), TYPIN(MXFILE,MXPINS)
      CHARACTER*3   PINRES(MXPINS), RESDUE
      CHARACTER*5   PINSNO(MXPINS)
      CHARACTER*6   NUMBER
      CHARACTER*9   HANDLE
      CHARACTER*30  PLDESC
      CHARACTER*60  PTITLE
      INTEGER       BGAP, FGAP, FPIN, I, IATOM1, IATOM2, ICONS, ICONST,
     -              IFILE, IGAP, IGFACT, IMODEL, IPOS, IRES, IRES1,
     -              IRES2, ITORS, LINE, LINEA, LSTRES, NGAPY(3),
     -              NREST(2,MXPINS), NGAP, NPAGE, NPIN, NRESTS, PLTYPE,
     -              SINDEX(2 * MAXCON), THEPIN, TRESTS
      LOGICAL       BRKPOS(MXPINS), FIRST, MUSTIN(3), PAGEND, PINOPE,
     -              WANTED
      REAL          ACDIST(NFILE + 2,MAXCON), CALVAL, LOWER, OMEGA,
     -              PINACC(MXPINS), PINANC(MXTORS,MXPINS), PINBOT(3),
     -              PINCON(MXRCON,MXPINS),
     -              PINDAT(MXFILE,MXPINS,3), PINLOW(MXFILE,MXPINS,3),
     -              PINDEV(2,MXPINS), PINSCO(NGFACT + 1,MXPINS),
     -              PINTOP(3), TOTVIO, UPPER, VIOLAT(NFILE + 2,MAXCON),
     -              X, XCENTR, XLAST, YLAST

      DATA  BGAP, FGAP / 2, 10 /
      DATA  HANDLE / 'restrviol' /
      DATA  MUSTIN / .FALSE., .TRUE., .TRUE. /
      DATA  PINBOT / 0.0, 0.0, 0.0 /
      DATA  PLDESC / 'Residue-by-residue violations' /
      DATA  PTITLE / 'Residue-by-residue violations' /

C---- Initialise variables
      FIRST = .TRUE.
      NXTCIS = ' '
      DO 50, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          DO 3, ICONS = 1, MXTORS
              PINANC(ICONS,NPIN) = -999.9
 3        CONTINUE
          NREST(1,NPIN) = 0
          NREST(2,NPIN) = 0
          DO 4, ICONS = 1, MXRCON
              PINCON(ICONS,NPIN) = 0.0
 4        CONTINUE
          DO 20, IFILE = 1, MXFILE
              PINDAT(IFILE,NPIN,1) = 999.9
              PINDAT(IFILE,NPIN,2) = 0.0
              PINDAT(IFILE,NPIN,3) = 999.9
              PINLOW(IFILE,NPIN,1) = 999.9
              PINLOW(IFILE,NPIN,2) = 0.0
              PINLOW(IFILE,NPIN,3) = 999.9
              TYPIN(IFILE,NPIN) = ' '
 20       CONTINUE
          PINDEV(1,NPIN) = 0.0
          PINDEV(2,NPIN) = 0.0
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 40, IGFACT = 1, NGFACT + 1
              PINSCO(IGFACT,NPIN) = 999.99
 40       CONTINUE
          PINSNO(NPIN) = ' '
 50   CONTINUE
      PINOPE = .FALSE.
      TRESTS = 0

C---- Initialise variables
      BRKCH = ' '
      CHNEND = '>'
      FPIN = 0
      INCHN = ' '
      LINE = 0
      LINEA = 0
      LSTBRK = ' '
      LSTCHN = ' '
      NPAGE = 0
      NPIN = 0
      OLDCHN = ' '
      THEPIN = MXPINS
      IF (NRES.LT.MXPINS .AND. NRES.GT.2) THEPIN = NRES
      THEPIN = MXPINS
      XCENTR = XPORIG + XPWID / 2.0

C---- Calculate maximum value for each plot
      PINTOP(1) = 0.0
      PINTOP(2) = 0.0
      PINTOP(3) = 0.0

C---- Initialise the residue number
      IRES1 = 0
      LSTRES = 0
      NRESTS = 0
      TOTVIO = 0.0

C---- Loop through all the sorted restraints to find those applying to
C     each residue
      DO 200, ICONS = 1, 2 * TCONST

C----     Get pointer to the next restraint
          ICONST = ABS(SINDEX(ICONS))

C----     Determine whether this restraint is wanted
          CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -        SINDEX(ICONS),IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,
     -        WANTED)

C----     If restraint is within the same residue only take
C         first instance of it to avoid double-counting
          IF (IRES1.EQ.IRES2) THEN
              IF (IATOM1.LT.IATOM2) THEN
                  WANTED = .TRUE.
              ELSE
                  WANTED = .FALSE.
              ENDIF
          ELSE
              WANTED = .TRUE.
          ENDIF

C----     If the restraint is wanted, accumulate the graph limits
          IF (WANTED) THEN

C----         If this is not the same residue as before, then increment
C             totals
              IF (IRES1.NE.LSTRES) THEN

C----             If this is the highest value so far, update maximum
C                 value
                  PINTOP(2) = MAX(TOTVIO,PINTOP(2))
                  PINTOP(3) = MAX(REAL(NRESTS),PINTOP(3))

C----             Reset accumulator
                  NRESTS = 0
                  TOTVIO = 0.0
                  LSTRES = IRES1
              ENDIF

C----         Loop through all the structures in the ensemble
              DO 100, IMODEL = 1, NMODEL

C----             If this is the highest value so far, update maximum
C                 value
                  PINTOP(1) = MAX(ABS(VIOLAT(IMODEL,ICONST)),PINTOP(1))

C----             If this is a violation, increment total
C                 violations for this residue
                  IF (VIOLAT(IMODEL,ICONST).GT.0.0) THEN
                      TOTVIO = TOTVIO + VIOLAT(IMODEL,ICONST)
                  ENDIF
 100          CONTINUE              

C----         Increment count of restraints for this residue
              NRESTS = NRESTS + 1
          ENDIF
 200  CONTINUE

C---- Update maximum values to include last residue
      PINTOP(2) = MAX(TOTVIO,PINTOP(2))
      PINTOP(3) = MAX(REAL(NRESTS),PINTOP(3))

C---- Adjust maximum values, if necessary
      DO 300, I = 1, 3
          PINTOP(I) = 1.1 * PINTOP(I)
          CALL ADJLIM(PINBOT(I),PINTOP(I),NGAPY(I),MUSTIN(I))
 300  CONTINUE

C---- Initialise variables
      NXTCIS = ' '
      NPIN = 0

C---- Loop over all the residues in the sequence to accumulate the
C     data for all the plots
      DO 1000, IPOS = 1, NRES

C----     Get the pointer to the next residue
          IF (IPOS.EQ.1) THEN
              IRES = FSTRES
          ELSE
              IRES = NXTRES(IRES)
          ENDIF
          NPIN = NPIN + 1
          RESDUE = VALSNO(IRES)(7:9)

C----     Initialise cis-peptide and D-amino acid markers
          CIS = NXTCIS
          NXTCIS = ' '
          DAMINO = ' '

C----     Loop through all structures in the ensemble for
C         this residue
          DO 400, IMODEL = 1, NMODEL

C----         Case of trans peptide (ie 315 > omega > 45) 
              OMEGA = VALUE(LOCOME,IRES,IMODEL)
              IF (OMEGA.GE.45.0 .AND. OMEGA.LE.315.0) THEN
                  OMEGA = ABS(OMEGA - GLOBOM)

C----         Case of cis peptide (ie abs(omega) < 45) 
              ELSE IF (ABS(OMEGA).LT.900.0) THEN
                  NXTCIS = 'c'
              ELSE
                  OMEGA = 999.9
              ENDIF
              VALUE(LOCOME,IRES,IMODEL) = OMEGA

C----         Alpha carbon chirality
              CALVAL = VALUE(LOCZET,IRES,IMODEL)
              IF (CALVAL.LT.900.0) THEN
                  IF (CALVAL.LT.0) DAMINO = 'D'
                  CALVAL = ABS(CALVAL - GLOBDH)
              ENDIF
              VALUE(LOCZET,IRES,IMODEL) = CALVAL
 400      CONTINUE

C----     Extract all the dihedral angle restraints for
C         this residue
          DO 500, ITORS = 1, MXTORS
              IF (DIHCON(1,ITORS,IRES).LT.900.0) THEN
                  PINANC(ITORS,NPIN) = 0.0
                  DO 450, IMODEL = 1, NMODEL
                      PINANC(ITORS,NPIN)
     -                    = PINANC(ITORS,NPIN)
     -                    + DVIOLM(ITORS,IRES,IMODEL)
     -                    / REAL(NMODEL)
 450              CONTINUE
              ENDIF
 500      CONTINUE

C----     Transfer the plot details for this residue into
C         the pin arrays
          PINACC(NPIN) = VALOOI(IRES)
          IF (CIS.EQ.'c' .AND. DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = 'X'
          ELSE IF (CIS.EQ.'c') THEN
              PINCIS(NPIN) = CIS
          ELSE IF (DAMINO.EQ.'D') THEN
              PINCIS(NPIN) = DAMINO
          ENDIF
          PINRES(NPIN) = RESDUE
          DO 550, IGFACT = 1, NGFACT + 1
              PINSCO(IGFACT,NPIN) = GFACT(IGFACT,IRES)
 550      CONTINUE
          PINSNO(NPIN) = VALSNO(IRES)(2:6)
          PINSST(NPIN) = CONSST(IRES)
          IF (NPIN.EQ.NRES) THEN
              NXTSST = '='
          ELSE
              NXTSST = CONSST(IRES + 1)
          ENDIF
          OLDCHN = INCHN
          INCHN = VALSNO(IRES)(1:1)
          CHNEND = ' '
          IF (IPOS.EQ.1) THEN
              CHNEND = '>'
              OLDCHN = INCHN
          ENDIF
          IF (IPOS.EQ.NRES) CHNEND = '<'
          PINCHN(NPIN) = INCHN // CHNEND
          NXTCHN = INCHN
          BRKCH = CHNBRK(IRES)

C----     Transfer the RMS deviation and restraints data
          PINDEV(1,NPIN) = RMSALL(1,IRES)
          PINDEV(2,NPIN) = RMSALL(2,IRES)

C----     Determine whether at a chain-end or chain-start
          IF (NPIN.GT.0) THEN
              IF (OLDCHN.NE.NXTCHN) THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (OLDCHN.NE.LSTCHN) THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.'!') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
              ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.' ') THEN
                  CHNEND = '>'
                  PINCHN(NPIN)(2:2) = CHNEND
              ELSE IF (BRKCH.EQ.'x') THEN
                  CHNEND = '<'
                  PINCHN(NPIN)(2:2) = CHNEND
                  CHNEND = '!'
              ENDIF
              LSTBRK = BRKCH
              LSTCHN = OLDCHN
          ENDIF

C----     Loop through all the sorted restraints to find those applying to
C         the current residue
          DO 700, ICONS = 1, 2 * TCONST

C----         Get pointer to the next restraint
              ICONST = ABS(SINDEX(ICONS))

C----         Determine whether this restraint is wanted
              CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,
     -           UPPER,SINDEX(ICONS),IRES1,IRES2,IATOM1,IATOM2,
     -           RTYPE,DTYPE,WANTED)

C----         See if it belongs to the current residue of interest
              IF (IRES1.EQ.IRES) THEN
                  WANTED = .TRUE.
              ELSE
                  WANTED = .FALSE.
              ENDIF

C----         If the restraint is wanted, accumulate the data
              IF (WANTED) THEN

C----             Increment the count of upper-bound restraints for
C                 this residue
                  IF (RESTYP(ICONST).EQ.'U' .OR.
     -                RESTYP(ICONST).EQ.'B') THEN
                      IF (IRES1.EQ.IRES2) THEN
                          IF (IATOM1.LT.IATOM2) THEN
                              NREST(1,NPIN) = NREST(1,NPIN) + 1
                          ELSE
                              NREST(2,NPIN) = NREST(2,NPIN) + 1
                          ENDIF
                      ELSE
                          NREST(1,NPIN) = NREST(1,NPIN) + 1
                      ENDIF
                      TRESTS = TRESTS + 1
                  ENDIF
              ENDIF

C----         If restraint is within the current residue only take
C             first instance of it
              IF (WANTED) THEN
                  IF (IRES1.EQ.IRES2) THEN
                      IF (IATOM1.LT.IATOM2) THEN
                          WANTED = .TRUE.
                      ELSE
                          WANTED = .FALSE.
                      ENDIF
                  ELSE
                      WANTED = .TRUE.
                  ENDIF
              ENDIF

C----         If the restraint is wanted, accumulate the data
              IF (WANTED) THEN

C----             Loop through all structures in the ensemble for this
C                 residue to update the graph data
                  DO 600, IMODEL = 1, NMODEL

C----                 If this is the highest value for this model
C                     so far, update maximum value (for upper-
C                     and lower bounds)
                      IF (VIOLAT(IMODEL,ICONST).GT.0.0) THEN
                          IF (PINDAT(IMODEL,NPIN,1).GT.900.0) THEN
                              PINDAT(IMODEL,NPIN,1)
     -                            = ABS(VIOLAT(IMODEL,ICONST))
                          ELSE
                              PINDAT(IMODEL,NPIN,1)
     -                            = MAX(ABS(VIOLAT(IMODEL,ICONST)),
     -                                  PINDAT(IMODEL,NPIN,1))
                          ENDIF
                          IF (NREST(1,NPIN).LE.MXRCON) THEN
                              PINCON(NREST(1,NPIN),NPIN)
     -                            = PINCON(NREST(1,NPIN),NPIN)
     -                            + 1.0 / REAL(NMODEL)
                          ENDIF
                          TYPIN(IMODEL,NPIN) = DTYPE // RTYPE
                      ELSE IF (VIOLAT(IMODEL,ICONST).LT.0.0) THEN
                          IF (PINLOW(IMODEL,NPIN,1).GT.900.0) THEN
                              PINLOW(IMODEL,NPIN,1)
     -                            = ABS(VIOLAT(IMODEL,ICONST))
                          ELSE
                              PINLOW(IMODEL,NPIN,1)
     -                            = MAX(ABS(VIOLAT(IMODEL,ICONST)),
     -                                  PINLOW(IMODEL,NPIN,1))
                          ENDIF
                          TYPIN(IMODEL,NPIN) = DTYPE // RTYPE
                      ENDIF

C----                 If this is an upper-bound violation, increment total
C                     violations for this residue
                      IF (VIOLAT(IMODEL,ICONST).GT.0.0) THEN
                          PINDAT(IMODEL,NPIN,2)
     -                        = PINDAT(IMODEL,NPIN,2)
     -                        + VIOLAT(IMODEL,ICONST)
                      ENDIF
 600              CONTINUE
              ENDIF
 700      CONTINUE

C----     If have a pageful of data, then produce the pinplot
          IF (NPIN.EQ.THEPIN) THEN

C----         If current PostScript file is open, close it
              IF (PINOPE) THEN
                  CALL PSENDP
                  IF (.NOT.COMBPS) THEN
                      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                  ENDIF
              ENDIF

C----         Open new PostScript file
              CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,
     -            HANDLE,XCENTR)

C----         Produce current page
              CALL PINVPT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,
     -            PINRES,PINSST,PINLOW,PINCHN,PINSNO,BRKPOS,
     -            PINACC,PINSCO,PINCIS,PLTYPE,NREST,PINCON,
     -            PINANC,PINBOT,PINTOP,NGAPY,NFILE,NXTSST,TYPIN,
     -            XLAST,YLAST)
              FIRST = .FALSE.
              PINOPE = .TRUE.
              FPIN = FPIN + THEPIN
              NPIN = 0
              CHNEND = ' '
          ENDIF

C----     Check whether this residue is the end of a chain
          IF (CHNEND.EQ.'<' .OR. CHNEND.EQ.'!') THEN

C----         Leave the appropriate number of blanks between the chains
              PAGEND = .FALSE.
              IF (CHNEND.EQ.'<') THEN
                  NGAP = FGAP
              ELSE
                  NGAP = BGAP
              ENDIF
              DO 800, IGAP = 1, NGAP

C----             Add blanks providing that haven't reached end of page
                  IF (.NOT.PAGEND .AND. IRES.NE.NRES) THEN
                      NPIN = NPIN + 1
                      BRKPOS(NPIN) = .TRUE.

C----                 If have a pageful of data, then produce
C                     the plot
                      IF (NPIN.EQ.THEPIN) THEN

C----                     If current PostScript file is open, close it
                          IF (PINOPE) THEN
                              CALL PSENDP
                              IF (.NOT.COMBPS) THEN
                                  CALL PSCLOS(BBOXX1,BBOXX2,
     -                                BBOXY1,BBOXY2)
                              ENDIF
                          ENDIF

C----                     Open new PostScript file
                          CALL PGOPEN(FIRST,NPAGE,PLTYPE,
     -                        PTITLE,PLDESC,HANDLE,XCENTR)

C----                     Produce current page
                          CALL PINVPT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,
     -                        PINRES,PINSST,PINLOW,PINCHN,PINSNO,BRKPOS,
     -                        PINACC,PINSCO,PINCIS,PLTYPE,NREST,PINCON,
     -                        PINANC,PINBOT,PINTOP,NGAPY,NFILE,NXTSST,
     -                        TYPIN,XLAST,YLAST)
                          FIRST = .FALSE.
                          PINOPE = .TRUE.
                          FPIN = FPIN + THEPIN
                          NPIN = 0
                          CHNEND = ' '
                          PAGEND = .TRUE.
                      ENDIF
                  ENDIF
 800          CONTINUE
          ENDIF
 1000 CONTINUE

C---- If any more data left to be printed, then produce the pinplot
      IF (NPIN.GT.0) THEN

C----     If current PostScript file is open, close it
          IF (PINOPE) THEN
              CALL PSENDP
              IF (.NOT.COMBPS) THEN
                  CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
              ENDIF
          ENDIF

C----     Open new PostScript file
          CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,HANDLE,XCENTR)

C----     Produce current page
          CALL PINVPT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,PINRES,
     -        PINSST,PINLOW,PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,
     -        PLTYPE,NREST,PINCON,PINANC,PINBOT,PINTOP,NGAPY,NFILE,
     -        NXTSST,TYPIN,XLAST,YLAST)
          FIRST = .FALSE.
          PINOPE = .TRUE.
      ENDIF

C---- Print total number of restraints and close the PotScript file
      IF (PINOPE) THEN
          X = XLAST + 20.0
          CALL PSCTXT(X,YLAST + 12.0,6.0,'Total')
          WRITE(NUMBER,1020) TRESTS / 2
1020      FORMAT(I6)
          IPOS = 1
          IF (NUMBER(1:1).EQ.' ') IPOS = 2
          IF (NUMBER(2:2).EQ.' ') IPOS = 3
          IF (NUMBER(3:3).EQ.' ') IPOS = 4
          IF (NUMBER(4:4).EQ.' ') IPOS = 5
          CALL PSCTXT(X,YLAST + 6.0,6.0,NUMBER(IPOS:6))
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINVPT  -  Print current page for Residue-by-residue
C                        violations plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINVPT(THEPIN,NPIN,FPIN,PINDAT,PINDEV,PINRES,PINSST,
     -    PINLOW,PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,
     -    PLTYPE,NREST,PINCON,PINANC,PINBOT,PINTOP,NGAPY,NFILE,NXTSST,
     -    TYPIN,XLAST,YLAST)

      SAVE

      INCLUDE 'vplot.inc'

      REAL          CONSTY, ENOTE1, ENOTE2, NOTE1Y, NOTEX1, NOTEX2,
     -              NOTEY1, NOTEY2, SECSTY, STACHT
      PARAMETER    (
     -              CONSTY =  220.0,
     -              ENOTE1 =   30.0,
     -              ENOTE2 =   22.0,
     -              NOTE1Y =   38.0,
     -              NOTEX1 =  150.0,
     -              NOTEX2 =  145.0,
     -              NOTEY1 =   17.0,
     -              NOTEY2 =   25.0,
     -              SECSTY =   60.0,
     -              STACHT =   70.0
     -             )

      REAL          MKSIZE, SIZLAB, TSIZE, YRORIG, YRSEP, YRWID
      PARAMETER    (
     -              MKSIZE =    5.0,
     -              SIZLAB =   10.0,
     -              TSIZE  =   15.0,
     -              YRORIG =  380.0,
     -              YRSEP  =   80.0,
     -              YRWID  =  100.0
     -             )

      INTEGER       THEPIN, NFILE

      CHARACTER*1   A, DTYPE(MXFILE), NXTSST, PINSST(THEPIN),
     -              PINCIS(THEPIN), RCHAR, RTYPE(MXFILE)
      CHARACTER*2   PINCHN(THEPIN), TYPIN(MXFILE,MXPINS)
      CHARACTER*3   CODE(20), PINRES(THEPIN)
      CHARACTER*5   PINSNO(THEPIN), TICLAB(MXPINS)
      CHARACTER*20  AMINO1
      CHARACTER*26  LOWER
      CHARACTER*60  PLTHED(MXPLOT), PLTYHD(MXPLOT)
      INTEGER       FPIN, ICODE, ICOLR, ICONS, IDIST, IFILE, IGRAPH,
     -              IMODEL, IPIN, IRGRAF, LABNUM(MXFILE), N, NGAPY(3),
     -              NOFFDN, NOFFUP, NREST(2,MXPINS), NPIN, NSTD, PLOTNO,
     -              PLTHLN(MXPLOT), PLTYLN(MXPLOT), PLTYPE,
     -              TICLEN(MXPINS), VINDEX(MXRCON)
      LOGICAL       BRKPOS(MXPINS), TICPOS(MXPINS)
      REAL          LASTYP, PLTDUM(3), PINACC(THEPIN),
     -              PINANC(MXTORS,MXPINS), PINBOT(3),
     -              PINCON(MXRCON,MXPINS),
     -              PINDAT(MXFILE,MXPINS,3), PINDEV(2,THEPIN),
     -              PINLOW(MXFILE,MXPINS,3), PINSCO(NGFACT + 1,THEPIN),
     -              PINTOP(3), SCALEX, SCALEY, SHADE, VVALUE(MXRCON), X,
     -              XCENTR, XLAST, X1, X2, Y, YLAST, YMAX, YP, Y1, Y2

      DATA  A      / 'A' /
      DATA  AMINO1 / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /

      DATA  PLTHED / 
     -    'x. Maximum upper-bound restraint violation per model',
     -    'x. Total upper-bound violations from all models',
     -    'x. Maximum upper-bound violation per model'
     -            /

      DATA  PLTHLN /  52, 47, 42 /

      DATA  PLTYHD /
     -    'Max. violation (A)',
     -    'Total violation (A)',
     -    'Max. violation (A)'
     -            /

      DATA  PLTYLN /  18, 19, 18 /

C---- Initialise variables
      PLTDUM(1) = 0.0
      PLTDUM(2) = 0.0
      PLTDUM(3) = 0.0
      XCENTR = XPORIG + XPWID / 2.0
      YP = YRORIG + 2.0 * YRWID + YRSEP
      SCALEX = XPWID / THEPIN
      DO 50, ICONS = 1, MXRCON
          VVALUE(ICONS) = 0.0
          VINDEX(ICONS) = ICONS
 50   CONTINUE
      CALL PSLWID(0.1)

C---- Loop through the two graphs to be plotted
      IRGRAF = 0
      NSTD = 0
      DO 200, IGRAPH = 1, 2

C----     Determine position on page
          YP = YRORIG + (2 - IGRAPH) * (YRWID + YRSEP)
          PLOTNO = IGRAPH

C----     Plot the graph box and axes
          IRGRAF = IRGRAF + 1
          PLTHED(PLOTNO)(1:1) = LOWER(IRGRAF:IRGRAF)
          CALL PINGBX(XPORIG,YP,XPWID,YRWID,BSHADE(PLTYPE),
     -        PINBOT(PLOTNO),PINTOP(PLOTNO),FPIN,FPIN + THEPIN,
     -        PLTHED(PLOTNO),PLTHLN(PLOTNO),PLTYHD(PLOTNO),
     -        PLTYLN(PLOTNO),PLTYHD(PLOTNO),PLTYLN(PLOTNO),
     -        INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(2,PLTYPE),
     -        COLPLT(2,PLTYPE),NGAPY(PLOTNO),SCALEY,1)

C----     Print the residue numbers along the x-axis
          CALL PINRNO(XPORIG,XPORIG + XPWID,YP,PINSNO,
     -        MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)
          CALL PSCTXT(XCENTR,YP - 22.0,15.0,'Residue number')

C----     Plot histogram or points, according to graph type
          IF (IGRAPH.EQ.1) THEN

C----         Loop over all the points to be plotted
              DO 100, IPIN = 1, NPIN

C----             Calculate x-position
                  X = XPORIG + (REAL(IPIN) - 0.5) * SCALEX

C----             Initialise all the point labels and types
                  DO 80, IMODEL = 1, NMODEL
                      LABNUM(IMODEL) = ACTNUM(IMODEL)
                      DTYPE(IMODEL) = TYPIN(IMODEL,IPIN)(1:1)
                      RTYPE(IMODEL) = TYPIN(IMODEL,IPIN)(2:2)
 80               CONTINUE

C----             Print all the data points for this restraint
                  CALL PLTPTS(PINDAT(1,IPIN,IGRAPH),NMODEL,X,YP,
     -                PINBOT(PLOTNO),PINTOP(PLOTNO),MKSIZE,DTYPE,RTYPE,
     -                SCALEY,PLTYPE,.TRUE.,LABNUM,TOPMOD,NOFFDN,NOFFUP)
 100          CONTINUE
              LASTYP = YP

C----         Print explanatory note
              X = XPORIG
              Y = LASTYP - NOTEY1
              CALL PSTEXT(X,Y,8.0,'All restraint violations given in' //
     -            ' Angstroms')

C----         Print key to symbols
              Y = Y - 22.0
              CALL SYMKEY(X,Y,MKSIZE,PLTYPE,.TRUE.,.TRUE.)
          ELSE

C----         Plot the graph bars for the residues on this page
              CALL PINBOX(MXFILE,NFILE,THEPIN,NPIN,
     -            PINDAT(1,1,IGRAPH),XPORIG,YP,YRWID,SCALEX,
     -            YRWID / PINTOP(PLOTNO),INCOLR(PLTYPE),MXCOLR,
CHECK v.3.4.3-->
C     -            RGB,COLPLT(9,PLTYPE),MWANT,NMODEL,TOPMOD)
     -            RGB,COLPLT(9,PLTYPE),MWANT)
CHECK v.3.4.3<--
              LASTYP = YP

C----         Print explanatory text below graph
              X = XPORIG
              YP = LASTYP - NOTEY1
              CALL PSTEXT(X,YP,8.0,'Cumulative violations from each ' //
     -            'model, stacked')
              YP = LASTYP - NOTEY2
              CALL PSTEXT(X,YP,8.0,'one above the other')

C----         Print explanatory text below graph
              X = XPORIG + XPWID - NOTEX2
              YP = LASTYP - NOTEY1
              CALL PSTEXT(X,YP,8.0,'Numbers indicate models making' //
     -            ' largest contrib.')
          ENDIF

 200  CONTINUE

C---- Print the "wiring diagram" showing the secondary structure, with
C     background shading giving a measure of the accessibility
      IRGRAF = IRGRAF + 1
      Y = YRORIG - SECSTY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Secondary structure & average estimated accessibility')
      Y = Y - 18.0
      CALL PSLWID(0.0)
      IF (SHOWAC) THEN
          CALL ACCSHD(THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
     -        SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(4,PLTYPE),
     -        COLPLT(3,PLTYPE))
      ENDIF
      CALL SSPLOT(THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRES,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(7,PLTYPE),
     -    COLPLT(3,PLTYPE),COLPLT(4,PLTYPE),.TRUE.,NXTSST)

C---- Show the number of restraints per residue and a measure of the
C     restraint violations
      Y = YRORIG - CONSTY 
      CALL PSLWID(0.0)

C---- Upper-bound restraint violations
      CALL CNPLOT(XPORIG,SCALEX,Y,NREST,PINCON,MXPINS,
     -    NPIN,INCOLR(PLTYPE),MXCOLR,RGB,PINSST,MXRCON,MXTORS,VVALUE,
     -    VINDEX,PINANC,HAVANG,1,COLPLT(9,PLTYPE),
     -    COLPLT(10,PLTYPE),STACHT,YMAX,NINT(PINTOP(3)))

C---- Print the heading above the highest point
      IRGRAF = IRGRAF + 1
      YMAX = YMAX + 13.0
      CALL PSTEXT(XPORIG,YMAX,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Numbers of restraints per residue')

C---- Add ticks at appropriate positions
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.FALSE.)
      YLAST = Y

C---- Loop through the residues and print single-letter or three-letter
C     residue codes
      Y = Y - 6.0
      DO 400, IPIN = 1, NPIN
          X = XPORIG + (IPIN - 0.5) * SCALEX
          XLAST = X

C----     Find single-letter code for this residue
          ICODE = 0
          DO 300, N = 1, 20
              IF (PINRES(IPIN).EQ.CODE(N)) THEN
                  ICODE = N
                  GO TO 350
              ENDIF
 300      CONTINUE

C----     If not one of the standard 20, then print full 3-letter code
 350      CONTINUE
          IF (ICODE.EQ.0) THEN
              CALL PSCTXT(X,Y,8.0,PINRES(IPIN)(1:1))
              RCHAR = PINRES(IPIN)(2:2)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 6.0,8.0,RCHAR)
              RCHAR = PINRES(IPIN)(3:3)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 12.0,8.0,RCHAR)

C----     Otherwise, print the single-letter code
          ELSE
              RCHAR = AMINO1(ICODE:ICODE)
              CALL PSCTXT(X,Y,8.0,RCHAR)
          ENDIF
 400  CONTINUE

C---- Plot ticks and residue numbers
      Y = Y - 40.0
      CALL PINRNO(XPORIG,XPORIG + XPWID,Y,PINSNO,
     -    MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,TSIZE)
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.TRUE.)

C---- Print explanatory notes at bottom of page
      X = XPORIG
      Y = Y - 20.0
      SHADE = 1.0
      X1 = X
      X2 = X + MKSIZE / 2.0
      Y1 = Y - MKSIZE / 4.0
      Y2 = Y + MKSIZE / 4.0
      ICOLR = COLPLT(9,PLTYPE)
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSTEXT(X + 10.0,Y,8.0,'Unviolated restraints')
      Y = Y - 8.0
      SHADE = 0.0
      Y1 = Y - MKSIZE / 4.0
      Y2 = Y + MKSIZE / 4.0
      ICOLR = COLPLT(10,PLTYPE)
      CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
      CALL PSTEXT(X + 10.0,Y,8.0,'Violated restraints')

C---- If any restraint types have been excluded, then show this on the plot
      X = XPORIG + 300.0
      Y = Y + 16.0
      CALL PLEXCL(X,Y)

C---- Re-initalise arrays
      DO 850, NPIN = 1, MXPINS
          BRKPOS(NPIN) = .FALSE.
          NXTSST = '='
          PINACC(NPIN) = 0.0
          PINCIS(NPIN) = ' '
          NREST(1,NPIN) = 0
          NREST(2,NPIN) = 0
          DO 720, ICONS = 1, MXRCON
              PINCON(ICONS,NPIN) = 0.0
 720      CONTINUE
          DO 760, ICONS = 1, MXTORS
              PINANC(ICONS,NPIN) = -999.0
 760      CONTINUE
          DO 830, IFILE = 1, MXFILE
              PINDAT(IFILE,NPIN,1) = 999.9
              PINDAT(IFILE,NPIN,2) = 0.0
              PINDAT(IFILE,NPIN,3) = 999.9
              PINLOW(IFILE,NPIN,1) = 999.9
              PINLOW(IFILE,NPIN,2) = 0.0
              PINLOW(IFILE,NPIN,3) = 999.9
              TYPIN(IFILE,NPIN) = ' '
 830      CONTINUE
          PINDEV(1,NPIN) = 0.0
          PINDEV(2,NPIN) = 0.0
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 840, IDIST = 1, NGFACT + 1
              PINSCO(IDIST,NPIN) = 999.99
 840      CONTINUE
          PINSNO(NPIN) = ' '
 850  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PINBOX  -  Print histogram bars for pins plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE PINBOX(MXFILE,NFILE,THEPIN,NPIN,PINDAT,XP,YP,YPWID,
CHECK v.3.4.3-->
C     -    SCALEX,SCALEY,INCOLR,MXCOLR,RGB,COLGD,MWANT,NMODEL,TOPMOD)
     -    SCALEX,SCALEY,INCOLR,MXCOLR,RGB,COLGD,MWANT)
CHECK v.3.4.3<--

      CHARACTER*3   NUMBER
      INTEGER       COLGD, IFILE, IPIN, IPOS, MODMAX, MXCOLR, MXFILE,
CHECK v.3.4.3-->
C     -              NFILE, NMODEL, NPIN, THEPIN, TOPMOD
     -              NFILE, NPIN, THEPIN
CHECK v.3.4.3<--
      LOGICAL       INCOLR, MWANT(MXFILE)
      REAL          PINDAT(MXFILE,THEPIN), RGB(3,MXCOLR), SCALEX,
     -              SCALEY, TSIZE, VALMAX, XP, X1, X2, Y, YP, YPWID,
     -              Y1, Y2

C---- Plot the values
      CALL PSLWID(0.1)
      X1 = XP
      Y1 = YP
      DO 100, IPIN = 1, NPIN
          X2 = X1 + SCALEX
          Y = Y1
          VALMAX = 0.0
          MODMAX = 0

C----     Loop over all the files in the ensemble
          DO 50, IFILE = 1, NFILE

C----         Process only if this is one of the selected models
              IF (MWANT(IFILE)) THEN

                  IF (PINDAT(IFILE,IPIN).LT.990.0 .AND.
     -                PINDAT(IFILE,IPIN).GT.0.0) THEN
                      IF (PINDAT(IFILE,IPIN).GT.VALMAX) THEN
                          VALMAX = PINDAT(IFILE,IPIN)
                          MODMAX = IFILE
                      ENDIF
                      Y2 = SCALEY * PINDAT(IFILE,IPIN)
                      Y2 = Y + Y2
                      IF (Y2.GT.Y1 + YPWID) Y2 = Y1 + YPWID
                      CALL PSHADE(1.0,COLGD,RGB,MXCOLR,INCOLR)
                      CALL PSBBOX(X1,Y,X2,Y,X2,Y2,X1,Y2)
                      Y = Y2
                  ENDIF
              ENDIF
 50       CONTINUE

C----     Print the model number with the highest total deviation above
C         the histogram
          IF (MODMAX.NE.0 .AND. NFILE.GT.1) THEN
              WRITE(NUMBER,60) MODMAX
 60           FORMAT(I3)
              IPOS = 1
              IF (MODMAX.LT.100) IPOS = 2
              IF (MODMAX.LT.10) IPOS = 3
              TSIZE = 8.0
              IF (NFILE.GT.9) TSIZE = 6.0
              CALL PSCTXT((X1 + X2) / 2.0,Y + 8.0,TSIZE,NUMBER(IPOS:))
          ENDIF
          X1 = X2
 100  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE ACCSHD  -  Shade in the background of the secondary
C                        structure "wiring diagram" to give an indication
C                        of the relative accessibility
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE ACCSHD(THEPIN,NPIN,PINACC,PINSST,XP,YP,DX,
     -    SSSIZE,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)

      SAVE

      INTEGER       MXCOLR, NPIN, THEPIN
      CHARACTER*1   PINSST(THEPIN), SECSTR
CHECK v.3.4.3-->
C      INTEGER       ISTRUC, IPIN, IRES, LSTRUC, MAXCOL, MINCOL
      INTEGER       IPIN, IRES, MAXCOL, MINCOL
CHECK v.3.4.3<--
      LOGICAL       BLANK, INCOLR
      REAL          DX, HEIGHT, MINHT, PINACC(THEPIN), RGB(3,MXCOLR),
     -              SHADE, SSSIZE, X, XP, X1, X2, Y, YDIFF, YP, Y1, Y2

CHECK v.3.4.3-->
C      DATA IRES,LSTRUC   / 0, 0 /
      DATA IRES   / 0 /
CHECK v.3.4.3<--

C---- Initialise values
      HEIGHT = SSSIZE * 2.3
      MINHT = HEIGHT
      X = XP
      Y = YP

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)
          IF (SECSTR.EQ.'=') THEN
              BLANK = .TRUE.
          ELSE
              BLANK = .FALSE.
              IRES = IRES + 1
          ENDIF

C----     If not off the end of a chain, draw a shaded patch according to
C         the accessibility
          IF (.NOT.BLANK) THEN
              X1 = X
              X2 = X + DX
              YDIFF = (HEIGHT - MINHT) * (1.0 - PINACC(IPIN) / 100.0)
              Y1 = Y - MINHT - YDIFF
              Y2 = Y + MINHT + YDIFF
              SHADE = PINACC(IPIN) / 100.0
              IF (SHADE.LT.0.0) SHADE = 0.0
              IF (SHADE.GT.1.0) SHADE = 1.0
              CALL PSCALE(SHADE,INCOLR,MXCOLR,RGB,MINCOL,MAXCOL)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          ENDIF

C----     Increment x-position
          X = X + DX

CHECK v.3.4.3-->
CC----     Save current structure
C          LSTRUC = ISTRUC
CHECK v.3.4.3<--
 400  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SSPLOT  -  Draw the secondary structure "wiring diagram"
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE SSPLOT(THEPIN,NPIN,PINSST,XP,YP,DX,NRESID,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR,MXCOLR,RGB,COLOUR,MINACC,MAXACC,SHOWKY,
     -    NXTSST)

      SAVE

      INTEGER       BLANK, COIL, HELIX, STRAND
      PARAMETER    (
     -              BLANK  =   0,
     -              COIL   =   3,
     -              HELIX  =   1,
     -              STRAND =   2
     -             )

      REAL          ARRWID, COIWID, THICK, THIN
      PARAMETER    (
     -              ARRWID = 1.8,
     -              COIWID = 0.25,
     -              THICK  = 0.4,
     -              THIN   = 0.2
     -             )

      INTEGER       MXCOLR, NPIN, THEPIN
      CHARACTER*1   NXTSST, NXTSTR, PINSST(THEPIN), SECSTR
      CHARACTER*2   PINCHN(THEPIN)
      INTEGER       COLOUR, FIRSTH, ISTRUC, IPIN, IRES, LENRUN, LSTRUC,
     -              MAXACC, MINACC, NRESID, SSLEN
      LOGICAL       INCOLR, SHOWAC, SHOWKY
      REAL          DX, HEIGHT, HWIDTH, RGB(3,MXCOLR), SSSIZE, X, XP,
     -              X1, X2, Y, YP, Y1, Y2


C---- Initialise values
      HEIGHT = SSSIZE * 1.5
      HWIDTH = SSSIZE * 1.5
      X = XP
      Y = YP
      LENRUN = 0
      IRES = 0
      LSTRUC = 0
      CALL PSLWID(THIN)

C---- Loop through the residues
      DO 400, IPIN = 1, NPIN

C----     If this is the start of a chain, draw chain-start
          IF (PINCHN(IPIN)(2:2).EQ.'>' .AND.
     -        PINCHN(IPIN)(1:1).NE.' ') THEN
              CALL PSLINE(X,Y - SSSIZE * 0.6,X,Y + SSSIZE * 0.6)

C----         Print the chain identifier
              CALL PSTEXT(X - 10.0,Y,10.0,PINCHN(IPIN)(1:1))
          ENDIF

C----     If this is the end of a chain, draw chain-end
          IF (PINCHN(IPIN)(2:2).EQ.'<') THEN
              CALL PSLINE(X + DX,Y - SSSIZE * 0.6,X + DX,
     -            Y + SSSIZE * 0.6)
          ENDIF

C----     Initialise structure type for this residue
          SECSTR = PINSST(IPIN)
          IF (IPIN.LT.NPIN) THEN
              NXTSTR = PINSST(IPIN + 1)
          ELSE
              NXTSTR = NXTSST
          ENDIF
          IF (SECSTR.NE.'=') IRES = IRES + 1
          IF (SECSTR.EQ.'H' .OR. SECSTR.EQ.'G') THEN
              ISTRUC = HELIX
          ELSE IF (SECSTR.EQ.'E') THEN
              ISTRUC = STRAND
          ELSE IF (SECSTR.EQ.'=') THEN
              ISTRUC = BLANK
          ELSE
              ISTRUC = COIL
          ENDIF

C----     If coil, then draw a horizontal bar
          IF (ISTRUC.EQ.COIL) THEN

C----         Draw the current fragment of the coil
              X1 = X
              X2 = X + DX
              Y1 = Y - SSSIZE * COIWID
              Y2 = Y + SSSIZE * COIWID
              CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
              CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
              CALL PSLINE(X1,Y1,X2,Y1)
              CALL PSLINE(X1,Y2,X2,Y2)

C----         If this is the start of the coil, then start box
              IF (LSTRUC.NE.COIL) THEN
                  CALL PSLINE(X,Y1,X,Y2)
              ENDIF

C----         If this is the last residue of the coil, draw its end
              IF (NXTSTR.EQ.'E' .OR. NXTSTR.EQ.'H' .OR.
     -            NXTSTR.EQ.'G' .OR. IRES.EQ.NRESID) THEN
                  CALL PSLINE(X2,Y1,X2,Y2)
              ENDIF
              X = X + DX

C----     Else if it's a strand, draw a horizontal box
          ELSE IF (ISTRUC.EQ.STRAND) THEN
              
C----         If this is the last residue of the strand, draw the arrow-head
              IF (NXTSTR.NE.'E' .OR. IRES.EQ.NRESID) THEN
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - ARRWID * SSSIZE
                  Y2 = Y + ARRWID * SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
                  CALL PSLINE(X,Y2,X,Y + SSSIZE)
                  CALL PSLINE(X,Y1,X,Y - SSSIZE)
                  CALL PSLINE(X,Y2,X + DX,Y)
                  CALL PSLINE(X,Y1,X + DX,Y)
                  X = X + DX

C----         Otherwise, draw the current fragment of the strand
              ELSE
                  X1 = X
                  X2 = X + DX
                  Y1 = Y - SSSIZE
                  Y2 = Y + SSSIZE
                  CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
                  CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X,Y - SSSIZE,X + DX,Y - SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
                  CALL PSLINE(X,Y + SSSIZE,X + DX,Y + SSSIZE)
                  X = X + DX
              ENDIF
                          
C----         If this is the start of the strand, then start box
              IF (LSTRUC.NE.STRAND) THEN
                  IF (.NOT.SHOWAC) CALL PSLWID(THICK)
                  CALL PSLINE(X1,Y - SSSIZE,X1,Y + SSSIZE)
                  IF (.NOT.SHOWAC) CALL PSLWID(THIN)
              ENDIF

C----     Else if it's a helix, draw a sawtooth
          ELSE IF (ISTRUC.EQ.HELIX) THEN

C----         Increment count of helix residues in current helix
              LENRUN = LENRUN + 1
              IF (LENRUN.EQ.1) FIRSTH = IRES

C----         If at end of the helix, draw it
              IF (IRES.EQ.NRESID .OR. IPIN.EQ.NPIN .OR.
     -            (NXTSTR.NE.'H' .AND. NXTSTR.NE.'G')) THEN
                  CALL DHELIX(LENRUN,X,Y,FIRSTH,DX,HWIDTH,HEIGHT,
     -                SHOWAC,INCOLR,MXCOLR,RGB,COLOUR)
                  LENRUN = 0
              ENDIF
          ELSE
              X = X + DX
          ENDIF                          

C----     Save current structure
          LSTRUC = ISTRUC
 400  CONTINUE

C---- Show key to wiring diagram
      IF (SHOWKY) THEN
          X = XP
          Y = YP - 21.0
          CALL PSTEXT(X,Y,10.0,'Key:-')

C----     Helix
          X = XP + 27.0
          CALL DHELIX(4,X,Y,1,DX,HWIDTH,HEIGHT,SHOWAC,INCOLR,MXCOLR,
     -        RGB,COLOUR)
          X = X + 3.0
          CALL PSTEXT(X,Y,10.0,'Helix')

C----     Strand
          X = XP + 83.0
          X1 = X
          SSLEN = 2
          X2 = X + SSLEN * DX
          Y1 = Y - SSSIZE
          Y2 = Y + SSSIZE
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          IF (.NOT.SHOWAC) CALL PSLWID(THICK)
          CALL PSLINE(X1,Y1,X1,Y2)
          CALL PSLINE(X,Y - SSSIZE,X + SSLEN * DX,Y - SSSIZE)
          IF (.NOT.SHOWAC) CALL PSLWID(THIN)
          CALL PSLINE(X,Y + SSSIZE,X + SSLEN * DX,Y + SSSIZE)
          X = X + SSLEN * DX
          X1 = X
          X2 = X + DX
          Y1 = Y - ARRWID * SSSIZE
          Y2 = Y + ARRWID * SSSIZE
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUTRI(X1,Y1,X1,Y2,X2,Y)
          CALL PSLINE(X,Y2,X,Y + SSSIZE)
          CALL PSLINE(X,Y1,X,Y - SSSIZE)
          CALL PSLINE(X,Y2,X + DX,Y)
          CALL PSLINE(X,Y1,X + DX,Y)
          X = X + DX + 4.0
          CALL PSTEXT(X,Y,10.0,'Beta strand')

C----     Coil
          X = XP + 161.0
          X1 = X
          SSLEN = 3
          X2 = X1 + SSLEN * DX
          Y1 = Y - SSSIZE * COIWID
          Y2 = Y + SSSIZE * COIWID
          CALL PSHADE(1.0,COLOUR,RGB,MXCOLR,INCOLR)
          CALL PSUBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          CALL PSLINE(X1,Y1,X2,Y1)
          CALL PSLINE(X1,Y2,X2,Y2)
          CALL PSLINE(X1,Y1,X1,Y2)
          CALL PSLINE(X2,Y1,X2,Y2)
          X = X + SSLEN * DX + 3.0
          CALL PSTEXT(X,Y,10.0,'Random coil')

C----     Accessibility shading
          IF (SHOWAC) THEN
              X = XP + 248.0
              Y1 = Y + 2.5
              Y2 = Y - 2.5
              IF (INCOLR) THEN
                  CALL PSTEXT(X,Y,8.0,'Accessibility shading:')
                  X1 = X + 80.0
                  X2 = X1 + 5.0
                  CALL PSHADE(0.0,MINACC,RGB,MXCOLR,INCOLR)
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                  X = X2 + 7.0
                  CALL PSTEXT(X,Y,8.0,'Buried')
                  X1 = X + 34.0
                  X2 = X1 + 5.0
                  CALL PSHADE(0.0,MAXACC,RGB,MXCOLR,INCOLR)
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                  X = X2 + 7.0
                  CALL PSTEXT(X,Y,8.0,'Accessible')
              ELSE
                  CALL PSTEXT(X,Y,8.0,'Accessibility shading: Black=' //
     -                'buried, White=accessible')
              ENDIF
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE CNPLOT  -  Plot the numbers of restraints per residue and
C                        a measure of the restraint violation
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE CNPLOT(XPORIG,XGAP,YP,NCONS,PINCON,THEPIN,NPIN,
     -    INCOLR,MXCOLR,RGB,PINSST,MXRCON,MXTORS,VVALUE,VINDEX,PINANC,
     -    HAVANG,ICTYPE,COLCON,COLVIO,STACHT,YMAX,MXCONS)

      SAVE

      INTEGER       MXCOLR, MXRCON, MXTORS, THEPIN, VINDEX(MXRCON)

      CHARACTER*1   PINSST(THEPIN), SECSTR
      CHARACTER*4   NUMBER
      INTEGER       COLCON, COLVIO, ICONS, ICTYPE, IPIN, IPOINT, IPOS,
     -              MXCONS, NCONS(2,THEPIN), NLOOPS, NPIN
      LOGICAL       HAVANG, INCOLR
      REAL          PINANC(MXTORS,THEPIN), PINCON(MXRCON,THEPIN),
     -              RGB(3,MXCOLR), SCALEY, STACHT, VVALUE(MXRCON), X,
     -              XGAP, XPORIG, X1, X2, Y, YMAX, YP, Y1, Y2

C---- Initialise values
      CALL PSLWID(0.05)

C---- Calculate scaling factor
      SCALEY = STACHT / MXCONS
      X = XPORIG
      YMAX = YP + STACHT

C---- Print the headings in the left
      X1 = XPORIG - 45.0
      Y1 = YP + 4.0
      IF (ICTYPE.EQ.1) THEN
          CALL PSTEXT(X1,Y1 + 12.0,6.0,'Upper-bound')
          CALL PSTEXT(X1,Y1 + 6.0,6.0,'distance')
          CALL PSTEXT(X1,Y1,6.0,'restraints')
          CALL PSTEXT(X1,Y1 - 6.0,6.0,'(same residue)')
      ELSE
          CALL PSTEXT(X1,Y1 + 6.0,6.0,'H-bond')
          CALL PSTEXT(X1,Y1,6.0,'upper-bound')
      ENDIF
      IF (HAVANG) THEN
          Y1 = YP - 21.0
          CALL PSTEXT(X1,Y1,6.0,'Dihedrals: Phi')
          Y1 = YP - 27.0
          X1 = XPORIG - 18.0
          CALL PSTEXT(X1,Y1,6.0,'Psi')
          Y1 = YP - 33.0
          X1 = XPORIG - 22.0
          CALL PSTEXT(X1,Y1,6.0,'Chi1')
          Y1 = YP - 39.0
          X1 = XPORIG - 22.0
          CALL PSTEXT(X1,Y1,6.0,'Chi2')
      ENDIF

C---- Lop through the residues to be processed
      DO 800, IPIN = 1, NPIN

C----     Process if not within a chain-break
          SECSTR = PINSST(IPIN)
          IF (SECSTR.NE.'=') THEN

C----         Distance restraints

C----         Initialise y-value
              Y = YP

C----         Sort the numbers of restraint violations into ascending
C             order
              NLOOPS = NCONS(1,IPIN)
              IF (NLOOPS.GT.MXRCON) NLOOPS = MXRCON
              IF (NLOOPS.GT.0) THEN
                  DO 100, ICONS = 1, NLOOPS
                      VINDEX(ICONS) = ICONS
                      VVALUE(ICONS) = PINCON(ICONS,IPIN)
 100              CONTINUE
                  CALL SHSORT(NLOOPS,VVALUE,NLOOPS,VINDEX)
              ENDIF

C----         Print the box around the outside
              IF (NCONS(1,IPIN).GT.0) THEN
                  X1 = X
                  X2 = X + XGAP
                  Y1 = Y
                  Y2 = Y + NCONS(1,IPIN) * SCALEY
                  CALL PSHADE(1.0,COLCON,RGB,MXCOLR,INCOLR)
                  CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
              ENDIF

C----         Loop through all the distance restraints for this residue
              DO 300, ICONS = 1, NCONS(1,IPIN)

C----             Initialise x-values
                  X1 = X
                  X2 = X + XGAP

C----             Calculate y-height of this restraint box
                  Y1 = Y
                  Y2 = Y + SCALEY

C----             Draw the restraint box (if not too many to be shown)
                  IF (MXCONS.LT.30) THEN
                      CALL PSHADE(1.0,COLCON,RGB,MXCOLR,INCOLR)
                      CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                  ENDIF

C----             Shade in part of box showing by how much the restraint
C                 is violated
                  IF (ICONS.LE.MXRCON) THEN
                      IPOINT = VINDEX(ICONS)
                      IF (PINCON(IPOINT,IPIN).GT.1.0)
     -                    PINCON(IPOINT,IPIN) = 1.0
                      IF (PINCON(IPOINT,IPIN).GT.0.0 .AND.
     -                    PINCON(IPOINT,IPIN).LE.1.0) THEN
                          X2 = X1 + PINCON(IPOINT,IPIN) * (X2 - X1)
     -                        / 1.0
                          CALL PSHADE(0.0,COLVIO,RGB,MXCOLR,INCOLR)
                          CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                      ENDIF
                  ENDIF

C----             Increment the y-value for the next restraint
                  Y = Y + SCALEY
 300          CONTINUE

C----         Print the number of restraints on top
              IF (NCONS(1,IPIN).GT.0) THEN
                  Y = Y + 10.0
                  YMAX = MAX(Y,YMAX)
                  WRITE(NUMBER,320) NCONS(1,IPIN)
 320              FORMAT(I4)
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  IF (NUMBER(3:3).EQ.' ') IPOS = 4
                  CALL PSCTXT(X + XGAP / 2.0,Y,6.0,NUMBER(IPOS:4))
                  Y = Y - 5.0
                  WRITE(NUMBER,320) NCONS(2,IPIN)
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  IF (NUMBER(3:3).EQ.' ') IPOS = 4
                  CALL PSCTXT(X + XGAP / 2.0,Y,5.0,'(' //
     -                NUMBER(IPOS:4) // ')')
              ENDIF

C----         Dihedral angle restraints
              IF (HAVANG) THEN

C----             Re-initialise y-value
                  Y = YP - 20.0

C----             Loop through all the dihedral angle restraints for
C                 this residue
                  DO 500, ICONS = 1, MXTORS

C----                 Initialise x-values
                      X1 = X
                      X2 = X + XGAP

C----                 Calculate y-height of this restraint box
                      Y1 = Y
                      Y2 = Y - (STACHT / 30.0)

C----                 If the restraint exists, draw the restraint box
                      IF (PINANC(ICONS,IPIN).GE.0.0) THEN
                          CALL PSHADE(1.0,COLCON,RGB,MXCOLR,INCOLR)
                          CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)

C----                     Shade in part of box showing by how much the
C                         restraint is violated
                          IF (PINANC(ICONS,IPIN).LE.1.0) THEN
                              X2 = X1 + PINANC(ICONS,IPIN)
     -                            * (X2 - X1) / 1.0
                              CALL PSHADE(0.0,COLVIO,RGB,MXCOLR,INCOLR)
                              CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
                          ENDIF
                      ENDIF

C----                 Increment the y-value for the next restraint
                      Y = Y - 6.0
 500              CONTINUE
              ENDIF
          ENDIF

C----     Increment x-value for next residue
          X = X + XGAP
 800  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE MODELC  -  Plot the model comparisons of NOE violations
C                        and G-factors
C 
C----------------------------------------------------------------------+--- 

      SUBROUTINE MODELC(PLTYPE,ACDIST,VIOLAT,SINDEX,NFILE,MAXCON)

      INCLUDE 'vplot.inc'

      INTEGER       NPPAGE
      PARAMETER    (NPPAGE = 4)

      CHARACTER*1   BRKCH, CHNEND, CIS(MXFILE), DAMINO(MXFILE), DTYPE,
     -              INCHN, LSTBRK, LSTCHN, NXTCHN, NXTCIS(MXFILE),
     -              NXTSST, OLDCHN, PINCIS(MXFILE,MXPINS),
     -              PINSST(MXPINS), RTYPE
      CHARACTER*2   PINCHN(MXPINS), TYPIN(MXRCON,MXPINS,NPPAGE)
      CHARACTER*3   PINRES(MXPINS), RESDUE
      CHARACTER*5   PINSNO(MXPINS)
      CHARACTER*9   HANDLE
      CHARACTER*30  PLDESC
      CHARACTER*60  PTITLE
      INTEGER       BGAP, CONTOP, FGAP, FEND, FPIN, FSTART, IATOM1,
     -              IATOM2, ICONS, ICONST, IFILE, IGAP, IGRAPH, IMODEL,
     -              IPOINT, IPOS, IRES, IRES1, IRES2, LINE, LINEA,
     -              LSTRES, MAXCON, NFILE, NGAP, NGAPY, NPAGE, NPAGES,
     -              NPIN, NPOINT(NPPAGE), NREST(2,MXPINS), NRESTS,
     -              ONPAGE, PINPOS(MXPINS), PLTYPE, SINDEX(2 * MAXCON),
     -              THEPIN, TLVIOL(NPPAGE), TRESTS, TUVIOL(NPPAGE)
      LOGICAL       BRKPOS(MXPINS), FIRST, LASTPG, PAGEND, PINOPE,
     -              WANTED
CHECK v.3.4.3-->
C      REAL          ACDIST(NFILE + 2,MAXCON), CALVAL, LOWER, LSTCHX,
      REAL          ACDIST(NFILE + 2,MAXCON), CALVAL, LOWER,
CHECK v.3.4.3<--
     -              LSTCHY, OMEGA, PINACC(MXPINS), PINBOT,
     -              PINCON(MXRCON,MXPINS), PINDAT(MXRCON,MXPINS,NPPAGE),
     -              PINSCO(MXFILE + 1,MXPINS), PINTOP, UPPER,
     -              VIOLAT(NFILE + 2,MAXCON), XCENTR

      DATA  BGAP, FGAP / 2, 10 /
      DATA  HANDLE / 'modelcomp' /
      DATA  PINBOT / 0.0 /
      DATA  PLDESC / 'Model-by-model violations' /
      DATA  PTITLE / 'Model-by-model violations' /

C---- Initialise variables
      DO 50, NPIN = 1, MXPINS
          NREST(1,NPIN) = 0
          NREST(2,NPIN) = 0
          NXTSST = '='
          BRKPOS(NPIN) = .FALSE.
          PINACC(NPIN) = 0.0
          DO 20, IGRAPH = 1, NPPAGE
              NPOINT(IGRAPH) = 0
              DO 10, IPOINT = 1, MXRCON
                  PINDAT(IPOINT,NPIN,IGRAPH) = 0.0
                  TYPIN(IPOINT,NPIN,IGRAPH) = ' '
 10           CONTINUE
 20       CONTINUE
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 30, ICONS = 1, MXRCON
              PINCON(ICONS,NPIN) = 0.0
 30       CONTINUE
          DO 40, IFILE = 1, MXFILE
              PINCIS(IFILE,NPIN) = ' '
              PINSCO(IFILE,NPIN) = 999.99
 40       CONTINUE
          PINPOS(NPIN) = 0
          PINSCO(MXFILE + 1,NPIN) = 999.99
          PINSNO(NPIN) = ' '
 50   CONTINUE
      BRKCH = ' '
      CHNEND = '>'
      CONTOP = 0
      PINOPE = .FALSE.
      FIRST = .TRUE.
      INCHN = ' '
      LINE = 0
      LINEA = 0
      LSTBRK = ' '
      LSTCHN = ' '
      LSTRES = 0
      NPAGE = 0
      NRESTS = 0
      OLDCHN = ' '
      THEPIN = MXPINS
      IF (NRES.LT.MXPINS .AND. NRES.GT.2) THEPIN = NRES
      THEPIN = MXPINS
      XCENTR = XPORIG + XPWID / 2.0

C---- Calculate maximum value for each plot 
      PINBOT = 0.0
      PINTOP = 0.0

C---- Loop through all the sorted restraints to find those applying to
C     each residue
      DO 200, ICONS = 1, 2 * TCONST

C----     Get pointer to the next restraint
          ICONST = ABS(SINDEX(ICONS))

C----     Determine whether this restraint is wanted
          CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,LOWER,UPPER,
     -        SINDEX(ICONS),IRES1,IRES2,IATOM1,IATOM2,RTYPE,DTYPE,
     -        WANTED)

C----     If restraint is within the same residue only take
C         first instance of it to avoid double-counting
          IF (IRES1.EQ.IRES2) THEN
              IF (IATOM1.LT.IATOM2) THEN
                  WANTED = .TRUE.
              ELSE
                  WANTED = .FALSE.
              ENDIF
          ELSE
              WANTED = .TRUE.
          ENDIF

C----     If the restraint is wanted, accumulate the graph limits
          IF (WANTED) THEN

C----         If this is not the same residue as before, then increment
C             totals
              IF (IRES1.NE.LSTRES) THEN

C----             If this is the highest value so far, update maximum
C                 value
                  CONTOP = MAX(NRESTS,CONTOP)

C----             Reset accumulator
                  NRESTS = 0
                  LSTRES = IRES1
              ENDIF

C----         Increment the count of upper-bound restraints for
C             this residue
              IF (RESTYP(ICONST).EQ.'U' .OR.
     -            RESTYP(ICONST).EQ.'B') THEN
                  NRESTS = NRESTS + 1
              ENDIF

C----         Loop through all the structures in the ensemble
              DO 100, IMODEL = 1, NMODEL

C----             If this is the highest value so far, update maximum
C                 value
                  PINBOT = MIN(VIOLAT(IMODEL,ICONST),PINBOT)
                  PINTOP = MAX(VIOLAT(IMODEL,ICONST),PINTOP)
 100          CONTINUE              
          ENDIF
 200  CONTINUE

C---- If this is the highest value so far, update maximum value
      CONTOP = 1.1 * MAX(NRESTS,CONTOP)

C---- Adjust maximum and minimum values, if necessary
      IF (PINTOP.EQ.0.0 .AND. PINBOT.EQ.0.0) THEN
          PINTOP = 0.8
      ENDIF
      PINTOP = 1.1 * PINTOP
      PINBOT = 1.1 * PINBOT
      CALL ADJLIM(PINBOT,PINTOP,NGAPY,.FALSE.)

C---- Loop through all the models in the ensemble
      DO 250, IMODEL = 1, NMODEL

C----     Initialise the cis-peptide markers
          NXTCIS(IMODEL) = ' '

C----     Loop through all the residues in the current model
CXXX          DO 100, IRES = 1, NRES

C----         Update figures for calculating overall residue-by-residue
C             averages and overall model-by-model averages
CXXX              SCOMOD(IRES,NMODEL + 1) = SCOMOD(IRES,NMODEL + 1)
CXXX     -            + SCOMOD(IRES,IMODEL)
CXXX              NUMSCO(IRES,NMODEL + 1) = NUMSCO(IRES,NMODEL + 1)
CXXX     -            + NUMSCO(IRES,IMODEL)
CXXX              SCOMOD(MXRES + 1,IMODEL) = SCOMOD(MXRES + 1,IMODEL)
CXXX     -            + SCOMOD(IRES,IMODEL)
CXXX              NUMSCO(MXRES + 1,IMODEL) = NUMSCO(MXRES + 1,IMODEL)
CXXX     -            + NUMSCO(IRES,IMODEL)
CXXX              SCOMOD(MXRES + 1,NMODEL + 1)
CXXX     -            = SCOMOD(MXRES + 1,NMODEL + 1)
CXXX     -            + SCOMOD(IRES,IMODEL)
CXXX              NUMSCO(MXRES + 1,NMODEL + 1)
CXXX     -            = NUMSCO(MXRES + 1,NMODEL + 1)
CXXX     -            + NUMSCO(IRES,IMODEL)
CXXX 100      CONTINUE
 250  CONTINUE

C---- Loop through all the data to calculate mean values
CXXX      DO 400, IMODEL = 1, NMODEL + 1

C----     Loop through all the residues
CXXX          DO 300, IRES = 1, MXRES + 1

C----         Calculate mean G-factor value for this residue in
C             this model
CXXX              IF (NUMSCO(IRES,IMODEL).GT.0) THEN
CXXX                  SCOMOD(IRES,IMODEL) = SCOMOD(IRES,IMODEL)
CXXX     -                / NUMSCO(IRES,IMODEL)
CXXX              ENDIF
CXXX 300      CONTINUE
CXXX 400  CONTINUE

C---- Sort all the models in order of overall model G-factor
CXXX      DO 450, IMODEL = 1, NMODEL
CXXX          SINDEX(IMODEL) = IMODEL
CXXX          STOSCO(IMODEL) = SCOMOD(MXRES + 1,IMODEL)

C----     Store this structure's overall G-factor
CXXX          SVALUE(5,IMODEL) = STOSCO(IMODEL)
CXXX 450  CONTINUE
CXXX      CALL SHSORT(NMODEL,STOSCO,NMODEL,SINDEX)

C---- Calculate how many pages will be required given the number of
C     models that can go on each page
      NPAGES = NMODEL / NPPAGE + 1
      IF ((NPAGES - 1) * NPPAGE.EQ.NMODEL) NPAGES = NPAGES - 1

C---- Loop through all the pages to be done
      DO 1200, ONPAGE = 1, NPAGES

C----     Initialise to the start of the sequence
          FPIN = 0
          NPIN = 0
          LASTPG = .FALSE.
          TRESTS = 0

C----     Calculate start- and end-file numbers
          FSTART = NPPAGE * (ONPAGE - 1) + 1
          FEND = FSTART + NPPAGE - 1
          IF (FEND.GT.NMODEL) FEND = NMODEL

C----     Initialise counts of violations
          DO 450, IGRAPH = 1, NPPAGE
              TLVIOL(IGRAPH) = 0
              TUVIOL(IGRAPH) = 0
 450      CONTINUE

C----     Loop through all the residues in the sequence to produce all
C         the pins plots
          DO 1000, IPOS = 1, NRES

C----         Get the pointer to the next residue
              IF (IPOS.EQ.1) THEN
                  IRES = FSTRES
              ELSE
                  IRES = NXTRES(IRES)
              ENDIF
              NPIN = NPIN + 1
              RESDUE = VALSNO(IRES)(7:9)
              PINPOS(NPIN) = IRES

C----         Initialise stores for current position
              DO 350, IGRAPH = 1, NPPAGE
                  NPOINT(IGRAPH) = 0
                  DO 300, IPOINT = 1, MXRCON
                      PINDAT(IPOINT,NPIN,IGRAPH) = 0.0
                      TYPIN(IPOINT,NPIN,IGRAPH) = ' '
 300              CONTINUE
 350          CONTINUE

C----         Calculate the number of upper-bound NOE restraints for
C             this residue
              DO 500, ICONS = 1, 2 * TCONST

C----             Get pointer to the next restraint
                  ICONST = ABS(SINDEX(ICONS))

C----             Determine whether this restraint is wanted
                  CALL RSWANT(ACDIST,VIOLAT,NFILE,MAXCON,ICONST,
     -                LOWER,UPPER,SINDEX(ICONS),IRES1,IRES2,IATOM1,
     -                IATOM2,RTYPE,DTYPE,WANTED)

C----             See if it belongs to the current residue of interest
                  IF (IRES1.EQ.IRES) THEN
                      WANTED = .TRUE.
                  ELSE
                      WANTED = .FALSE.
                  ENDIF

C----             If the restraint is wanted, accumulate the data
                  IF (WANTED) THEN

C----                 Increment the count of upper-bound restraints for
C                     this residue
                      IF (RESTYP(ICONST).EQ.'U' .OR.
     -                    RESTYP(ICONST).EQ.'B') THEN
                          IF (IRES1.EQ.IRES2) THEN
                              IF (IATOM1.LT.IATOM2) THEN
                                  NREST(1,NPIN) = NREST(1,NPIN) + 1
                              ELSE
                                  NREST(2,NPIN) = NREST(2,NPIN) + 1
                              ENDIF
                          ELSE
                              NREST(1,NPIN) = NREST(1,NPIN) + 1
                          ENDIF
                          TRESTS = TRESTS + 1
                      ENDIF
                  ENDIF

C----             If restraint is within the current residue only take
C                 first instance of it
                  IF (WANTED) THEN
                      IF (IRES1.EQ.IRES2) THEN
                          IF (IATOM1.LT.IATOM2) THEN
                              WANTED = .TRUE.
                          ELSE
                              WANTED = .FALSE.
                          ENDIF
                      ELSE
                          WANTED = .TRUE.
                      ENDIF
                  ENDIF

C----             If the restraint is wanted, accumulate the data
                  IF (WANTED) THEN

C----                 If this is a violation, then add to current set
                      IGRAPH = 0
                      DO 460, IMODEL = FSTART, FEND
                          IGRAPH = IGRAPH + 1
                          IF (VIOLAT(IMODEL,ICONST).NE.0.0) THEN
                              NPOINT(IGRAPH) = NPOINT(IGRAPH) + 1
                              IF (NPOINT(IGRAPH).LE.MXRCON) THEN
                                  PINDAT(NPOINT(IGRAPH),NPIN,IGRAPH)
     -                                = VIOLAT(IMODEL,ICONST)
                                  TYPIN(NPOINT(IGRAPH),NPIN,IGRAPH)
     -                                = DTYPE // RTYPE

C----                             Increment total counts of violations
C                                 for this model
                                  IF (VIOLAT(IMODEL,ICONST).GT.0.0) THEN
                                      TUVIOL(IGRAPH)
     -                                    = TUVIOL(IGRAPH) + 1
                                      IF (IRES1.EQ.IRES2) THEN
                                          TUVIOL(IGRAPH)
     -                                        = TUVIOL(IGRAPH) + 1
                                      ENDIF
                                  ELSE
                                      TLVIOL(IGRAPH)
     -                                    = TLVIOL(IGRAPH) + 1
                                      IF (IRES1.EQ.IRES2) THEN
                                          TLVIOL(IGRAPH)
     -                                        = TLVIOL(IGRAPH) + 1
                                      ENDIF
                                  ENDIF
                              ENDIF
                          ENDIF
 460                  CONTINUE

C----                 Loop through all structures in the ensemble for this
C                     residue
                      DO 480, IMODEL = 1, NMODEL

C----                     Count number of upper-bound violations of this
C                         restraint
                          IF (VIOLAT(IMODEL,ICONST).GT.0.0) THEN
                              IF (NREST(1,NPIN).LE.MXRCON) THEN
                                  PINCON(NREST(1,NPIN),NPIN)
     -                                = PINCON(NREST(1,NPIN),NPIN)
     -                                + 1.0 / REAL(NMODEL)
                              ENDIF
                          ENDIF
 480                  CONTINUE
                  ENDIF
 500          CONTINUE

C----         Check whether we have a cis-peptide or D-amino acid in any of
C             the models
              DO 600, IMODEL = FSTART, FEND

C----             Initialise cis-peptide and D-amino acid markers
                  CIS(IMODEL) = NXTCIS(IMODEL)
                  NXTCIS(IMODEL) = ' '
                  DAMINO(IMODEL) = ' '

C----             Check for cis peptide (ie abs(omega) < 45) 
                  OMEGA = VALUE(LOCOME,IRES,IMODEL)
                  IF (ABS(OMEGA).LT.900.0 .AND. (OMEGA.LT.45.0 .OR.
     -                OMEGA.GT.315.0)) THEN
                      NXTCIS(IMODEL) = 'c'
                  ENDIF

C----             Alpha carbon chirality
                  CALVAL = VALUE(LOCZET,IRES,IMODEL)
                  IF (CALVAL.LT.900.0) THEN
                      IF (CALVAL.LT.0) DAMINO(IMODEL) = 'D'
                  ENDIF

C----             Transfer into plot array
                  IF (CIS(IMODEL).EQ.'c' .AND.
     -                DAMINO(IMODEL).EQ.'D') THEN
                      PINCIS(IMODEL,NPIN) = 'X'
                  ELSE IF (CIS(IMODEL).EQ.'c') THEN
                      PINCIS(IMODEL,NPIN) = CIS(IMODEL)
                  ELSE IF (DAMINO(IMODEL).EQ.'D') THEN
                      PINCIS(IMODEL,NPIN) = DAMINO(IMODEL)
                  ENDIF
 600          CONTINUE

C----         Transfer the plot details for this residue into the plot
C             arrays
              PINACC(NPIN) = VALOOI(IRES)
              PINRES(NPIN) = RESDUE

C----         Store all the G-factor scores for this residue
CXXX              DO 700, IMODEL = FSTART, FEND
CXXX                  IF (NUMSCO(IRES,IMODEL).GT.0) THEN
CXXX                      PINSCO(IMODEL,NPIN) = SCOMOD(IRES,IMODEL)
CXXX                  ELSE
CXXX                      PINSCO(IMODEL,NPIN) = 999.9
CXXX                  ENDIF
CXXX 700          CONTINUE

C----         Get secondary structure and any chain breaks
              PINSNO(NPIN) = VALSNO(IRES)(2:6)
              PINSST(NPIN) = CONSST(IRES)
              IF (NPIN.EQ.NRES) THEN
                  NXTSST = '='
              ELSE
                  NXTSST = CONSST(IRES + 1)
              ENDIF
              OLDCHN = INCHN
              INCHN = VALSNO(IRES)(1:1)
              CHNEND = ' '
              IF (IPOS.EQ.1) THEN
                  CHNEND = '>'
                  OLDCHN = INCHN
              ENDIF
              IF (IPOS.EQ.NRES) CHNEND = '<'
              PINCHN(NPIN) = INCHN // CHNEND
              NXTCHN = INCHN
              BRKCH = CHNBRK(IRES)

C----         Determine whether at a chain-end or chain-start
              IF (NPIN.GT.0) THEN
                  IF (OLDCHN.NE.NXTCHN) THEN
                      CHNEND = '<'
                      PINCHN(NPIN)(2:2) = CHNEND
                  ELSE IF (OLDCHN.NE.LSTCHN) THEN
                      CHNEND = '>'
                      PINCHN(NPIN)(2:2) = CHNEND
                  ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.'!') THEN
                      CHNEND = '<'
                      PINCHN(NPIN)(2:2) = CHNEND
                      CHNEND = '!'
                  ELSE IF (LSTBRK.EQ.'!' .AND. BRKCH.EQ.' ') THEN
                      CHNEND = '>'
                      PINCHN(NPIN)(2:2) = CHNEND
                  ELSE IF (BRKCH.EQ.'x') THEN
                      CHNEND = '<'
                      PINCHN(NPIN)(2:2) = CHNEND
                      CHNEND = '!'
                  ENDIF
                  LSTBRK = BRKCH
                  LSTCHN = OLDCHN
              ENDIF

C----         If have a pageful of data, then produce the pinplot
              IF (NPIN.EQ.THEPIN) THEN
                  IF (PLOTMD) THEN

C----                 If current PostScript file is open, close it
                      IF (PINOPE) THEN
                          CALL PSENDP
                          IF (.NOT.COMBPS) THEN
                              CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                          ENDIF
                      ENDIF

C----                 Open new PostScript file
                      CALL PGOPEN(FIRST,NPAGE,PLTYPE,
     -                    PTITLE,PLDESC,HANDLE,XCENTR)

C----                 Produce current page
                      IF (IPOS.GE.NRES) LASTPG = .TRUE.
                      CALL MODPLT(THEPIN,NPIN,FPIN,PINRES,PINSST,
     -                    PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,
CHECK v.3.4.3-->
C     -                    LSTCHX,LSTCHY,PLTYPE,FSTART,FEND,FIRST,NFILE,
C     -                    MAXCON,NREST,CONTOP,PINCON,PINDAT,PINPOS,
     -                    LSTCHY,PLTYPE,FSTART,FEND,
     -                    NREST,CONTOP,PINCON,PINDAT,PINPOS,
CHECK v.3.4.3<--
     -                    TYPIN,LASTPG,NXTSST,PINTOP,PINBOT,NGAPY,
     -                    NPPAGE,TLVIOL,TUVIOL,TRESTS)
                      FIRST = .FALSE.
                      PINOPE = .TRUE.
                  ENDIF
                  FPIN = FPIN + THEPIN
                  NPIN = 0
                  CHNEND = ' '
              ENDIF

C----         Check whether this residue is the end of a chain
              IF (CHNEND.EQ.'<' .OR. CHNEND.EQ.'!') THEN

C----             Leave the appropriate number of blanks between the chains
                  PAGEND = .FALSE.
                  IF (CHNEND.EQ.'<') THEN
                      NGAP = FGAP
                  ELSE
                      NGAP = BGAP
                  ENDIF
                  DO 800, IGAP = 1, NGAP

C----                 Add blanks providing that haven't reached end of
C                     page
                      IF (.NOT.PAGEND .AND. IPOS.NE.NRES) THEN
                          NPIN = NPIN + 1
                          BRKPOS(NPIN) = .TRUE.

C----                     If have a pageful of data, then produce the
C                         pinplot
                          IF (NPIN.EQ.THEPIN) THEN
                              IF (PLOTMD) THEN

C----                             If current PostScript file is open,
C                                 close it
                                  IF (PINOPE) THEN
                                      CALL PSENDP
                                      IF (.NOT.COMBPS) THEN
                                          CALL PSCLOS(BBOXX1,BBOXX2,
     -                                        BBOXY1,BBOXY2)
                                      ENDIF
                                  ENDIF

C----                             Open new PostScript file
                                  CALL PGOPEN(FIRST,NPAGE,PLTYPE,
     -                                PTITLE,PLDESC,HANDLE,XCENTR)

C----                             Produce current page
                                  IF (IPOS.GE.NRES) LASTPG = .TRUE.
                                  CALL MODPLT(THEPIN,NPIN,FPIN,PINRES,
     -                                PINSST,PINCHN,PINSNO,BRKPOS,
CHECK v.3.4.3-->
C     -                                PINACC,PINSCO,PINCIS,LSTCHX,
C     -                                LSTCHY,PLTYPE,FSTART,FEND,FIRST,
C     -                                NFILE,MAXCON,NREST,CONTOP,PINCON,
     -                                PINACC,PINSCO,PINCIS,
     -                                LSTCHY,PLTYPE,FSTART,FEND,
     -                                NREST,CONTOP,PINCON,
CHECK v.3.4.3<--
     -                                PINDAT,PINPOS,TYPIN,LASTPG,NXTSST,
     -                                PINTOP,PINBOT,NGAPY,NPPAGE,TLVIOL,
     -                                TUVIOL,TRESTS)
                                  FIRST = .FALSE.
                                  PINOPE = .TRUE.
                              ENDIF
                              FPIN = FPIN + THEPIN
                              NPIN = 0
                              CHNEND = ' '
                              PAGEND = .TRUE.
                          ENDIF
                      ENDIF
 800              CONTINUE
              ENDIF
 1000     CONTINUE

C----     If any more data left to be printed, then produce the pinplot
          IF (PLOTMD .AND. NPIN.GT.0) THEN

C----          If current PostScript file is open, close it
               IF (PINOPE) THEN
                   CALL PSENDP
                   IF (.NOT.COMBPS) THEN
                       CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
                   ENDIF
               ENDIF

C----          Open new PostScript file
               CALL PGOPEN(FIRST,NPAGE,PLTYPE,PTITLE,PLDESC,
     -             HANDLE,XCENTR)

C----         Produce current page
              LASTPG = .TRUE.
              CALL MODPLT(THEPIN,NPIN,FPIN,PINRES,
     -            PINSST,PINCHN,PINSNO,BRKPOS,PINACC,PINSCO,PINCIS,
CHECK v.3.4.3-->
C     -            LSTCHX,LSTCHY,PLTYPE,FSTART,FEND,FIRST,NFILE,MAXCON,
C     -            NREST,CONTOP,PINCON,PINDAT,PINPOS,TYPIN,LASTPG,NXTSST,
     -            LSTCHY,PLTYPE,FSTART,FEND,NREST,
     -            CONTOP,PINCON,PINDAT,PINPOS,TYPIN,LASTPG,NXTSST,
CHECK v.3.4.3<--
     -            PINTOP,PINBOT,NGAPY,NPPAGE,TLVIOL,TUVIOL,TRESTS)
              FIRST = .FALSE.
              PINOPE = .TRUE.
          ENDIF
 1200 CONTINUE

C---- Close the current PostScript file
      IF (PINOPE) THEN
          CALL PSENDP
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE MODPLT  -  Print current page for model-by-model G-factors
C                        plot
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE MODPLT(THEPIN,NPIN,FPIN,PINRES,PINSST,PINCHN,PINSNO,
CHECK v.3.4.3-->
C     -    BRKPOS,PINACC,PINSCO,PINCIS,LSTCHX,LSTCHY,PLTYPE,FSTART,FEND,
C     -    FIRST,NFILE,MAXCON,NREST,CONTOP,PINCON,PINDAT,PINPOS,TYPIN,
     -    BRKPOS,PINACC,PINSCO,PINCIS,LSTCHY,PLTYPE,FSTART,FEND,
     -    NREST,CONTOP,PINCON,PINDAT,PINPOS,TYPIN,
CHECK v.3.4.3<--
     -    LASTPG,NXTSST,PINTOP,PINBOT,NGAPY,NPPAGE,TLVIOL,TUVIOL,TRESTS)

      SAVE

      INCLUDE 'vplot.inc'

      REAL          DASCOY, MKSIZE, SECSTY, SEQRMY, STACHT, YMORIG,
     -              YMSEP, YMWID, YTOP
      PARAMETER    (
     -              DASCOY = 150.0,
     -              MKSIZE =    5.0,
     -              SECSTY =   0.0,
     -              SEQRMY =  61.0,
     -              STACHT =  46.0,
     -              YMORIG = 120.0,
     -              YMSEP  =  35.0,
     -              YMWID  =  75.0,
     -              YTOP   = 680.0
     -             )

      REAL          LSIZE, SIZLAB, TSIZE
      PARAMETER    (
     -              LSIZE  =  15.0,
     -              SIZLAB =  10.0,
     -              TSIZE  =   6.0
     -             )

      INTEGER       NPPAGE, THEPIN

      CHARACTER*1   A, DTYPE(MXRCON), NXTSST, PINCIS(MXFILE,THEPIN),
     -              PINSST(THEPIN), RCHAR, RTYPE(MXRCON)
      CHARACTER*2   PINCHN(THEPIN), TYPIN(MXRCON,MXPINS,NPPAGE)
      CHARACTER*3   CODE(20), PINRES(THEPIN)
      CHARACTER*5   PINSNO(THEPIN), TICLAB(MXPINS)
      CHARACTER*6   NUMBER
      CHARACTER*9   CLABEL
      CHARACTER*20  AMINO1
CHECK v.3.4.3-->
C      CHARACTER*26  LOWER, PLTYHD
C      CHARACTER*60  PLTHED
      CHARACTER*26  LOWER
      CHARACTER*60  PLTHED, PLTYHD
CHECK v.3.4.3<--
      INTEGER       CONTOP, FPIN, FSTART, FEND, ICODE, ICONS, IFILE,
     -              IGRAPH, IPIN, IPOINT, IPOS, IRGRAF, LABNUM(MXRCON),
CHECK v.3.4.3-->
C     -              MAXCON, N, NREST(2,MXPINS), NFILE, NGAPY, NLVIOL,
     -              N, NREST(2,MXPINS), NGAPY, NLVIOL,
CHECK v.3.4.3<--
     -              NOFFDN, NOFFUP, NPIN, NPOINT, NUVIOL,
     -              PINPOS(MXPINS), PLTHLN, PLTYLN, PLTYPE,
     -              TICLEN(MXPINS), TLVIOL(NPPAGE), TRESTS,
     -              TUVIOL(NPPAGE), VINDEX(MXRCON)
CHECK v.3.4.3-->
C      LOGICAL       BRKPOS(MXPINS), FIRST, LASTPG, TICPOS(MXPINS)
      LOGICAL       BRKPOS(MXPINS), LASTPG, TICPOS(MXPINS)
CHECK v.3.4.3<--
CHECK v.3.4.3-->
C      REAL          LSTCHX, LSTCHY, PINACC(THEPIN),
      REAL          LSTCHY, PINACC(THEPIN),
CHECK v.3.4.3<--
     -              PINANC(MXTORS,MXPINS), PINBOT,
     -              PINCON(MXRCON,MXPINS), PINDAT(MXRCON,MXPINS,NPPAGE),
     -              PINSCO(MXFILE + 1,THEPIN), PINTOP, SCALEX, SCALEY,
     -              VVALUE(MXRCON), X, XCENTR, Y, YBOT, YMAX,
     -              YP, Y1

      DATA  A      / 'A' /
      DATA  AMINO1 / 'ACDEFGHIKLMNPQRSTVWY'/

      DATA  CODE   / 'ALA','CYS','ASP','GLU','PHE','GLY','HIS',
     -               'ILE','LYS','LEU','MET','ASN','PRO','GLN','ARG',
     -               'SER','THR','VAL','TRP','TYR' /
      DATA  LOWER  / 'abcdefghijklmnopqrstuvwxyz' /
      DATA  PLTHED / 'Restraint violations' /
      DATA  PLTHLN / 20 /
      DATA  PLTYHD / 'Violation (A)' /
      DATA  PLTYLN / 13 /

C---- Initialise variables
      IRGRAF = 0
      XCENTR = XPORIG + XPWID / 2.0
      YP = YTOP
      SCALEX = XPWID / THEPIN
      CALL PSLWID(0.1)

C---- Print the "wiring diagram" showing the secondary structure, with
C     background shading giving a measure of the accessibility
      IRGRAF = IRGRAF + 1
      Y = YTOP - SECSTY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Secondary structure & average estimated accessibility')
      Y = Y - 18.0
      CALL PSLWID(0.0)
      IF (SHOWAC) THEN
          CALL ACCSHD(THEPIN,NPIN,PINACC,PINSST,XPORIG,Y,SCALEX,
     -        SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(4,PLTYPE),
     -        COLPLT(3,PLTYPE))
      ENDIF
      CALL SSPLOT(THEPIN,NPIN,PINSST,XPORIG,Y,SCALEX,NRES,PINCHN,
     -    SHOWAC,SSSIZE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(7,PLTYPE),
     -    COLPLT(3,PLTYPE),COLPLT(4,PLTYPE),.TRUE.,NXTSST)

C---- Print the residue codes
      IRGRAF = IRGRAF + 1
      Y = YTOP - SEQRMY
      CALL PSTEXT(XPORIG,Y,12.0,LOWER(IRGRAF:IRGRAF) //
     -    '. Sequence & numbers of NOE restraints per residue')
      CALL PSLWID(0.0)
      Y = Y - STACHT - 20.0

C---- Numbers of upper-bound restraints
      CALL CNPLOT(XPORIG,SCALEX,Y,NREST,PINCON,MXPINS,
     -    NPIN,INCOLR(PLTYPE),MXCOLR,RGB,PINSST,MXRCON,MXTORS,VVALUE,
     -    VINDEX,PINANC,.FALSE.,1,COLPLT(9,PLTYPE),
     -    COLPLT(10,PLTYPE),STACHT,YMAX,CONTOP)
      Y = Y - 6.0

C---- Loop through the residues and print single-letter or three-letter
C     residue codes
      DO 400, IPIN = 1, NPIN
          X = XPORIG + (IPIN - 0.5) * SCALEX

C----     Find single-letter code for this residue
          ICODE = 0
          DO 300, N = 1, 20
              IF (PINRES(IPIN).EQ.CODE(N)) THEN
                  ICODE = N
                  GO TO 350
              ENDIF
 300      CONTINUE

C----     If not one of the standard 20, then print full 3-letter code
 350      CONTINUE
          IF (ICODE.EQ.0) THEN
              CALL PSCTXT(X,Y,8.0,PINRES(IPIN)(1:1))
              RCHAR = PINRES(IPIN)(2:2)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 6.0,8.0,RCHAR)
              RCHAR = PINRES(IPIN)(3:3)
              N = ICHAR(RCHAR) - ICHAR(A) + 1
              IF (N.GE.1 .AND. N.LE.26) RCHAR = LOWER(N:N)
              CALL PSCTXT(X,Y - 12.0,8.0,RCHAR)

C----     Otherwise, print the single-letter code
          ELSE
              RCHAR = AMINO1(ICODE:ICODE)
              CALL PSCTXT(X,Y,8.0,RCHAR)
          ENDIF
 400  CONTINUE

C---- If this is the last page, print the total numbers of restraints
      IF (LASTPG) THEN
          X = X + 20.0
          CALL PSCTXT(X,Y + 12.0,TSIZE,'Total')
          WRITE(NUMBER,280) TRESTS / 2
 280      FORMAT(I6)
          IPOS = 1
          IF (NUMBER(1:1).EQ.' ') IPOS = 2
          IF (NUMBER(2:2).EQ.' ') IPOS = 3
          IF (NUMBER(3:3).EQ.' ') IPOS = 4
          IF (NUMBER(4:4).EQ.' ') IPOS = 5
          CALL PSCTXT(X,Y + 6.0,TSIZE,NUMBER(IPOS:6))
      ENDIF

C---- Show the heading
      IRGRAF = IRGRAF + 1
      Y = YTOP - DASCOY
      LSTCHY = Y
      IGRAPH = 0

C---- Loop through all the models on this page
      DO 1000, IFILE = FSTART, FEND

C----     Get graph number ans starting coordinates
          IGRAPH = IGRAPH + 1
          YP = YMORIG + (NPPAGE - IGRAPH) * (YMWID + YMSEP)

C----     Print the model number
          WRITE(CLABEL,410) ACTNUM(IFILE)
 410      FORMAT('Model',I3,'.')
          CALL PSTEXT(XPORIG,YP + YMWID + 8.0,12.0,CLABEL)

C----     Plot the graphs showing the upper-bound NOE restraint
C         violations for this model
          SCALEY = YMWID / (PINTOP - PINBOT)
          CALL PINGBX(XPORIG,YP,XPWID,YMWID,BSHADE(PLTYPE),PINBOT,
     -        PINTOP,FPIN,FPIN + THEPIN,PLTHED,PLTHLN,PLTYHD,PLTYLN,
     -        PLTYHD,PLTYLN,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(2,PLTYPE),
     -        COLPLT(2,PLTYPE),NGAPY,SCALEY,1)

C----     Draw x-axis as dotted line
          IF (PINBOT.LT.0.0) THEN
              Y = YP - SCALEY * PINBOT
              CALL PSDASH(2)
              CALL PSLINE(XPORIG,Y,XPORIG + XPWID,Y)
              CALL PSDASH(0)
          ENDIF

C----     Loop through all the data points
          DO 600, IPIN = 1, NPIN

C----         Calculate starting coordinates
              X = XPORIG + (REAL(IPIN) - 0.5) * SCALEX

C----         Count how many values there are for this position
              NPOINT = 0
              NLVIOL = 0
              NUVIOL = 0
              DO 500, IPOINT = 1, MXRCON
                  IF (PINDAT(IPOINT,IPIN,IGRAPH).NE.0.0) THEN
                      NPOINT = IPOINT
                      LABNUM(IPOINT) = ACTNUM(IFILE)
                      DTYPE(IPOINT) = TYPIN(IPOINT,IPIN,IGRAPH)(1:1)
                      RTYPE(IPOINT) = TYPIN(IPOINT,IPIN,IGRAPH)(2:2)
                      IF (PINDAT(IPOINT,IPIN,IGRAPH).GT.0.0) THEN
                          NUVIOL = NUVIOL + 1
                      ELSE
                          NLVIOL = NLVIOL + 1
                      ENDIF
                  ENDIF
 500          CONTINUE

C----         Print all the data points for this restraint
CHECK v.3.5.4-->
              IF (NPOINT.GT.1) THEN
CHECK v.3.5.4<--
                  CALL PLTPTS(PINDAT(1,IPIN,IGRAPH),NPOINT,X,YP,PINBOT,
     -                PINTOP,MKSIZE,DTYPE,RTYPE,SCALEY,PLTYPE,.FALSE.,
     -                LABNUM,TOPMOD,NOFFDN,NOFFUP)
CHECK v.3.5.4-->
              ENDIF
CHECK v.3.5.4<--

C----         Print numbers of upper- and lower-bound violations

C----         Print the number of upper-bound violations
              IF (NUVIOL.GT.0) THEN
                  WRITE(NUMBER,580) NUVIOL
 580              FORMAT(I3)
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  CALL PSCTXT(X,YP + YMWID - 5.0,TSIZE,NUMBER(IPOS:3))
              ENDIF

C----         Print the number of lower-bound violations
              IF (NLVIOL.GT.0) THEN
                  WRITE(NUMBER,580) NLVIOL
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  CALL PSCTXT(X,YP + 5.0,TSIZE,NUMBER(IPOS:3))
              ENDIF
 600      CONTINUE
          YBOT = YP

C----     If this is the last page for this graph, print the violation
C         totals
          IF (LASTPG) THEN
              X = XPORIG + XPWID + 10.0
              CALL PSCTXT(X,YP + YPWID + 5.0,TSIZE,'Viol.')

C----         Print the number of upper-bound violations
              IF (TUVIOL(IGRAPH).GT.0) THEN
                  WRITE(NUMBER,580) TUVIOL(IGRAPH) / 2
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  CALL PSCTXT(X,YP + YMWID - 5.0,TSIZE,NUMBER(IPOS:3))
              ENDIF

C----         Print the number of lower-bound violations
              IF (TLVIOL(IGRAPH).GT.0) THEN
                  WRITE(NUMBER,580) TLVIOL(IGRAPH) / 2
                  IPOS = 1
                  IF (NUMBER(1:1).EQ.' ') IPOS = 2
                  IF (NUMBER(2:2).EQ.' ') IPOS = 3
                  CALL PSCTXT(X,YP + 5.0,TSIZE,NUMBER(IPOS:3))
              ENDIF
          ENDIF

C----     Print the G-factors
CXXX          Y1 = Y1 - YCHQHT / 2.0
CXXX          LSTCHY = Y1
CXXX          CALL MODCHQ(XPORIG,SCALEX,Y1,YCHQHT,PINSCO,THEPIN,NPIN,
CXXX     -        NFILE,INCOLR(PLTYPE),MXCOLR,RGB,COLPLT(5,PLTYPE),
CXXX     -        COLPLT(6,PLTYPE),YBOT,PINSST,MXFILE,LSTCHX,IFILE)

C----     If this is the last part of the sequence, plot the overall
C         G-factor for this model
CXXX          IF (LASTPG) THEN
CXXX              CALL MODGFS(XPORIG + XPWID,XGAP,LSTCHY,YCHQHT,SCOMOD,
CXXX     -            MXRES,MXFILE,NFILE,INCOLR(PLTYPE),MXCOLR,RGB,
CXXX     -            COLPLT(5,PLTYPE),COLPLT(6,PLTYPE),IFILE)
CXXX          ENDIF

C----     Print the residue numbers
          CALL PINRNO(XPORIG,XPORIG + XPWID,YBOT,PINSNO,
     -        MXPINS,NPIN,FPIN,TICPOS,TICLAB,TICLEN,SIZLAB,LSIZE)

C----     Add ticks at appropriate positions below overall G-factors line
          CALL PINTIC(XPORIG,YBOT,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -        BRKPOS,.FALSE.)

C----     Print the tick labels
          X = XPORIG + XGAP / 2.0
          Y1 = YBOT - LSIZE / 2.0
          DO 700, IPIN = 1, NPIN
              IF (TICPOS(IPIN)) THEN
                  CALL PSCTXT(X,Y1,SIZLAB,TICLAB(IPIN)(1:TICLEN(IPIN)))
              ENDIF
              X = X + XGAP
 700      CONTINUE
 1000 CONTINUE

C---- Print explanatory notes
      X = XPORIG
      Y = YBOT - 20.0
      IF (PINBOT.NE.0.0) THEN
          CALL PSTEXT(X,Y,8.0,'Positive values correspond to upp' //
     -        'er-bound violations (numbers shown at top)')
          Y = Y - 8.0
          CALL PSTEXT(X,Y,8.0,'Negative values correspond to low' //
     -        'er-bound violations (numbers shown at bottom)')
      ELSE
          CALL PSTEXT(X,Y,8.0,'Numbers at top of graph show numb' //
     -        'ers of upper-bound violations for each residue')
          Y = Y - 8.0
      ENDIF

C---- Print key to symbols
      Y = Y - 8.0
      CALL SYMKEY(X,Y,MKSIZE,PLTYPE,.FALSE.,.TRUE.)

C---- If any restraint types have been excluded, then show this on the plot
      X = XPORIG + XPWID - 118.0
      Y = YBOT - 12.0
      CALL PLEXCL(X,Y)

C---- Add ticks at appropriate positions for sequence
      Y = YTOP - SEQRMY - STACHT - 20.0
      CALL PINTIC(XPORIG,Y,0.0,XPWID,MXPINS,NPIN,-2.0,TICPOS,
     -    BRKPOS,.FALSE.)

C---- Re-initalise arrays
      DO 850, NPIN = 1, MXPINS
          NREST(1,NPIN) = 0
          NREST(2,NPIN) = 0
          NXTSST = '='
          BRKPOS(NPIN) = .FALSE.
          PINACC(NPIN) = 0.0
          DO 820, IGRAPH = 1, NPPAGE
              DO 810, IPOINT = 1, MXRCON
                  PINDAT(IPOINT,NPIN,IGRAPH) = 0.0
                  TYPIN(IPOINT,NPIN,IGRAPH) = ' '
 810          CONTINUE
 820      CONTINUE
          PINPOS(NPIN) = 0
          PINRES(NPIN) = ' '
          PINSST(NPIN) = '='
          PINCHN(NPIN) = ' '
          DO 830, ICONS = 1, MXRCON
              PINCON(ICONS,NPIN) = 0.0
 830      CONTINUE
          DO 840, IFILE = 1, MXFILE
              PINCIS(IFILE,NPIN) = ' '
              PINSCO(IFILE,NPIN) = 999.99
 840      CONTINUE
          PINSCO(MXFILE + 1,NPIN) = 999.99
          PINSNO(NPIN) = ' '
 850  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE SYMKEY  -   Plot the explanatory key for the symbols
C
C----------------------------------------------------------------------+--- 

      SUBROUTINE SYMKEY(XLEFT,Y,MKSIZE,PLTYPE,SIDEBY,SHOWRN)

      INCLUDE 'vplot.inc'

      CHARACTER*1   LSM
      CHARACTER*110 TEXT
      INTEGER       ICOLR, LENSTR, PLTYPE
      LOGICAL       SHOWRN, SIDEBY
      REAL          MKSIZE, SHADE, TSIZE, X, XLEFT, X1, X2, X3, Y, YMID,
     -              YTEXT, Y1, Y2

C---- Initialise variables
      TSIZE = 6.0
      X = XLEFT
      YTEXT = Y - 1.0
      CALL PSTEXT(X,YTEXT,8.0,'Shape of symbol gives restraint type:')
      X = X + 123.0

C---- Get most likely colour to use
      LSM = 'S'
      ICOLR = COLPNT(3)
      IF (.NOT.INCLUS) THEN
          LSM = 'M'
          ICOLR = COLPNT(2)
          IF (.NOT.INCLUM) THEN
              LSM = 'L'
              ICOLR = COLPNT(1)
          ENDIF
      ENDIF

C---- Plot box for NOEs
      IF (TYPENO) THEN
          X1 = X - MKSIZE / 2.0
          X2 = X + MKSIZE / 2.0
          Y1 = Y - MKSIZE / 2.0
          Y2 = Y + MKSIZE / 2.0
          SHADE = 1.0
          CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)
          CALL PSCTXT(X,Y,TSIZE,LSM)
          X = X + 8.0
          CALL PSTEXT(X,YTEXT,8.0,'NOE')
          X = X + 24.0
      ENDIF

C---- Plot circle for H-bonds
      IF (TYPEHB) THEN
          CALL PSLWID(0.05)
          IF (INCOLR(PLTYPE)) THEN
              CALL PSCCOL(RGB(1,ICOLR),RGB(2,ICOLR),RGB(3,ICOLR))
          ELSE
              CALL PSCSHD(1.0)
          ENDIF
          CALL PSCIRC(X,Y,0.6 * MKSIZE)
          CALL PSLWID(0.2)
          CALL PSCTXT(X,Y,TSIZE,LSM)
          X = X + 8.0
          CALL PSTEXT(X,YTEXT,8.0,'H-bond')
          X = X + 30.0
      ENDIF

C---- Plot diamond for disulphides
      IF (TYPESS) THEN
          CALL PSLWID(0.1)
          SHADE = 1.0
          X1 = X - 0.7 * MKSIZE
          X2 = X + 0.7 * MKSIZE
          X3 = (X1 + X2) / 2.0
          Y1 = Y - 0.7 * MKSIZE
          Y2 = Y + 0.7 * MKSIZE
          YMID = (Y1 + Y2) / 2.0
          CALL PSHADE(SHADE,ICOLR,RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSBBOX(X1,YMID,X3,Y2,X2,YMID,X3,Y1)
          CALL PSCTXT(X,Y,TSIZE,LSM)
          X = X + 8.0
          CALL PSTEXT(X,YTEXT,8.0,'disulphide')
          X = X + 30.0
      ENDIF

C---- Write in restraint type: long/medium/short
      IF (SHOWRN) THEN
          X = XLEFT
          Y = YTEXT - 10.0
          IF (SIDEBY) THEN
              X = XLEFT + 247.0
              Y = YTEXT
          ENDIF
          CALL PSTEXT(X,Y,8.0,'Restraint ranges defined as:-')
          X = X + 81.0
          IF (DCLASS) THEN
              IF (INCLUS) THEN
                  WRITE(TEXT,220) 'S=short-range (', CLASS(1,1), ' -',
     -                CLASS(2,1), ' A)'
 220              FORMAT(A,F5.2,A,F5.2,A)
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(3)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
              IF (INCLUM) THEN
                  WRITE(TEXT,220) 'M=medium-range (', CLASS(1,2), ' -',
     -                CLASS(2,2), ' A)'
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(2)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
              IF (INCLUL) THEN
                  WRITE(TEXT,220) 'L=Long-range (', CLASS(1,3), ' -',
     -                CLASS(2,3), ' A)'
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(1)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
          ELSE
              IF (INCLUS) THEN
                  TEXT = 'S=short-range (same residue)'
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(3)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
              IF (INCLUM) THEN
                  TEXT = 'M=Medium (sep. <= 4 residues)'
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(2)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
              IF (INCLUL) THEN
                  TEXT = 'L=Long (sequence sep. > 4 residues)'
                  IF (INCOLR(PLTYPE)) THEN
                      ICOLR = COLPNT(1)
                      CALL PSCOLB(RGB(1,ICOLR),RGB(2,ICOLR),
     -                    RGB(3,ICOLR))
                  ENDIF
                  CALL PSTEXT(X + 10.0,Y,8.0,TEXT(1:LENSTR(TEXT)))
                  Y = Y - 8.0
              ENDIF
          ENDIF
          Y = Y - 8.0
          IF (INCOLR(PLTYPE)) THEN
              CALL PSCOLB(RGB(1,1),RGB(2,1),RGB(3,1))
          ENDIF
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
