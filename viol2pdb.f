C**************************************************************************
C
C  VIOL2PDB.F  -  Program to generate a PDB-format file of a set of NOE
C                 and/or H-bond restraints, showing violations and
C                 upper-bound excesses for a user-selected range of
C                 models and residues
C
C     Written by Roman Laskowski, University College, London, March 1996.
C
C     Original version was part of v.3.4 of the PROCHECK suite of programs.
C     
C     Subsequent amendments will be labelled by CHECK v.m.n--> and
C     CHECK v.m.n<-- where m.n is the version number corresponding to the
C     change
C     
C  v.3.4.3 - Addition of ranges file (as used in the other PROCHECK-NMR
C            programs) for defining which models and which residue ranges
C            are to be included.
C                                              Roman Laskowski (16 May 1996)
C            Amendments to routines for reading in the pseudo-atom
C            coordinates. Changed temorary solution to final version now
C            that Ton's Aqua writes this file out.
C                                              Roman Laskowski (22 Jul 1996)
C
C--------------------------------------------------------------------------
C
C Compilation and linking (on unix)
C -----------------------
C
C f77 -u -c viol2pdb.f
C f77 -u -c ps.f
C f77 -o viol2pdb viol2pdb.o ps.o
C
C Compilation and linking (on VAX VMS)
C -----------------------
C
C FORT VIOL2PDB
C FORT PS
C LINK VIOL2PDB, PS
C
C--------------------------------------------------------------------------
C     
C  Files
C  -----
C     
C  1  <filename>.pdb          - Input PDB file containing the ensemble
C                               of NMR models
C  2  <filename>_pseudo.pdb   - Input PDB file containing the pseudo atoms
C                               generated by AQUA
C  7  <filename>_xxxviol.pdb  - Output restraints files, in PDB format,
C                               giving restraint violations for xxx = noe,
C                               hb and ss.
C  8  <filename>_xxxsatis.pdb - Output restraints files, in PDB format,
C                               giving satisfied restrains for xxx = noe,
C                               hb and ss.
C 12  <filename>.nrv - NOE restraints            }
C     <filename>.hrv - H-bond restraints         }  Files output by AQUA
C     <filename>.srv - S-S disulphide restraints }  holding restraint data
C     <filename>.tor - Dihedral angle restraints }
C 16  <user-defined> - Optional input file holding the model- and residue-
C                      number ranges to be included in the plots.
C
C--------------------------------------------------------------------------
C     
C     Subroutine calling tree
C     -----------------------
C     
C     MAIN    --> INITS
C             --> GETPDB
C             --> PARAMS
C             --> GETRNG  --> GETOKN
C                         --> INTOKN  --> LENSTR
C                         --> DELTOK
C                         --> STOTOK
C                         --> PRNRNG
C             --> REAPDB  --> LENSTR
C             --> REAPSU  --> LENSTR
C             --> GETRST  --> LENSTR
C             --> WRIRST  --> WRIATS
C
C--------------------------------------------------------------------------
      
      
      PROGRAM VIOL2
      
      INCLUDE 'viol2pdb.inc'

      INTEGER       MAXCON
      REAL          ACDIST(MAXARR)

C---- Initialise variables
      INSCRP = .TRUE.
CDEBUG
      INSCRP = .FALSE.
CDEBUG
      CALL INITS
      
C---- Request the name of the PDB file
      CALL GETPDB
      IF (IFAIL) GO TO 999

C---- Get the program parameters
      CALL PARAMS
      IF (IFAIL) GO TO 999

CHECK v.3.4.3-->
C---- Read in the model- and residue-ranges in the supplied ranges file,
C     if there is one
      IF (HAVRAN) THEN
          CALL GETRNG(FILRNG,MODFRM,MODTO,RESFRM,RESTO,MAXRNG,MRANGE,
     -        NRANGE,BOTHND,IFAIL)
          IFAIL = .FALSE.
          MODEL = MODFRM(1)

C----     Check whether the user has selected a range of residues
          IF (RESFRM(1).NE.'*ALL  ') RSELEC = .TRUE.
      ENDIF
CHECK v.3.4.3<--

C---- Read in the structures of the ensemble
      CALL REAPDB
      IF (IFAIL) GO TO 999
      MAXCON = MAXARR / (NMODEL + 2)

C---- Read in any pseudo-atoms calculated by AQUA
      CALL REAPSU
      IF (IFAIL) GO TO 999

C---- Read in the restraints from the Aqua output files
      CALL GETRST(ACDIST,NMODEL,MAXCON)
      IF (IFAIL) GO TO 999
C      CALL GETORS(NFILE)
C      IF (IFAIL) GO TO 999
      IF (TCONST.EQ.0) THEN
          IFAIL = .TRUE.
          GO TO 999
      ENDIF

C---- Write the required restraints out to the output PDB file
      CALL WRIRST(ACDIST,NMODEL,MAXCON)

 999  CONTINUE
      IF (IFAIL) THEN
         PRINT*, '**** Program terminated with error'
      ELSE 
         PRINT*, 'Program complete'
      ENDIF
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C     
C  SUBROUTINE INITS  -  Initialise variables
C     
C----------------------------------------------------------------------+---
      
      SUBROUTINE INITS
      
      INCLUDE 'viol2pdb.inc'
      
      CHARACTER*3   AMNAME(NAMINO)
      INTEGER       IAMINO, IMODEL

      DATA AMNAME /'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -             'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -             'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

C---- Initialise variables
      DO 50, IAMINO = 1, NAMINO
          AMINO(IAMINO) = AMNAME(IAMINO)
 50   CONTINUE
CHECK v.3.4.3-->
      BOTHND = .FALSE.
CHECK v.3.4.3<--
      ENSEMB = .FALSE.
      FSTRES = 1
CHECK v.3.4.3-->
      HAVRAN = .FALSE.
CHECK v.3.4.3<--
      IFAIL = .FALSE.
      DO 100, IMODEL = 1, MXMODL
          LSTATM(IMODEL) = 0
          NMRMOD(IMODEL) = -9999
 100  CONTINUE
      MODALL = .FALSE.
      MODFST = .FALSE.
      MODEL = 0
CHECK v.3.4.3-->
C      MRANGE = 0
      MRANGE = 1
      MODFRM(MRANGE) = 1
      MODTO(MRANGE) = 1
      DO 110, IMODEL = 1, MXMODL
          MWANT(IMODEL) = .FALSE.
 110  CONTINUE
      MWANT(1) = .TRUE.
      NRANGE = 1
      RESFRM(NRANGE) = '*ALL  '
      RESTO(NRANGE) = 'XXXXXX'
CHECK v.3.4.3<--
      NCONEC = 0
      NMODEL = 0
      NMR = .TRUE.
      NRES = 0
      WSHORT = .FALSE.
      WMEDIU = .FALSE.
      WLONG = .FALSE.

      RETURN
      END
      
C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETPDB  -  Read in the name out the output file and the
C                        chain
C
C----------------------------------------------------------------------+--- 
 
      SUBROUTINE GETPDB
 
      INCLUDE 'viol2pdb.inc'
 
CHECK v.3.4.3-->
C      CHARACTER*1   LOWERA
C      CHARACTER*26  UPPER
CHECK v.3.4.3<--
      INTEGER       IEND, ISTART, LINE
      LOGICAL       IERROR

CHECK v.3.4.3-->
C      DATA  LOWERA / 'a' /
C      DATA  UPPER  / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
CHECK v.3.4.3<--

C---- Initialise variables
      LINE = 0

C---- Accept name of output file
      IF (.NOT.INSCRP) THEN
          PRINT*, 'Enter name of input PDB file'
      ENDIF
      READ(*,110,ERR=900) PDBFIL
 110  FORMAT(A)

C---- Peel off directory path and extension
      CALL GETNAM(PDBFIL,ISTART,IEND,IERROR)
      IF (IERROR) GO TO 990

C---- Form names of other files that will be required in default directory
      BRCALL = PDBFIL(ISTART:IEND)
CHECK v.3.4.3-->
C      FILPSU = PDBFIL(ISTART:IEND) // '.pseudo'
      FILPSU = PDBFIL(ISTART:IEND) // '_pseudo.pdb'
CHECK v.3.4.3<--
      FILTOR = PDBFIL(ISTART:IEND) // '.tor'
      FILVIO(1) = PDBFIL(ISTART:IEND) // '.nrv'
      FILVIO(2) = PDBFIL(ISTART:IEND) // '.hrv'
      FILVIO(3) = PDBFIL(ISTART:IEND) // '.srv'
      FILOUT(1,1) = PDBFIL(ISTART:IEND) // '_noeviol.pdb'
      FILOUT(1,2) = PDBFIL(ISTART:IEND) // '_hbviol.pdb'
      FILOUT(1,3) = PDBFIL(ISTART:IEND) // '_ssviol.pdb'
      FILOUT(2,1) = PDBFIL(ISTART:IEND) // '_noesatis.pdb'
      FILOUT(2,2) = PDBFIL(ISTART:IEND) // '_hbsatis.pdb'
      FILOUT(2,3) = PDBFIL(ISTART:IEND) // '_sssatis.pdb'

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** ERROR. Data error in entered filename'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.
 
999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4.3-->
C SUBROUTINE GETNAM removed as object code now linked to ps.f
CHECK v.3.4.3<--
C**************************************************************************
C
C  SUBROUTINE PARAMS  -  Get the program parameters
C
C----------------------------------------------------------------------+---

      SUBROUTINE PARAMS

      INCLUDE 'viol2pdb.inc'

CHECK v.3.4.3-->
      CHARACTER*1   CH
CHECK v.3.4.3<--
      CHARACTER*80  IREC
CHECK v.3.4.3-->
C      INTEGER       I, IERR
C      LOGICAL       GOTNXT
      INTEGER       GOTLMS, GOTNUM, I, IERR, ILEN, IMODEL, IPOS, LENSTR
      LOGICAL       GOTNXT
CHECK v.3.4.3<--

C---- Initialise variables
      GOTNXT = .FALSE.

C---- Accept model number
      IF (.NOT.INSCRP) THEN
          PRINT*
CHECK v.3.4.3-->
C          PRINT*, 'Enter model number, or * for all models in the ense',
C     -        'mble'
          PRINT*, 'Enter name of ranges file, or single model number, ',
     -        'or * for all models in the ensemble'
CHECK v.3.4.3<--
      ENDIF
      READ(*,20) IREC
 20   FORMAT(A)
CHECK v.3.4.3-->
C      I = INDEX(IREC,'*')
C      IF (I.GT.0) THEN
C          MODALL = .TRUE.
C      ELSE IF (IREC.EQ.' ') THEN
C          MODFST = .TRUE.
C      ELSE
C          READ(IREC,40,IOSTAT=IERR) I
C 40       FORMAT(I14.0)
C          IF (IERR.EQ.0) THEN
C              MODEL = I
C
CC----     If not a valid response, then assume that no option for model
CC         selection has been entered and this line in fact corresponds
CC         to the restraint type(s) required
C          ELSE
C              MODFST = .TRUE.
C              GOTNXT = .TRUE.
C          ENDIF
C      ENDIF

C---- Check whether the contents of the response might be a filename, a
C     model number, and asterisk or the response to the next question
      ILEN = LENSTR(IREC)

C---- Check whether ALL models required
      IF (ILEN.EQ.1 .AND. IREC(1:1).EQ.'*') THEN
          MODALL = .TRUE.

C---- Otherwise check for other possibilities
      ELSE IF (ILEN.GT.0) THEN
          GOTLMS = 0
          GOTNUM = 0
          DO 50, IPOS = 1, ILEN
              CH = IREC(IPOS:IPOS)
              IF (CH.EQ.'L' .OR. CH.EQ.'M' .OR. CH.EQ.'S') THEN
                  GOTLMS = GOTLMS + 1
              ELSE IF (LGE(CH,'0') .AND. LLE(CH,'9')) THEN
                  GOTNUM = GOTNUM + 1
              ENDIF
 50       CONTINUE

C----     If this is the next parameter, then can skip all else
          IF (GOTLMS.EQ.ILEN) THEN
              MODFST = .TRUE.
              GOTNXT = .TRUE.

C----     If this is an entirely numeric entry, then must be a single
C         model number
          ELSE IF (GOTNUM.EQ.ILEN) THEN
              READ(IREC,60,IOSTAT=IERR) I
 60           FORMAT(I14.0)
              IF (IERR.EQ.0) THEN
                  MODEL = I

C----         If not a valid response, then assume that no option for model
C             selection has been entered and this line in fact corresponds
C             to the restraint type(s) required
              ELSE
                  MODFST = .TRUE.
                  GOTNXT = .TRUE.
              ENDIF

C----     Otherwise, take this to be the name of a ranges file
          ELSE
              FILRNG = IREC
              HAVRAN = .TRUE.
          ENDIF

C---- If nothing entered, than take default of first model only
      ELSE
          MODFST = .TRUE.
      ENDIF
CHECK v.3.4.3<--

C---- Accept restraint selection
 100  CONTINUE
      IF (.NOT.GOTNXT) THEN
          IF (.NOT.INSCRP) THEN
              PRINT*
              PRINT*, 'Enter restraint type(s) required:-'
              PRINT*, '    L = Long-range only (seq. sep. > 4 residues)'
              PRINT*, '    M = Medium-range only (seq. sep. <= 4 resid',
     -            'ues)'
              PRINT*, '    S = Short-range only (within same residue)'
              PRINT*, '    ... or any combination (eg LM for long and ',
     -            'medium)'
          ENDIF
          READ(*,20) IREC
      ENDIF

C---- If no options selected, then default is all restraints
      IF (IREC.EQ.' ') THEN
          WLONG = .TRUE.
          WMEDIU = .TRUE.
          WSHORT = .TRUE.
      ENDIF

C---- Check whether long-range restraints required
      I = INDEX(IREC,'L')
      IF (I.GT.0) THEN
          WLONG = .TRUE.
      ENDIF

C---- Check whether medium-range restraints required
      I = INDEX(IREC,'M')
      IF (I.GT.0) THEN
          WMEDIU = .TRUE.
      ENDIF

C---- Check whether short-range restraints required
      I = INDEX(IREC,'S')
      IF (I.GT.0) THEN
          WSHORT = .TRUE.
      ENDIF

CHECK v.3.4.3-->
C---- Set the model flags according to which models are required
      IF (.NOT.HAVRAN) THEN
          IF (MODALL) THEN
              MRANGE = 1
              MODFRM(MRANGE) = -99999
              MODTO(MRANGE) = 99999
              DO 300, IMODEL = 1, MXMODL
                  MWANT(IMODEL) = .TRUE.
 300          CONTINUE
          ELSE IF (.NOT.MODFST) THEN
              MRANGE = 1
              MODFRM(MRANGE) = MODEL
              MODTO(MRANGE) = MODEL
          ENDIF
      ENDIF
CHECK v.3.4.3<--

      GO TO 999

C---- Errors

C---- Close the parameter file
C 990  CONTINUE
C      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE REAPDB  -  Read through appropriate .new file and
C                        accumulate coords to calculate mean positions
C
C----------------------------------------------------------------------+---

      SUBROUTINE REAPDB

      SAVE

      INCLUDE 'viol2pdb.inc'

      CHARACTER*1   CHAIN
      CHARACTER*3   RESDUE
      CHARACTER*4   ATNAME
      CHARACTER*5   SEQNO
      CHARACTER*6   IDENT, INSEQ
      CHARACTER*13  ATMKEY
      CHARACTER*80  IREC
      INTEGER       I, IATOM, IERR, LENSTR, LINE, RNO
CHECK v.3.4.3-->
C      LOGICAL       GOTMOD, HAVMOD, WANTED
      LOGICAL       GOTMOD, HAVMOD, INMODL, WANTED
CHECK v.3.4.3<--
      REAL          COORDS(3)

C---- Initialise variables
      GOTMOD = .FALSE.
      HAVMOD = .FALSE.
      IFAIL = .FALSE.
      LINE = 0
      IATOM = 0

C---- Open the PDB file
      OPEN(UNIT=1, FILE=PDBFIL, STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Scan through the PDB file to see if it contains any MODEL records
100   CONTINUE
          READ(1,120,END=150,ERR=904) IREC
120       FORMAT(A)
          IF (IREC(1:6).EQ.'MODEL ') HAVMOD = .TRUE.
      IF (.NOT.HAVMOD) GO TO 100

C---- Rewind the PDB file
 150  CONTINUE
      REWIND(1)

C---- If file has MODEL records, set model number to zero, otherwise
C     only have a single model
      IF (HAVMOD) THEN
          NMODEL = 0
      ELSE
          NMODEL = 1
      ENDIF
      NMRMOD(1) = NMODEL
      IF (MODFST) MODEL = 1

C---- Loop through the PDB file, picking out all the ATOM and HETATM
C     records
200   CONTINUE
          READ(1,120,END=800,ERR=904) IREC
          LINE = LINE + 1
          IDENT = IREC(1:6)

C----     Determine whether this record is required for processing
          IF (IDENT.EQ.'ATOM  ' .OR. IDENT.EQ.'HETATM') THEN

C----         Check whether atom belongs to a required model
              WANTED = .FALSE.
              IF (NMODEL.GT.0 .AND. NMODEL.LE.MXMODL) THEN
CHECK v.3.4.3-->
C                  IF (MODALL .OR. NMRMOD(NMODEL).EQ.MODEL) THEN
C                      WANTED = .TRUE.
C                      GOTMOD = .TRUE.
C                  ENDIF
                  WANTED = INMODL(NMRMOD(NMODEL),MODFRM,MODTO,MAXRNG,
     -                MRANGE)
                  IF (WANTED) GOTMOD = .TRUE.
CHECK v.3.4.3<--
              ENDIF

C----         If atom is wanted, then store its details
              IF (WANTED) THEN

C----             Pick off atom name, residue name, chain and sequence number
                  ATNAME = IREC(13:16)
                  RESDUE = IREC(18:20)
                  CHAIN = IREC(22:22)
                  INSEQ = IREC(22:27)
                  SEQNO = IREC(23:27)
                  READ(INSEQ,240,IOSTAT=IERR) RNO
 240              FORMAT(I5,1X)
                  IF (IERR.NE.0) RNO = 0

C----             Retrieve the atomic coordinates
                  READ(IREC,280,ERR=902) (COORDS(I), I = 1, 3)
280               FORMAT(30X,3F8.0)

C----             Form the unique, identifying key for this atom
                  ATMKEY = INSEQ // RESDUE // ATNAME

C----             Increment atom-store
                  IATOM = IATOM + 1
                  IF (IATOM.GT.MXATOM) GO TO 906

C----             Save the ATOM ID and coordinates
                  ATOMID(IATOM) = ATMKEY
                  ATMXYZ(1,IATOM) = COORDS(1)
                  ATMXYZ(2,IATOM) = COORDS(2)
                  ATMXYZ(3,IATOM) = COORDS(3)
                  LSTATM(NMODEL) = IATOM
                  MODNUM(IATOM) = NMODEL
                  RESNUM(IATOM) = RNO
CHECK v.3.4.3-->
                  RESNO(IATOM) = CHAIN // SEQNO
CHECK v.3.4.3<--
              ENDIF

C----     If MODEL record, then increment count of models processed and
C         reinitialise variables
          ELSE IF (IDENT.EQ.'MODEL ') THEN
              IF (HAVMOD) THEN
                  NMODEL = NMODEL + 1
                  IF (NMODEL.LE.MXMODL) THEN
                      READ(IREC,320,ERR=908) NMRMOD(NMODEL)
 320                  FORMAT(8X,I6)
                      IF (MODFST .AND. NMODEL.EQ.1) THEN
                          MODEL = NMRMOD(NMODEL)
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      GO TO 200

C---- End of Brookhaven file reached
 800  CONTINUE

C---- Show statistics on the models read in
      NATOMS = IATOM
      IF (NMODEL.EQ.0) GO TO 910
      IF (.NOT.GOTMOD) GO TO 912
      IF (NATOMS.EQ.0) GO TO 914
      PRINT*
      PRINT*, 'NMR structure'
      PRINT*, '-------------'
      PRINT 810, 'Number of models read in:        ', NMODEL
 810  FORMAT(1X,A,I6)
      PRINT*
      PRINT 810, 'Total no. of atoms stored:       ', NATOMS
      PRINT*

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** ERROR. Unable to open input PDB file:'
      PRINT*, '****        ', PDBFIL(1:LENSTR(PDBFIL))
      GO TO 990

 902  CONTINUE
      PRINT*, '**** Error in coords for atom: ', ATNAME, '-', RESDUE,
     -    '-', INSEQ
      GO TO 200

 904  CONTINUE
      PRINT*, '**** Data error reading file:  [',
     -    PDBFIL(1:LENSTR(PDBFIL)), ']'
      PRINT*, '    Line: ', LINE
      GO TO 990

 906  CONTINUE
      PRINT*, '**** Maximum number of atoms per protein exceeded:',
     -    MXATOM
      GO TO 990

 908  CONTINUE
      PRINT*, '**** ERROR in model number: ', IREC(1:14)
      GO TO 990

 910  CONTINUE
      PRINT*, '**** No protein models found in input PDB file!'
      GO TO 990

 912  CONTINUE
      PRINT*, '**** Given model number not found in PDB file:',
     -    MODEL
      GO TO 990

 914  CONTINUE
      PRINT*, '**** No atoms stored from input PDB file'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
CHECK v.3.4.3-->
C FUNCTION LENSTR removed as object code now linked to ps.f
CHECK v.3.4.3<--
C**************************************************************************
C
C  SUBROUTINE REAPSU  -  Read through the pseudo-atoms file to store any
C                        pseudo-atom coordinates not in the original PDB
C                        file
C
C----------------------------------------------------------------------+---

      SUBROUTINE REAPSU

      SAVE

      INCLUDE 'viol2pdb.inc'

      CHARACTER*1   CHAIN
      CHARACTER*3   RESDUE
      CHARACTER*4   ATNAME
      CHARACTER*5   SEQNO
      CHARACTER*6   IDENT, INSEQ
      CHARACTER*13  ATMKEY
      CHARACTER*80  IREC
      INTEGER       I, IATOM, IERR, IMODEL, LENSTR, LINE, RNO
CHECK v.3.4.3-->
C      LOGICAL       WANTED
      LOGICAL       INMODL, WANTED
CHECK v.3.4.3<--
      REAL          COORDS(3)

C---- Initialise variables
      IFAIL = .FALSE.
      LINE = 0
      IATOM = NATOMS
CHECK v.3.4.3-->
      IMODEL = 0
CHECK v.3.4.3<--

C---- Open the pseudo-atoms file
      OPEN(UNIT=2, FILE=FILPSU, STATUS='OLD', FORM='FORMATTED',
     -     ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=999)

C---- Loop through the file reading in all the pseudo atom records
200   CONTINUE
          READ(2,120,END=800,ERR=904) IREC
 120      FORMAT(A)
          LINE = LINE + 1
          IDENT = IREC(1:6)

C----     Determine whether this record is required for processing
          IF (IDENT.EQ.'ATOM  ' .OR. IDENT.EQ.'HETATM') THEN

CHECK v.3.4.3-->
CC----         Get this atom's model number
C              READ(IREC,220,ERR=908) IMODEL
C 220          FORMAT(6X,I5)
CHECK v.3.4.3<--

C----         Check whether atom belongs to a required model
              WANTED = .FALSE.
              IF (IMODEL.GT.0 .AND. IMODEL.LE.MXMODL) THEN
CHECK v.3.4.3-->
C                  IF (MODALL .OR. NMRMOD(IMODEL).EQ.MODEL) THEN
C                      WANTED = .TRUE.
C                  ENDIF
                  WANTED = INMODL(NMRMOD(IMODEL),MODFRM,MODTO,MAXRNG,
     -                MRANGE)
CHECK v.3.4.3<--
              ENDIF

C----         If atom is wanted, then store its details
              IF (WANTED) THEN

C----             Pick off atom name, residue name, chain and sequence number
                  ATNAME = IREC(13:16)
                  RESDUE = IREC(18:20)
                  CHAIN = IREC(22:22)
                  INSEQ = IREC(22:27)
                  SEQNO = IREC(23:27)
                  READ(INSEQ,240,IOSTAT=IERR) RNO
 240              FORMAT(1X,I4,1X)
                  IF (IERR.NE.0) RNO = 0

C----             Retrieve the atomic coordinates
                  READ(IREC,280,ERR=902) (COORDS(I), I = 1, 3)
280               FORMAT(30X,3F8.0)

C----             Form the unique, identifying key for this atom
                  ATMKEY = INSEQ // RESDUE // ATNAME

C----             Increment atom-store
                  IATOM = IATOM + 1
                  IF (IATOM.GT.MXATOM) GO TO 906

C----             Save the ATOM ID and coordinates
                  ATOMID(IATOM) = ATMKEY
                  ATMXYZ(1,IATOM) = COORDS(1)
                  ATMXYZ(2,IATOM) = COORDS(2)
                  ATMXYZ(3,IATOM) = COORDS(3)
                  MODNUM(IATOM) = IMODEL
                  RESNUM(IATOM) = RNO
CHECK v.3.4.3-->
                  RESNO(IATOM) = CHAIN // SEQNO
CHECK v.3.4.3<--
              ENDIF

CHECK v.3.4.3-->
C----     If this is a model record, pick up the model number
          ELSE IF (IDENT.EQ.'MODEL ') THEN
              READ(IREC,420,ERR=908) IMODEL
 420          FORMAT(6X,I8)
CHECK v.3.4.3<--
          ENDIF
      GO TO 200

C---- End of Brookhaven file reached
 800  CONTINUE

C---- Show statistics on the models read in
      PRINT*
      PRINT*, 'Pseudo atoms'
      PRINT*, '------------'
      PRINT*
      PRINT 810, 'Total no. of pseudo atoms stored:', IATOM - NATOMS
 810  FORMAT(1X,A,I6)
      PRINT*
      NATOMS = IATOM

      GO TO 999

C---- Fatal errors
 902  CONTINUE
      PRINT*, '**** Error in coords for atom: ', ATNAME, '-', RESDUE,
     -    '-', INSEQ
      GO TO 200

 904  CONTINUE
      PRINT*, '**** Data error reading file:  [',
     -    FILPSU(1:LENSTR(FILPSU)), ']'
      PRINT*, '    Line: ', LINE
      GO TO 990

 906  CONTINUE
      PRINT*, '**** Maximum number of atoms per protein exceeded:',
     -    MXATOM
      GO TO 990

 908  CONTINUE
      PRINT*, '**** ERROR in model number: ', IREC(1:14)
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETRST  -  Read through the Aqua output files to pick up
C                        all the distance restraints
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETRST(ACDIST,NFILE,MAXCON)

      INCLUDE 'viol2pdb.inc'

      CHARACTER*1   RESCHN(2)
      CHARACTER*3   RESNAM(2)
      CHARACTER*4   ATMNAM(2)
      CHARACTER*5   RESSEQ(2)
      CHARACTER*13  ATMKEY
      CHARACTER*80  FNAME
      CHARACTER*512 IREC
      INTEGER       IATOM, IATMNO(2), ICONST, ICTYPE, IERR, IFILE, 
     -              IRESAT, LCONST, LENSTR, LINE, NFILE, NLOST, MAXCON,
     -              RSEP
      LOGICAL       ENDFIL, LONG, MEDIUM, SHORT, START, WANTED
      REAL          ACDIST(NFILE + 2,MAXCON)

C---- Initialise variables
      ENDFIL = .FALSE.
      IFAIL = .FALSE.
      LINE = 0
      DO 100, ICTYPE = 1, NCTYPE
          NCONST(ICTYPE) = 0
 100  CONTINUE
      DO 200, ICONST = 1, MXCONS
          RESTYP(ICONST) = ' '
          VIOATM(1,ICONST) = 0
          VIOATM(2,ICONST) = 0
 200  CONTINUE
      ICONST = 0
      LCONST = 0

C---- Loop through the various AQUA output files
      DO 800, ICTYPE = 1, NCTYPE

C----     Initialise counts
          NLOST = 0

C----     Get the appropriate filename
          FNAME = FILVIO(ICTYPE) 
          PRINT*
          PRINT*, 'Reading in restraints from file: ',
     -         FNAME(1:LENSTR(FNAME)), ' ...'

C----     Open the restraints file
          OPEN(UNIT=12, FILE=FNAME, STATUS='OLD', FORM='FORMATTED',
     -         ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST', READONLY,
     -         IOSTAT=IERR)
          START = .FALSE.

C----     If restraints file not found, then just print a warning
C         message
          IF (IERR.NE.0) THEN
              PRINT*, '     *** Warning. Restraints file not found'

C----     Otherwise, read in the restraints
          ELSE

C----         Loop through the records in the file until get to the start
C             of the restraints data
 300          CONTINUE
                  READ(12,320,END=700,IOSTAT=IERR) IREC
 320              FORMAT(A)
                  LINE = LINE + 1
                  IF (IERR.NE.0) THEN
                      PRINT*, '***  File-read error at line', LINE
                      IREC = ' '
                  ENDIF

C----             Check whether have reached the start of the data
                  IF (IREC(1:17).EQ.'$ DATA  DISTANCES') THEN

C----                 Skip the next two lines
                      READ(12,*,END=700,ERR=700)
                      READ(12,*,END=700,ERR=700)
                      START = .TRUE.
                  ENDIF

C----         If still not found start of data, loop back for next record
              IF (.NOT.START) GO TO 300

C----         Read in the data from the file
              ENDFIL = .FALSE.
 400          CONTINUE
                  READ(12,320,END=700,IOSTAT=IERR) IREC
                  LINE = LINE + 1
                  IF (IERR.NE.0) THEN
                      PRINT*, '*  File-read error at line', LINE
                      IREC = ' '

C----             Check for the end of the data
                  ELSE IF (IREC(1:5).EQ.'$ END') THEN
 9                   ENDFIL = .TRUE.

C----             If not end, then store this restraint
                  ELSE

C----                 Extract the two residues involved
                      ATMNAM(1) = IREC(15:18)
                      RESCHN(1) = IREC(2:2)
                      RESNAM(1) = IREC(4:6)
                      RESSEQ(1) = IREC(9:13)
                      ATMNAM(2) = IREC(35:38)
                      RESCHN(2) = IREC(22:22)
                      RESNAM(2) = IREC(24:26)
                      RESSEQ(2) = IREC(29:33)
                      IATMNO(1) = 0
                      IATMNO(2) = 0
                      WANTED = .FALSE.

C----                 Check that both atoms making up the restraint are
C                     present
                      DO 500, IRESAT = 1, 2

C----                     Loop through all the atoms
                          IATOM = 0
 450                      CONTINUE

C----                     Increment atom number
                          IATOM = IATOM + 1

C----                         Get the current atom's ID and check whether
C                             it is one of the two restraint atoms
                              ATMKEY = ATOMID(IATOM)
                              IF (ATMKEY(1:1).EQ.RESCHN(IRESAT) .AND.
     -                            ATMKEY(2:6).EQ.RESSEQ(IRESAT) .AND.
     -                            ATMKEY(7:9).EQ.RESNAM(IRESAT) .AND.
     -                           (ATMKEY(10:13).EQ.ATMNAM(IRESAT) .OR.
     -                            ATMKEY(11:13).EQ.ATMNAM(IRESAT)))
     -                            IATMNO(IRESAT) = IATOM
                          IF (IATMNO(IRESAT).EQ.0 .AND. IATOM.LT.NATOMS)
     -                        GO TO 450
 500                  CONTINUE

C----                 If have located both atoms, then check restraint
C                     type and decide whether it is wanted or not
                      IF (IATMNO(1).NE.0 .AND.IATMNO(2).NE.0) THEN

C----                     Determine the residue separation between
C                         the two residues
                          SHORT = .FALSE.
                          MEDIUM = .FALSE.
                          LONG = .FALSE.
                          RSEP = ABS(RESNUM(IATMNO(1))
     -                        - RESNUM(IATMNO(2)))
                          IF (RSEP.EQ.0) THEN
                              SHORT = .TRUE.
                          ELSE IF (RSEP.LE.4) THEN
                              MEDIUM = .TRUE.
                          ELSE
                              LONG = .TRUE.
                          ENDIF

C----                     Check whether this restraint is wanted
                          IF ((SHORT .AND. WSHORT) .OR.
     -                        (MEDIUM .AND. WMEDIU) .OR.
     -                        (LONG .AND. WLONG)) WANTED = .TRUE.
                      ENDIF

C----                 If this restraint is wanted, then store it
                      IF (WANTED) THEN

C----                     Increment restraints count
                          ICONST = ICONST + 1
                          IF (ICONST.GT.MAXCON) THEN
                              PRINT*, '  *** Warning. Maximum restrain',
     -                            'ts array MAXARR exceeded',
     -                            MAXARR
                              PRINT*, '  *** Some restraint informatio',
     -                            'n has been lost'
                              GO TO 700
                          ENDIF
                          IF (ICONST.GT.MXCONS) THEN
                              PRINT*, '* Warning. Restraint-violations',
     -                            ' array MXCONS exceeded', MXCONS
                              PRINT*, '* Some restraint information ha',
     -                            's been lost'
                              GO TO 700
                          ENDIF

C----                     Store the names of the two atoms involved
                          ATOMRS(1,ICONST) = ATOMID(IATMNO(1))
                          ATOMRS(2,ICONST) = ATOMID(IATMNO(2))

C----                     Read in the restraint violations for all the models
                          READ(IREC,360,IOSTAT=IERR)
     -                        (ACDIST(IFILE,ICONST),
     -                        IFILE = 1, NFILE + 2)
CHECK v.3.4.3-->
C 360                      FORMAT(43X,60F7.2)
 360                      FORMAT(44X,60F7.3)
CHECK v.3.4.3<--
                          IF (IERR.EQ.0) THEN
                              VIOATM(1,ICONST) = IATMNO(1)
                              VIOATM(2,ICONST) = IATMNO(2)

C----                         Check whether restraint has both a lower-
C                             and upper-bound, or just one of these
                              RESTYP(ICONST) = 'B'
                              IF (IREC(53:57).EQ.' 0.  ')
     -                            RESTYP(ICONST) = 'L'
                              IF (IREC(46:50).EQ.' 0.  ')
     -                            RESTYP(ICONST) = 'U'

C----                     If there's an error, reject this restraint
                          ELSE
                              PRINT*, '* Warning. Error reading restr',
     -                            'aint on line', LINE
                              ICONST = ICONST - 1
                          ENDIF

C----                 Otherwise print warning message
                      ELSE 
                          IF (IATMNO(1).EQ.0) THEN
                              PRINT*, '  *** Warning. Restraint atom n',
     -                            'ot found [', ATMNAM(1), ' ',
     -                            RESNAM(1), ' ', RESSEQ(1), ']'
                          ENDIF
                          IF (IATMNO(2).EQ.0) THEN
                              PRINT*, '  *** Warning. Restraint atom n',
     -                            'ot found [', ATMNAM(2), ' ',
     -                            RESNAM(2), ' ', RESSEQ(2), ']'
                          ENDIF
                          NLOST = NLOST + 1
                      ENDIF
                  ENDIF

C----         Loop back for next record
              IF (.NOT.ENDFIL) GO TO 400
          ENDIF

C----     End of file reached
 700      CONTINUE

C----     Print stats on restraints read in
          IF (ICONST.GT.MAXCON) ICONST = MAXCON
          NCONST(ICTYPE) = ICONST - LCONST
          PRINT*, '  Number of valid restraints read in:      ',
     -        NCONST(ICTYPE)
          IF (NLOST.GT.0) THEN
              PRINT*, '  Number of restraints lost:               ',
     -            NLOST
          ENDIF
          LCONST = ICONST
 800  CONTINUE

C---- Total number of restraints
      TCONST = ICONST
      PRINT*
      PRINT*, '                                                    ---'
      PRINT*, 'Total number of restraints read in:        ',
     -    TCONST
      PRINT*
      IF (TCONST.EQ.0) THEN
          PRINT*, '   **** No distance restraints found'
      ENDIF

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE WRIRST  -  Write out all the selected restraints and their
C                        violations
C
C----------------------------------------------------------------------+---

      SUBROUTINE WRIRST(ACDIST,NFILE,MAXCON)

      INCLUDE 'viol2pdb.inc'

      INTEGER       SFILE, VFILE
      PARAMETER    (SFILE = 8, VFILE = 7)

CHECK v.3.4.3-->
      CHARACTER*1   INCHN
CHECK v.3.4.3<--
      CHARACTER*3   RTYPE(NCTYPE)
CHECK v.3.4.3-->
      CHARACTER*5   SEQNO
CHECK v.3.4.3<--
      CHARACTER*13  ATMKEY
      CHARACTER*45  RNAME(NCTYPE)
      CHARACTER*50  TSELEC(3)
CHECK v.3.4.3-->
C      CHARACTER*80  IREC1, IREC2
      CHARACTER*80  IREC, IREC1, IREC2
CHECK v.3.4.3<--
      INTEGER       ATOM1, ATOM2, ATOMPS, IATOM, IATMNO(2), ICONEC,
CHECK v.3.4.3-->
C     -              ICONST, ICTYPE, IEND, ILEN, IMODEL, IPOS, IRESAT,
C     -              ISTART, LENSTR, MAXCON, NFILE, NOUT(2),
     -              ICONST, ICTYPE, IEND, ILEN, IMODEL, IPOS, IRANGE,
     -              IRESAT, ISTART, LENSTR, MAXCON, NFILE, NOUT(2),
CHECK v.3.4.3<--
     -              NWROUT(2,NCTYPE), OUTFIL
CHECK v.3.4.3-->
C      LOGICAL       EXCESS, LOWVIO, UPPVIO
      LOGICAL       EXCESS, INMODL, INRANG, LOWVIO, UPPVIO, WANTED,
     -              WANT1, WANT2
CHECK v.3.4.3<--
      REAL          ACDIST(NFILE + 2,MAXCON), DIFF, FRACTN,
     -              LOWER, UPPER, X(4), Y(4), Z(4)

      DATA RTYPE  / 'NOE', 'HB', 'SS' /
      DATA RNAME  / 'NOE distance restraints           ',
     -              'H-bond distance restraints        ',
     -              'S-S disulphide distance restraints' /
      DATA TSELEC / 'Long-range restraints (seq. sep. > 4 residues)',
     -              'Medium-range restraints (seq. sep. <= 4 residues)',
     -              'Short-range restraints (within same residue)' /

C---- Initialise variables
      ISTART = 1
      DO 10, ICTYPE = 1, NCTYPE
          NWROUT(1,ICTYPE) = 0
          NWROUT(2,ICTYPE) = 0
 10   CONTINUE

C---- Loop through the different restraint types
      DO 800, ICTYPE = 1, NCTYPE

C----     Report on progress
          PRINT*, ICTYPE, '. Processing ',
     -        RNAME(ICTYPE)(1:LENSTR(RNAME(ICTYPE))), ' ...'

C----     Open the restraint violations file
          OPEN(UNIT=VFILE, FILE=FILOUT(1,ICTYPE), STATUS='UNKNOWN',
     -         FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST',
     -         ERR=900)

C----     Open the satisfied restraints file
          OPEN(UNIT=SFILE, FILE=FILOUT(2,ICTYPE), STATUS='UNKNOWN',
     -         FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -         CARRIAGECONTROL = 'LIST',
CHECK v.3.4.3-->
C     -         ERR=900)
     -         ERR=901)
CHECK v.3.4.3<--

C----     Write out header information to both files
          WRITE(7,20) PDBFIL(1:LENSTR(PDBFIL))
 20       FORMAT('REMARK',/,
     -        'REMARK  Restraint violations for PDB file:- ',A)
          WRITE(8,30) PDBFIL(1:LENSTR(PDBFIL))
 30       FORMAT('REMARK  Satisfied restraints for PDB file:- ',A)
          IF (MODALL) THEN
              WRITE(7,40) 'ALL ', NMODEL, ' models'
              WRITE(8,40) 'ALL ', NMODEL, ' models'
 40           FORMAT('REMARK',/,
     -            'REMARK     * Model selection:    ',A,I3,A)
CHECK v.3.4.3-->
          ELSE IF (HAVRAN) THEN
              WRITE(7,42)
              WRITE(8,42)
 42           FORMAT('REMARK',/,
     -            'REMARK     * Model selection:')
              DO 50, IRANGE = 1, MRANGE

C----             Retrieve start of model-number range
                  IF (MODFRM(IRANGE).EQ.-99999) THEN
                      IREC = 'From FIRST model'
                  ELSE
                      WRITE(IREC,44) MODFRM(IRANGE)
 44                   FORMAT('From model ',I5)
                  ENDIF

C----             Retrieve end of model-number range
                  IF (MODTO(IRANGE).EQ.99999) THEN
                      IREC(17:) = ' to LAST model'
                  ELSE
                      WRITE(IREC(17:),46) MODTO(IRANGE)
 46                   FORMAT(' to model ',I5)
                  ENDIF

C----             Show the interpreted range
                  WRITE(7,48) IREC(1:31)
                  WRITE(8,48) IREC(1:31)
 48               FORMAT('REMARK     *      ',A)
 50           CONTINUE
              
CHECK v.3.4.3<--
          ELSE
              WRITE(7,40) 'Model ', MODEL, ' only'
              WRITE(8,40) 'Model ', MODEL, ' only'
          ENDIF

C----     Write out the restraint types selected
          WRITE(7,60)
          WRITE(8,60)
 60       FORMAT('REMARK',/,
     -            'REMARK     * Restraint type(s):  ')
          IF (WSHORT) THEN
              WRITE(7,80) TSELEC(3)
              WRITE(8,80) TSELEC(3)
 80           FORMAT('REMARK            ',A)
          ENDIF
          IF (WMEDIU) THEN
              WRITE(7,80) TSELEC(2)
              WRITE(8,80) TSELEC(2)
          ENDIF
          IF (WLONG) THEN
              WRITE(7,80) TSELEC(1)
              WRITE(8,80) TSELEC(1)
          ENDIF

C----     Add blank REMARK record
          WRITE(7,120)
          WRITE(8,120)
 120      FORMAT('REMARK')

C----     Initialise variables
          NCONEC = 0
          NOUT(1) = 0
          NOUT(2) = 0

C----     For each restraint, loop over all the models of the ensemble
          DO 600, IMODEL = 1, NMODEL

C----         Process only if all models required, or if this is 
C             the right model
CHECK v.3.4.3-->
C              IF (MODALL .OR. NMRMOD(IMODEL).EQ.MODEL) THEN
              WANTED = INMODL(NMRMOD(IMODEL),MODFRM,MODTO,MAXRNG,
     -            MRANGE)
              IF (WANTED) THEN
CHECK v.3.4.3<--

C----             Report on progress
                  IF (MODALL) THEN
                      PRINT 160, '          Model ', NMRMOD(IMODEL)
 160                  FORMAT(A,8X,I3)
                  ENDIF

C----             Write model number to output files
                  WRITE(7,180) NMRMOD(IMODEL)
 180              FORMAT('REMARK  Model   ',I6)
                  WRITE(8,180) NMRMOD(IMODEL)

C----             Get the position of this model's actual distance
                  IPOS = IMODEL + 2

C----             Get the start- and end-atoms of the current model
                  ATOM1 = 1
                  IF (IMODEL.GT.1) THEN
                      ATOM1 = LSTATM(IMODEL - 1) + 1
                  ENDIF
                  ATOM2 = LSTATM(IMODEL)

C----             Get the start-position for the pseudo atoms
                  ATOMPS = LSTATM(NMODEL) + 1

C----             Get number of restraints stored of this type
                  IEND = ISTART + NCONST(ICTYPE) - 1

C----             Loop through all the restraints of this type
                  DO 500, ICONST = ISTART, IEND

C----                 Get the lower and upper bounds of this restraint
                      LOWER = ACDIST(1,ICONST)
                      UPPER = ACDIST(2,ICONST)

C----                 Check that both atoms making up the restraint are
C                     present
                      IATMNO(1) = 0
                      IATMNO(2) = 0
                      DO 300, IRESAT = 1, 2

C----                     Loop through all the atoms
                          IATOM = ATOM1
 250                      CONTINUE

C----                     Increment atom number
                          IATOM = IATOM + 1

C----                     Get the current atom's ID and check whether
C                         it is one of the two restraint atoms
                          ATMKEY = ATOMID(IATOM)
                          IF (ATMKEY.EQ.ATOMRS(IRESAT,ICONST))
     -                        IATMNO(IRESAT) = IATOM
                          IF (IATMNO(IRESAT).EQ.0 .AND. IATOM.LT.ATOM2)
     -                        GO TO 250
 300                  CONTINUE

C----                 If either atom not found, then search through list of
C                     pseudo atoms computed by AQUA
                      DO 400, IRESAT = 1, 2

C----                     If atom not found, search pseudo atoms
                          IF (IATMNO(IRESAT).EQ.0) THEN

C----                         Initialise to start of pseudo atoms
                              IATOM = ATOMPS

C----                         Loop through all the pseudo atoms until
C                             match found
 350                          CONTINUE

C----                             Increment atom number
                                  IATOM = IATOM + 1

C----                             Get the current atom's ID and check
C                                 whether it is one of the two
C                                 restraint atoms
                                  ATMKEY = ATOMID(IATOM)
                                  IF (ATMKEY.EQ.ATOMRS(IRESAT,ICONST)
     -                                .AND. IMODEL.EQ.MODNUM(IATOM))
     -                                 IATMNO(IRESAT) = IATOM
                              IF (IATMNO(IRESAT).EQ.0 .AND.
     -                            IATOM.LT.NATOMS)
     -                            GO TO 350
                          ENDIF
 400                  CONTINUE

C----                 If have locted both atoms, then process
                      IF (IATMNO(1).NE.0 .AND.IATMNO(2).NE.0) THEN

CHECK v.3.4.3-->
C----                     Check whether either atom is within the
C                         residue range
                          IATOM = IATMNO(1)
                          INCHN = RESNO(IATOM)(1:1)
                          SEQNO = RESNO(IATOM)(2:6)
                          WANT1 = INRANG(SEQNO,INCHN,RESFRM,RESTO,
     -                        MAXRNG,NRANGE)
                          IATOM = IATMNO(2)
                          INCHN = RESNO(IATOM)(1:1)
                          SEQNO = RESNO(IATOM)(2:6)
                          WANT2 = INRANG(SEQNO,INCHN,RESFRM,RESTO,
     -                        MAXRNG,NRANGE)
                          IF (BOTHND) THEN
                              IF (WANT1 .AND. WANT2) THEN
                                  WANTED = .TRUE.
                              ELSE
                                  WANTED = .FALSE.
                              ENDIF
                          ELSE IF (WANT1 .OR. WANT2) THEN
                              WANTED = .TRUE.
                          ELSE
                              WANTED = .FALSE.
                          ENDIF
CHECK v.3.4.3<--

C----                     Initialise flags
                          EXCESS = .FALSE.
                          LOWVIO = .FALSE.
                          UPPVIO = .FALSE.

C----                     Get the coordinates of the two atoms
C                             (1)-----------------------(2)
                          X(1) = ATMXYZ(1,IATMNO(1))
                          Y(1) = ATMXYZ(2,IATMNO(1))
                          Z(1) = ATMXYZ(3,IATMNO(1))
                          X(2) = ATMXYZ(1,IATMNO(2))
                          Y(2) = ATMXYZ(2,IATMNO(2))
                          Z(2) = ATMXYZ(3,IATMNO(2))

C----                     Check for lower-bound violation
CHECK v.3.4.3-->
C                          IF (ACDIST(IPOS,ICONST).LT.LOWER) THEN
                          IF (WANTED .AND.
     -                        ACDIST(IPOS,ICONST).LT.LOWER) THEN
CHECK v.3.4.3<--

C----                         Calculate the fraction of the actual bond
C                             length corresponding to the violation
                              DIFF = LOWER - ACDIST(IPOS,ICONST)
                              FRACTN = DIFF / ACDIST(IPOS,ICONST)
                              FRACTN = (1.0 - FRACTN) / 2.0

C----                         Calculate the coordinates of the relevant points
C                                 (|)--(1)-------------(2)--(|)
C                                       <Actual distance>
C                                  <-------Lower bound------->
C                                      (1)--(3)----(4)-(2)
C                                            <XXXXXX> Violation
                              X(3) = X(1) + FRACTN * (X(2) - X(1))
                              Y(3) = Y(1) + FRACTN * (Y(2) - Y(1))
                              Z(3) = Z(1) + FRACTN * (Z(2) - Z(1))
                              X(4) = X(2) - FRACTN * (X(2) - X(1))
                              Y(4) = Y(2) - FRACTN * (Y(2) - Y(1))
                              Z(4) = Z(2) - FRACTN * (Z(2) - Z(1))
                              LOWVIO = .TRUE.

C----                     Check for upper-bound violation
CHECK v.3.4.3-->
C                          ELSE IF (ACDIST(IPOS,ICONST).GT.UPPER) THEN
                          ELSE IF (WANTED .AND.
     -                             ACDIST(IPOS,ICONST).GT.UPPER) THEN
CHECK v.3.4.3<--

C----                         Calculate the fraction of the actual bond
C                             length corresponding to the violation
                              DIFF = ACDIST(IPOS,ICONST) - UPPER
                              FRACTN = DIFF / ACDIST(IPOS,ICONST)
                              FRACTN = FRACTN / 2.0

C----                         Calculate the coordinates of the relevant points
C                                 (1)--(3)-------------(4)--(2)
C                                       <--Upper bound-->
C                                  <-----Actual distance----->
C                                  <XXXX>   Violation   <XXXX>
                              X(3) = X(1) + FRACTN * (X(2) - X(1))
                              Y(3) = Y(1) + FRACTN * (Y(2) - Y(1))
                              Z(3) = Z(1) + FRACTN * (Z(2) - Z(1))
                              X(4) = X(2) - FRACTN * (X(2) - X(1))
                              Y(4) = Y(2) - FRACTN * (Y(2) - Y(1))
                              Z(4) = Z(2) - FRACTN * (Z(2) - Z(1))
                              UPPVIO = .TRUE.

C----                     Otherwise check the upper-bound excess over the
C                         actual distance
CHECK v.3.4.3-->
C                          ELSE
                          ELSE IF (WANTED) THEN
CHECK v.3.4.3<--

C----                         Calculate the fraction of the actual bond
C                             length corresponding to the violation
                              DIFF = UPPER - ACDIST(IPOS,ICONST)
                              FRACTN = DIFF / ACDIST(IPOS,ICONST)
                              FRACTN = FRACTN / 2.0

C----                         Calculate the coordinates of the relevant points
C                                 (1)--(3)-------------(4)--(2)
C                                       <--Upper bound-->
C                                  <-----Actual distance----->
C                                  <XXXX>   Violation   <XXXX>
                              X(3) = X(1) - FRACTN * (X(2) - X(1))
                              Y(3) = Y(1) - FRACTN * (Y(2) - Y(1))
                              Z(3) = Z(1) - FRACTN * (Z(2) - Z(1))
                              X(4) = X(2) + FRACTN * (X(2) - X(1))
                              Y(4) = Y(2) + FRACTN * (Y(2) - Y(1))
                              Z(4) = Z(2) + FRACTN * (Z(2) - Z(1))
                              EXCESS = .TRUE.
                          ENDIF

C----                     Write out the corresponding ATOM records

C----                     Upper-bound violation
                          IF (UPPVIO) THEN
                              CALL WRIATS(X,Y,Z,1,3,' O  ',3,4,' H  ',
     -                            4,2,' O  ',NOUT(1),DIFF,IATMNO(1),
     -                            IATMNO(2),'U',RTYPE(ICTYPE),VFILE)
                              NWROUT(1,ICTYPE) = NWROUT(1,ICTYPE) + 1

C----                     Lower-bound violation
                          ELSE IF (LOWVIO) THEN
                              CALL WRIATS(X,Y,Z,1,3,' H  ',3,4,' O  ',
     -                            4,2,' H  ',NOUT(1),DIFF,IATMNO(1),
     -                            IATMNO(2),'L',RTYPE(ICTYPE),VFILE)
                              NWROUT(1,ICTYPE) = NWROUT(1,ICTYPE) + 1

C----                     Satisfied restraints only
CHECK v.3.4.3-->
C                          ELSE
                          ELSE IF (WANTED) THEN
CHECK v.3.4.3<--
                              CALL WRIATS(X,Y,Z,3,1,' N  ',1,2,' H  ',
     -                            2,4,' N  ',NOUT(2),DIFF,IATMNO(1),
     -                            IATMNO(2),' ',RTYPE(ICTYPE),SFILE)
                              NWROUT(2,ICTYPE) = NWROUT(2,ICTYPE) + 1
                          ENDIF
                      ENDIF
 500              CONTINUE

C----             Write ENDMDL records to both files
COUT                  WRITE(7,520)
COUT 520              FORMAT('ENDMDL')
COUT                  WRITE(8,520)
              ENDIF
 600      CONTINUE

C----     Prepare for the next loop
          ISTART = IEND + 1

C----     Write out all the CONECT records to the two files
          NCONEC = MIN(NCONEC,MXCONS)
          DO 700, ICONEC = 1, NCONEC
              OUTFIL = CONNEC(3,ICONEC)
              WRITE(OUTFIL,620) CONNEC(1,ICONEC), CONNEC(2,ICONEC)
 620          FORMAT('CONECT',10I5)
 700      CONTINUE

C----     Close the two output files
CHECK v.3.4.3-->
C          CLOSE(VFILE)
C          CLOSE(SFILE)
          IF (NWROUT(1,ICTYPE).GT.0) THEN
              CLOSE(VFILE)
          ELSE
              CLOSE(VFILE,STATUS='DELETE')
          ENDIF
          IF (NWROUT(2,ICTYPE).GT.0) THEN
              CLOSE(SFILE)
          ELSE
              CLOSE(SFILE,STATUS='DELETE')
          ENDIF
CHECK v.3.4.3<--
 800  CONTINUE

C---- Show number of records written out
      PRINT*
      IF (MODALL) THEN
          PRINT 810, 'Number of restraints selected and written out fo',
     -        'r ALL ', NMODEL, ' models:-'
      ELSE
          PRINT 810, 'Number of restraints selected and written out fo',
     -        'r model ', MODEL, ':-'
 810      FORMAT(1X,2A,I3,A)
      ENDIF
      PRINT*
      PRINT 820
 820  FORMAT(45X,'Satisfied   Violated       Total')
      DO 1000, ICTYPE = 1, NCTYPE
          PRINT 840, RNAME(ICTYPE), NWROUT(2,ICTYPE), NWROUT(1,ICTYPE),
     -        NWROUT(1,ICTYPE) + NWROUT(2,ICTYPE)
 840      FORMAT(5X,A40,I6,6X,I6,6X,I8)
 1000 CONTINUE
      PRINT*
      PRINT*, 'Corresponding file names:-'
      IREC1 = 'Satisfied'
      IREC2 = 'Violated'
      ILEN = LENSTR(FILOUT(2,1))
      PRINT 1020, IREC1(1:ILEN), IREC2(1:ILEN)
 1020 FORMAT(40X,2(2X,A))
      DO 1200, ICTYPE = 1, NCTYPE
          PRINT 1040, RNAME(ICTYPE), FILOUT(2,ICTYPE)(1:ILEN),
     -        FILOUT(1,ICTYPE)(1:ILEN)
 1040     FORMAT(5X,A35,2(2X,A))
 1200 CONTINUE

      GO TO 999

C---- Fatal errors
CHECK v.3.4.3-->
C900   CONTINUE
C      PRINT*, '**** ERROR. Unable to open output PDB file:'
C      PRINT*, '****        ', FILOUT(1:LENSTR(FILOUT))
C      GO TO 990
 900  CONTINUE
      PRINT*, '**** ERROR. Unable to open output PDB file:'
      PRINT*, '****        ',
     -    FILOUT(1,ICTYPE)(1:LENSTR(FILOUT(1,ICTYPE)))
      GO TO 990

 901  CONTINUE
      PRINT*, '**** ERROR. Unable to open output PDB file:'
      PRINT*, '****        ',
     -    FILOUT(2,ICTYPE)(1:LENSTR(FILOUT(2,ICTYPE)))
      GO TO 990
CHECK v.3.4.3<--

CHECK v.3.4.3-->
C 902  CONTINUE
C      PRINT*, '**** Warning. Maximum number of CONEC records exceeded'
C      PRINT*, '****          Some restraints will be lost'
C      GO TO 999
CHECK v.3.4.3<--

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE WRIATS  -  Write out the atom records corresponding to the
C                        restraint distances
C
C----------------------------------------------------------------------+---

      SUBROUTINE WRIATS(X,Y,Z,I1,J1,ATYPE1,I2,J2,ATYPE2,I3,J3,ATYPE3,
     -    NOUT,DIFF,IATOM,JATOM,VIOTYP,RSTYP,OUTFIL)

      INCLUDE 'viol2pdb.inc'

      CHARACTER*1   VIOTYP
      CHARACTER*3   RSTYP
      CHARACTER*4   ATYPE1, ATYPE2, ATYPE3
      INTEGER       IATOM, I1, I2, I3, JATOM, J1, J2, J3, NOUT, OUTFIL
      REAL          DIFF, X(4), Y(4), Z(4)

C---- First link
      IF (ATYPE1.NE.' ') THEN
          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE1,
     -        ATOMID(IATOM)(7:9),
     -        ATOMID(IATOM)(1:1),
     -        ATOMID(IATOM)(2:6), X(I1), Y(I1), Z(I1),
     -        DIFF, ATOMID(IATOM)(10:13), VIOTYP, RSTYP
 140      FORMAT('HETATM',I5,1X,A4,1X,A3,1X,A1,A5,3X,
     -        3F8.3,'  1.00',F6.2,2X,A,1X,A,1X,A)

          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE1,
     -        ATOMID(IATOM)(7:9),
     -        ATOMID(IATOM)(1:1),
     -        ATOMID(IATOM)(2:6), X(J1), Y(J1), Z(J1),
     -        DIFF, ATOMID(IATOM)(10:13), VIOTYP, RSTYP
          NCONEC = NCONEC + 1
          IF (NCONEC.GT.MXCONS) GO TO 900
          CONNEC(1,NCONEC) = NOUT - 1
          CONNEC(2,NCONEC) = NOUT
          CONNEC(3,NCONEC) = OUTFIL
      ENDIF

C---- Second link
      IF (ATYPE2.NE.' ') THEN
          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE2,
     -        ATOMID(IATOM)(7:9),
     -        ATOMID(IATOM)(1:1),
     -        ATOMID(IATOM)(2:6), X(I2), Y(I2), Z(I2),
     -        DIFF, ATOMID(IATOM)(10:13), VIOTYP, RSTYP

          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE2,
     -        ATOMID(JATOM)(7:9),
     -        ATOMID(JATOM)(1:1),
     -        ATOMID(JATOM)(2:6), X(J2), Y(J2), Z(J2),
     -        DIFF, ATOMID(JATOM)(10:13), VIOTYP, RSTYP
          NCONEC = NCONEC + 1
          IF (NCONEC.GT.MXCONS) GO TO 900
          CONNEC(1,NCONEC) = NOUT - 1
          CONNEC(2,NCONEC) = NOUT
          CONNEC(3,NCONEC) = OUTFIL
      ENDIF

C---- Violation - end 1
      IF (ATYPE3.NE.' ') THEN
          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE3,
     -        ATOMID(JATOM)(7:9),
     -        ATOMID(JATOM)(1:1),
     -        ATOMID(JATOM)(2:6), X(I3), Y(I3), Z(I3),
     -        DIFF, ATOMID(JATOM)(10:13), VIOTYP, RSTYP

          NOUT = NOUT + 1
          WRITE(OUTFIL,140) NOUT, ATYPE3,
     -        ATOMID(JATOM)(7:9),
     -        ATOMID(JATOM)(1:1),
     -        ATOMID(JATOM)(2:6), X(J3), Y(J3), Z(J3),
     -        DIFF, ATOMID(JATOM)(10:13), VIOTYP, RSTYP
          NCONEC = NCONEC + 1
          IF (NCONEC.GT.MXCONS) GO TO 900
          CONNEC(1,NCONEC) = NOUT - 1
          CONNEC(2,NCONEC) = NOUT
          CONNEC(3,NCONEC) = OUTFIL
      ENDIF

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '**** Warning. Maximum number of CONEC records exceeded'
      PRINT*, '****          Some restraints will be lost'
      GO TO 990

 990  CONTINUE
      IFAIL = .TRUE.

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
