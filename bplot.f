C**************************************************************************
C
C  BPLOT.FOR  -  Program to plot histograms of the main-chain bond length
C                and bond angle data calculated by program anglen and
C                stored in the appropriat.lan file
C
C     Written by Roman Laskowski, University College, London, November 1993.
C
C     Original version was part of v.2.2 of the PROCHECK suite of programs.
C
C     Amendments after v.3.0 will be labelled by CHECK v.m.n--> and
C     CHECK v.m.n<-- where m.n is the version number corresponding to the
C     change
C
C  v.3.0   - Amendments to PostScript to routines to ensure that any lines
C            output to the output PostScript file are not longer than 80
C            characters (as some laser printers can't cope with long lines!)
C            Small change to ensure that the final comment on the distorted
C            geometry plots isn't sometimes lost when the pictures are
C            close to the bottom of the page.
C            Complete overhaul of parameter file, now called procheck.prm,
C            including addition of colour options.
C            Addition of option to accept a single chain-ID to restrict
C            all the plots to just the residues of a single chain.
C                                      Roman Laskowski (14 Nov-14 Dec 1993)
C  v.3.1   - Transfer of FINKEY, GETCOL and GETNAM routines to ps.f. Unit
C            number for procheck.prm file changed to 10 for consistency.
C            Addition of plot description to display of plot file name.
C                                           Roman Laskowski (8-19 Apr 1994)
C  v.3.2   - Addition of identifying plot handle to each plot filename.
C            Addition of descriptive plot title to header of PostScript
C            file.
C            Addition of .sum file holding a summary page.
C            Addition of option to print plot filename on the plot itself.
C            Chain ID made case-insensitive.
C            Where a bond length/angle spans two residues on the Distorted
C            Geometry plot, change made to show both residue names.
C                                       Roman Laskowski (25 Apr-3 May 1994)
C            Addition of option allowing plots of same type to be combined
C            in a single PostScript file.
C                                             Roman Laskowski (12 Oct 1994)
C            Minor amendments to various statements to make them
C            acceptable to f2c, and to deal with various uninitialised
C            variables.(Amendments supplied by Dave Love at Daresbury).
C                                  David Love/Roman Laskowski (18 Oct 1994)
C
C  v.3.3.2 - Output of summary statistics in html format
C                                              Roman Laskowski (21 Aug 1995)
C  v.3.4   - Amendments to PSPAGE calls to comply with additional parameter
C            (used by other programs).
C                                              Roman Laskowski (25 Mar 1996)
C            Increase of number of colours that can be user-defined.
C                                              Roman Laskowski (24 Apr 1996)
C  v.3.4.3 - Output of HTML file only if being run for WWW pages.
C                                              Roman Laskowski ( 1 Oct 1996)
C
C  v.3.5   - Bug-fix to percentage counts of points within limits and     
C            highlighted, as shown in the .sum file. (Spotted by Jurgen
C            Doreleijers).
C                                            Roman Laskowski (31 Oct 1996)
C  v.3.6.4   Change to OPEN statement for .sum file in ps.f (to work under
C            Win-64).
C            Changes to GETNAM in ps.f to recognize full path in Win-64
C            version.
C            Increase in filename lengths to 512 characters.
C                                              Roman Laskowski ( 8 Aug 2013)
C
C--------------------------------------------------------------------------
C
C Compilation and linking (on unix)
C -----------------------
C
C f77 -u -c bplot.f
C f77 -u -c ps.f
C f77 -o bplot bplot.o ps.o
C
C Compilation and linking (on VAX VMS)
C -----------------------
C
C FORT BPLOT
C FORT PS
C LINK BPLOT, PS
C
C--------------------------------------------------------------------------
C
C     Files
C     -----
C
C  2  <filename>.lan - File generated by program ANGLEN, holding all the
C                      mainchain bond lengths and bond angles
C  3  <filename>.pln - File generated by program ANGLEN, holding the
C                      transformed coordinates of all the planar groups
C  10 procheck.prm   - Input parameter file containing user-defined
C                      options governing the plots produced.
C  11 <filename>.dnn - Output PostScript files, numbered nn = 01, 02, ...
C                      with the last-used number being picked up from
C                      the ps.number file
C  12  ps.number     - Input file holding last-used number for the
C                      PostScript files
C  14 <filename>.sum - Output summary page showing summarised results from
C                      all the plots
C  15 <filename>.html- Output html file giving summary statistics in html
C                      format
C
C--------------------------------------------------------------------------
C
C     Subroutine calling tree
C     -----------------------
C
C     MAIN    --> INITS
C             --> PARAMS   --> FINKEY
C                          --> GETCOL
C             --> GETPSN
C
C                 Get filename and resolution of structure
C             --> GETCOD   --> GETNAM
C             --> OPESUM
C             --> OPEHTM
C
C                 Read through bond lengths/angles file to calculate
C                 minimum, maximum and means values
C             --> GETLAN
C
C                 Plot the histograms for main-chain bond lengths, bond
C                 angles and planar groups
C             --> HPLOTS  --> HBOUND
C                         --> HCOUNT
C                         --> BARPLT  --> BAREND  --> PSENDP
C                                                 --> PSCLOS
C                                                 --> PSCTXT
C                                                 --> PSRCTX
C                                                 --> PSHADE
C                                                 --> PSTRIA
C                                                 --> PSTEXT
C                                     --> BARHED  --> PSNAME
C                                                 --> PSPAGE
C                                                 --> PSOPEN
C                                                 --> PSLWID
C                                                 --> PSCTXT
C                                     --> PSLWID
C                                     --> PSHADE
C                                     --> PSDASH
C                                     --> PSBBOX
C                                     --> AXES    --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSCTXT
C                                     --> BARTXT  --> PSCTXT
C                                     --> BARLIN  --> PSLWID
C                                                 --> PSDASH
C                                                 --> PSLINE
C                                     --> BARDRW  --> PSHADE
C                                                 --> PSBBOX
C                                                 --> PSTEXT
C                                                 --> PSLINE
C                                     --> BAROFF  --> PSHADE
C                                                 --> PSTRIA
C
C                 Plot distorted geometry
C             --> DISTGM  --> DGPLOT  --> REAPLN
C                                     --> REALAN
C                                     --> DISEND  --> PSENDP
C                                                 --> PSCLOS
C                                     --> DISHED  --> PSNAME
C                                                 --> PSPAGE
C                                                 --> PSOPEN
C                                                 --> PSLWID
C                                                 --> PSCTXT
C                                     --> DRWLIN  --> PSCTXT
C                                                 --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                     --> DRWANG  --> PSCTXT
C                                                 --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSHADE
C                                                 --> PSBBOX
C                                     --> DRWPLN  --> PSCTXT
C                                                 --> PSLWID
C                                                 --> PSLINE
C                                                 --> PSHADE
C                                                 --> PSBBOX
C
C--------------------------------------------------------------------------


      PROGRAM BPLOT

      INCLUDE 'bplot.inc'


C---- Initialise variables
      CALL INITS

C---- Read in the program parameters
      CALL PARAMS
      IF (IFAIL) GO TO 999

C---- Read in the last-used plot-number for the PostScript files
      CALL GETPSN(IPLOT)

C---- Read in the code of the Brookhaven file and the structure's resolution
      CALL GETCOD
      IF (IFAIL) GO TO 999

CHECK v.3.2-->
C---- Open the summary file
      CALL OPESUM(FILSUM,.FALSE.,IFAIL)
      IF (IFAIL) GO TO 999
CHECK v.3.2<--

CHECK v.3.3.2-->
C---- Open the html file
CHECK v.3.4.3-->
      IF (WWWOUT) THEN
CHECK v.3.4.3<--
          CALL OPEHTM(FILHTM,.FALSE.,IFAIL)
          IF (IFAIL) GO TO 999
CHECK v.3.4.3-->
      ENDIF
CHECK v.3.4.3<--
CHECK v.3.3.2<--

C---- Read through the bond lengths and bond angles file to find the mean
C     and maximum and minimum values
      CALL GETLAN
      IF (IFAIL) GO TO 999

C---- Perform the histogram plots
      CALL HPLOTS
      IF (IFAIL) GO TO 999

C---- Perform plots of distorted geometry
      IF (PLOTDG) CALL DISTGM
      IF (IFAIL) GO TO 999

 999  CONTINUE
      IF (IFAIL) THEN
         PRINT*, '*** Program terminated with error'
CHECK v.3.2-->
          WRITE(14,*)
          WRITE(14,*) '*** Program bplot terminated with error. See lo',
     -        'g file:  bplot.log'
          WRITE(14,*)
CHECK v.3.2<--
      ELSE
         PRINT*, '* Program complete'
      ENDIF

CHECK v.3.2-->
C---- Write closing line(s) to the summary file
      WRITE(14,1010)
 1010 FORMAT(' +------------------------------------------------------',
     -    '----------------------+',/,
     -       '   + May be worth investigating further.  * Worth invest',
     -    'igating further.',/)

C---- Display name of summary file
      PRINT*, '*'
      PRINT*, '* Summary page: ', FILSUM(1:ILEN + 4)
      PRINT*, '*'
CHECK v.3.2<--

      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE INITS  -  Initialise variables
C
C----------------------------------------------------------------------+---

      SUBROUTINE INITS

      INCLUDE 'bplot.inc'

      REAL           PI

C---- Initialise variables
      IFAIL = .FALSE.
      PI = 4.0 * ATAN(1.0)
      RADDEG = PI / 180.0

C---- Initialise default parameters      
      BSHADE(1) = .TRUE.
      BSHADE(2) = .TRUE.
      BSHADE(3) = .TRUE.
CHECK v.3.2-->
      COMBPS = .FALSE.
CHECK v.3.2<--
      DGLIMA = 10.0
      DGLIML = 0.05
      DGLIMP = 0.03
      DGLIMR = 0.04
      INCOLR(1) = .FALSE.
      INCOLR(2) = .FALSE.
      INCOLR(3) = .FALSE.
      LIMPLN(1) = 0.02
      LIMPLN(2) = 0.03
      LIMRES(1) = 2.0
      LIMRES(2) = 2.0
CHECK v.3.2-->
      PLABEL = .TRUE.
CHECK v.3.2<--
      PLOTBA = .TRUE.
      PLOTBL = .TRUE.
      PLOTDG = .TRUE.
      PLOTPL = .TRUE.
      TODO(1) = 0
      TODO(2) = 0
      TODO(3) = 0
      TOPLOT(1) = .FALSE.
      TOPLOT(2) = .FALSE.
      TOPLOT(3) = .FALSE.
CHECK v.3.2-->
      WITHAN = .FALSE.
CHECK v.3.2<--
CHECK v.3.4.3-->
      WWWOUT = .FALSE.
CHECK v.3.4.3<--

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE PARAMS  -  Read in program parameters from parameter file
C
C----------------------------------------------------------------------+---

      SUBROUTINE PARAMS

      INCLUDE 'bplot.inc'

      CHARACTER*1   YESNO
CHECK v.3.4-->
      CHARACTER*80  IREC
CHECK v.3.4<--
      INTEGER       I, ICOL, LINE
CHECK v.3.4-->
C      LOGICAL       ALLCOL, FINERR
      LOGICAL       ALLCOL, ENDCOL, FINERR
CHECK v.3.4<--
      REAL          RNUMB

C---- Initialise variables and set default parameter values
      FINERR = .FALSE.
      LINE = 0

C---- Open parameter file
CHECK v.3.1-->
C      OPEN(UNIT=1, FILE='procheck.prm', STATUS='OLD',
      OPEN(UNIT=10, FILE='procheck.prm', STATUS='OLD',
CHECK v.3.1<--
     -     FORM='FORMATTED', ACCESS='SEQUENTIAL',
CVAX     -     CARRIAGECONTROL = 'LIST', READONLY,
     -     ERR=900)

C---- Read in the parameters

C---- Check that have the right version number in the parameter file
CHECK v.3.2-->
C      CALL FINKEY('PROCHECK v.3.0',14,LINE,FINERR)
      CALL FINKEY('PROCHECK v.3.3',14,LINE,FINERR)
      IF (FINERR) THEN
          CALL FINKEY('PROCHECK v.3',12,LINE,FINERR)
          IF (FINERR) THEN
              GO TO 901
          ELSE
              PRINT*, '* Warning. Parameter file not up-to-date'
              PRINT*, '*          Defaults will be used for missing',
     -            ' items'
          ENDIF
      ENDIF
CHECK v.3.2<--
      IF (FINERR) GO TO 901

C---- Find the colours key-word
      CALL FINKEY('Colours',7,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Read in all the RGB colours and corresponding colour names
CHECK v.3.4-->
C      DO 100, ICOL = 1, MXCOLR
C          LINE = LINE + 1
CCHECK v.3.1-->
CC          READ(1,*,END=902,ERR=904) (RGB(I, ICOL), I = 1, 3),
C          READ(10,*,END=902,ERR=904) (RGB(I, ICOL), I = 1, 3),
CCHECK v.3.1<--
C     -        COLNAM(ICOL)
C 100  CONTINUE
      ENDCOL = .FALSE.
      NCOLOR = MXCOLR
      DO 100, ICOL = 1, MXCOLR
          IF (.NOT.ENDCOL) THEN
              LINE = LINE + 1
              READ(10,20,END=902,ERR=904) IREC
 20           FORMAT(A)
              IF (IREC.EQ.' ') THEN
                  ENDCOL = .TRUE.
              ELSE
                  READ(IREC,*,ERR=904) (RGB(I,ICOL), I = 1, 3),
     -                COLNAM(ICOL)
                  NCOLOR = ICOL
              ENDIF
          ENDIF

C----     If have reached end of colours then insert default
          IF (ENDCOL) THEN
              RGB(1,ICOL) = 0.0
              RGB(2,ICOL) = 0.0
              RGB(3,ICOL) = 0.0
              COLNAM(ICOL) = 'WHITE'
          ENDIF
 100  CONTINUE
CHECK v.3.4<--

C---- Determine whether all plots are to be in colour

C---- Find the colour-all-plots keywords
      CALL FINKEY('Colour all plots?',17,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Determine whether all plots are to be in colour
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          ALLCOL = .TRUE.
CHECK v.3.4.3-->
      ELSE IF (YESNO.EQ.'W' .OR. YESNO.EQ.'w') THEN
          ALLCOL = .TRUE.
          WWWOUT = .TRUE.
CHECK v.3.4.3<--
      ELSE
          ALLCOL = .FALSE.
      ENDIF

C---- Determine which plots are to be produced

C---- Find the "Which plots" keyword
      CALL FINKEY('Which plots',11,LINE,FINERR)
      IF (FINERR) GO TO 990

C---- Skip the first 6 options as these done by tplot.f and pplot.f
      DO 150, I = 1, 6
          LINE = LINE + 1
CHECK v.3.1-->
C          READ(1,120,END=902,ERR=904) YESNO
          READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
 120      FORMAT(A)
 150  CONTINUE

C---- 7. Main-chain bond-length distributions (Y/N)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTBL = .TRUE.
      ELSE
          PLOTBL = .FALSE.
      ENDIF

C---- 8. Main-chain bond-angle distributions (Y/N)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTBA = .TRUE.
      ELSE
          PLOTBA = .FALSE.
      ENDIF

C---- 9. RMS distances from planarity (Y/N)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTPL = .TRUE.
      ELSE
          PLOTPL = .FALSE.
      ENDIF

C---- 10. Distorted geometry plots (Y/N)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          PLOTDG = .TRUE.
      ELSE
          PLOTDG = .FALSE.
      ENDIF

C---- Read in the plot parameters

C---- 7. Main-chain bond-length distributions

C---- Find the Main-chain bond lengths key-word
      CALL FINKEY('7. Main-chain bond length',25,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = 1

C---- Plot options

C---- Background shading (Y/N)?
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          BSHADE(PLTYPE) = .TRUE.
      ELSE
          BSHADE(PLTYPE) = .FALSE.
      ENDIF

C---- No. of standard deviations for highlighting
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      LIMRES(PLTYPE) = RNUMB
      IF (LIMRES(PLTYPE).LT.0.0) LIMRES(PLTYPE) = 0.0
      IF (LIMRES(PLTYPE).GT.99.9) LIMRES(PLTYPE) = 99.9

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 200, ICOL = 1, 4
          CALL GETCOL(COLPLT(PLTYPE,ICOL),LINE,COLNAM,MXCOLR)
 200  CONTINUE

C---- 8. Main-chain bond-angle distributions

C---- Find the Main-chain bond angles key-word
      CALL FINKEY('8. Main-chain bond angle',24,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = 2

C---- Plot options

C---- Background shading (Y/N)?
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          BSHADE(PLTYPE) = .TRUE.
      ELSE
          BSHADE(PLTYPE) = .FALSE.
      ENDIF

C---- No. of standard deviations for highlighting
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      LIMRES(PLTYPE) = RNUMB
      IF (LIMRES(PLTYPE).LT.0.0) LIMRES(PLTYPE) = 0.0
      IF (LIMRES(PLTYPE).GT.99.9) LIMRES(PLTYPE) = 99.9

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 300, ICOL = 1, 4
          CALL GETCOL(COLPLT(PLTYPE,ICOL),LINE,COLNAM,MXCOLR)
 300  CONTINUE

C---- 9. RMS distances from planarity

C---- Find the planar groups key-word
      CALL FINKEY('9. RMS distances',16,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = 3

C---- Plot options

C---- Background shading (Y/N)?
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          BSHADE(PLTYPE) = .TRUE.
      ELSE
          BSHADE(PLTYPE) = .FALSE.
      ENDIF

C---- RMS distance from planarity for highlighting for planar groups
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      LIMPLN(1) = RNUMB
      IF (LIMPLN(1).LT.0.0) LIMPLN(1) = 0.0
      IF (LIMPLN(1).GT.99.9) LIMPLN(1) = 99.9

C---- RMS distance from planarity for highlighting for other groups
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      LIMPLN(2) = RNUMB
      IF (LIMPLN(2).LT.0.0) LIMPLN(2) = 0.0
      IF (LIMPLN(2).GT.99.9) LIMPLN(2) = 99.9

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 400, ICOL = 1, 4
          CALL GETCOL(COLPLT(PLTYPE,ICOL),LINE,COLNAM,MXCOLR)
 400  CONTINUE

C---- 10. Distorted geometry plots

C---- Find the distorted geometry key-word
      CALL FINKEY('10. Distorted geometry',22,LINE,FINERR)
      IF (FINERR) GO TO 990
      PLTYPE = 4

C---- Plot options

C---- Deviations from ideal bond-length (A)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      DGLIML = RNUMB
      IF (DGLIML.LT.0.0) DGLIML = 0.0
      IF (DGLIML.GT.99.9) DGLIML = 99.9

C---- Deviations from ideal bond angles (degrees)
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      DGLIMA = RNUMB
      IF (DGLIMA.LT.0.0) DGLIMA = 0.0
      IF (DGLIMA.GT.99.9) DGLIMA = 99.9

C---- RMS dists from plane for ring atoms
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      DGLIMR = RNUMB
      IF (DGLIMR.LT.0.0) DGLIMR = 0.0
      IF (DGLIMR.GT.99.9) DGLIMR = 99.9

C---- RMS dists from plane for other atoms
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,*,END=902,ERR=904) RNUMB
      READ(10,*,END=902,ERR=904) RNUMB
CHECK v.3.1<--
      DGLIMP = RNUMB
      IF (DGLIMP.LT.0.0) DGLIMP = 0.0
      IF (DGLIMP.GT.99.9) DGLIMP = 99.9

C---- Produce a black-and-white or colour PostScript file
      LINE = LINE + 1
CHECK v.3.1-->
C      READ(1,120,END=902,ERR=904) YESNO
      READ(10,120,END=902,ERR=904) YESNO
CHECK v.3.1<--
      IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
          INCOLR(PLTYPE) = .TRUE.
      ELSE
          INCOLR(PLTYPE) = .FALSE.
      ENDIF

C---- Get each of the user-defined colours for this plot
      DO 500, ICOL = 1, 4
          CALL GETCOL(COLPLT(PLTYPE,ICOL),LINE,COLNAM,MXCOLR)
 500  CONTINUE

CHECK v.3.2-->
C---- Find whether file-handles are required or not
      CALL FINKEY('File-handles',12,LINE,FINERR)
      IF (.NOT.FINERR) THEN

C----     See whether the file-handle is required
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              WITHAN = .TRUE.
          ELSE
              WITHAN = .FALSE.
          ENDIF

C----     See whether plot filename to be printed on the plot itself
          LINE = LINE + 1
          READ(10,*,END=902,ERR=904)
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              PLABEL = .TRUE.
          ELSE
              PLABEL = .FALSE.
          ENDIF

C----     See whether all pages of same plot to be combined in one
C         paginated PostScript file
          LINE = LINE + 1
          READ(10,120,END=902,ERR=904) YESNO
          IF (YESNO.EQ.'Y' .OR. YESNO.EQ.'y') THEN
              COMBPS = .TRUE.
          ELSE
              COMBPS = .FALSE.
          ENDIF
      ENDIF
CHECK v.3.2<--

C---- If all plots are required to be in colour, then set all the
C     appropriate flags to TRUE
      IF (ALLCOL) THEN
          DO 600, PLTYPE = 1, 4
              INCOLR(PLTYPE) = .TRUE.
 600      CONTINUE
      ENDIF

      GO TO 999


C---- Errors reading parameter file
900   CONTINUE
      PRINT*, '* Parameters file (procheck.prm) not found.'
      GO TO 990

 901  CONTINUE
      PRINT*, '* Failed to find correct version number in parameters ',
     -        'file, procheck.prm'
      GO TO 990

902   CONTINUE
      PRINT*, '* Premature end of parameters file, procheck.prm, ',
     -        'encountered at line', LINE
      GO TO 990

904   CONTINUE
      PRINT*, '* Error reading parameter file, procheck.prm, at ',
     -    'line', LINE
      GO TO 990

C---- Close the parameter file
 990  CONTINUE
      PRINT*, '* Default values have been assumed for the ',
     -    'parameters'
      CLOSE(10)

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETCOD  -  Read in the name of the .lan file to be processed
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETCOD

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
C      INTEGER       LINE
      CHARACTER*1   LOWERA
      CHARACTER*26  UPPER
      INTEGER       LINE, N
CHECK v.3.2<--
      LOGICAL       IERROR

CHECK v.3.2-->
      DATA  LOWERA / 'a' /
      DATA  UPPER  / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
CHECK v.3.2<--

C---- Initialise variables
      LINE = 0

C---- Accept name of original .pdb file holding the structure
      PRINT*, 'Enter filename containing coordinates of structure'
      READ(*,110,ERR=900) PDBFIL
 110  FORMAT(A)

C---- Accept chain-ID
      PRINT*, 'Enter required chain-ID, or leave blank for all'
      READ(*,110,ERR=906) CHAIN

CHECK v.3.2-->
C---- Convert chain ID to upper-case if necessary
      N = ICHAR(CHAIN) - ICHAR(LOWERA) + 1
      IF (N.GE.1 .AND. N.LE.26) CHAIN = UPPER(N:N)
CHECK v.3.2<--

C---- Peel off directory path and extension
CHECK v.3.6.4-->
C      CALL GETNAM(PDBFIL,ISTART,IEND,IERROR)
      CALL GETNAM(PDBFIL,FNAMLN,ISTART,IEND,IERROR)
CHECK v.3.6.4<--
      IF (IERROR) GO TO 990

C---- Form names of other files that will be required in default directory
      ILEN = IEND - ISTART + 1
      BRCODE = PDBFIL(ISTART:IEND)
      FILLAN = PDBFIL(ISTART:IEND) // '.lan'
      FILPLN = PDBFIL(ISTART:IEND) // '.pln'
      FILPS = BRCODE
CHECK v.3.2-->
      FILSUM = PDBFIL(ISTART:IEND) // '.sum'
CHECK v.3.2<--
CHECK v.3.3.2-->
      FILHTM = PDBFIL(ISTART:IEND) // '.html'
CHECK v.3.3.2<--
      PSLEN = IEND - ISTART + 1
      BLEN = PSLEN
      IF (CHAIN.NE.' ') THEN
          BRCODE = BRCODE(1:BLEN) // ' - Chain ' // CHAIN
          BLEN = BLEN + 10
          IF (BLEN.GT.78) BLEN = 78
      ENDIF

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Data error in entered filename'
      GO TO 990

 906  CONTINUE
      PRINT*, '*** ERROR. Data error in entered chain-ID'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE GETLAN  -  Read through the bond lengths and angles file
C                        to calculate minimu, maxmimum, and mean values
C
C----------------------------------------------------------------------+---

      SUBROUTINE GETLAN

      INCLUDE 'bplot.inc'

      CHARACTER*1   ALP, INCHN
      CHARACTER*3   RESNAM
      CHARACTER*80  IREC
      INTEGER       IMAIN, IPLANE, IPOS, IRESID, LINE, NGAP
      REAL          SEP, VALUE

C---- Initialise variables
      LINE = 0

C---- Open lengths and angles file, <filename>.lan
      OPEN(UNIT=2, FILE=FILLAN, STATUS='OLD', FORM='FORMATTED',
     -    ACCESS='SEQUENTIAL',
CVAX     -    READONLY,
     -    ERR=900)

C---- Read through the header records to pick up the Engh & Huber
C     means and st devs for bond lengths and bond angles derived from
C     analysis of small molecule data
      DO 40, IMAIN = 1, NMAIN
          READ(2,20,END=902,ERR=904) ALP, LENANG(IMAIN),
     -        ENCODE(IMAIN), ENDESC(IMAIN), ENGMEA(IMAIN),
     -        ENGSTD(IMAIN)
 20       FORMAT(A1,1X,A8,6X,A13,4X,A16,2F8.3)
          LINE = LINE + 1
          AL(IMAIN) = ALP
          IF (AL(IMAIN).NE.'A' .AND. AL(IMAIN).NE.'L') GO TO 903
 40   CONTINUE

C---- Read through the header record to read in the planar groups
      DO 60, IPLANE = 1, NPLANE
          IPOS = NMAIN + IPLANE
          READ(2,50,END=902,ERR=904) ALP, NPATOM(IPLANE), PNAME(IPLANE)
 50       FORMAT(A1,1X,I4,27X,A3)
          AL(IPOS) = ALP
          IF (AL(IPOS).NE.'P') GO TO 905
 60   CONTINUE

C---- Initialise calculated parameters, setting minimum and maximum
C     values to Engh & Huber small-molecule data
      DO 80, IMAIN = 1, NMAIN
          MCHMEA(IMAIN) = 0.0
          MCHSTD(IMAIN) = 0.0
          MCHNUM(IMAIN) = 0
          IF (AL(IMAIN).EQ.'L') THEN
              NGAP = NGAPL
              SEP = LSEP
          ELSE
              NGAP = NGAPA
              SEP = ASEP
          ENDIF
          MCHMIN(IMAIN) = ENGMEA(IMAIN) - NGAP * SEP / 2.0
 80   CONTINUE

C---- Initialise values for planar groups
      DO 100, IPLANE = 1, NPLANE
          IPOS = NMAIN + IPLANE
          MCHMEA(IPOS) = 0.0
          MCHSTD(IPOS) = 0.0
          MCHNUM(IPOS) = 0
          MCHMAX(IPOS) = 0.05
          MCHMIN(IPOS) = 0.0
          NBARS(IPOS) = MCHMAX(IPOS) / PWIDTH
          NTICKS(IPOS) = 6
 100  CONTINUE

C---- Loop while reading in records
 200  CONTINUE
          READ(2,220,END=500,ERR=904) IREC
 220      FORMAT(A)

C----     Read in the data from the record
          READ(IREC,240,ERR=906) IRESID, INCHN, RESNAM, IMAIN, VALUE
 240      FORMAT(I6,A1,5X,A3,I2,F9.4)
          LINE = LINE + 1

C----     Only process this residue if it belongs to the required chain
          IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN

C----         Check whether this is a planar group record
              IF (IREC(29:33).EQ.'PLANE') THEN
                  IPLANE = IMAIN

C----             Check that this is a valid planar group
                  IF (IPLANE.GT.0 .AND. IPLANE.LE.NPLANE) THEN

C----                 Accumulate mean values
                      IMAIN = NMAIN + IPLANE
                      MCHMEA(IMAIN) = MCHMEA(IMAIN) + VALUE
                      MCHNUM(IMAIN) = MCHNUM(IMAIN) + 1
                      TOPLOT(3) = .TRUE.

C----                 If the value qualifies it for the "distorted"
C                     geometry plot, increment count of those
                      IF (NPATOM(IPLANE).EQ.4) THEN
                          IF (VALUE.GT.DGLIMP)
     -                        TODO(3) = TODO(3) + 1
                      ELSE
                          IF (VALUE.GT.DGLIMR)
     -                        TODO(3) = TODO(3) + 1
                      ENDIF
                  ENDIF

C----         If not a planar group, must be a bond length or angle
              ELSE

C----             Check that this is a valid length/angle
                  IF (IMAIN.GT.0 .AND. IMAIN.LE.NMAIN) THEN

C----                 Accumulate mean values
                      MCHMEA(IMAIN) = MCHMEA(IMAIN) + VALUE
                      MCHNUM(IMAIN) = MCHNUM(IMAIN) + 1

C----                 If the value qualifies it for the "distorted"
C                     geometry plot, increment count of those
                      IF (AL(IMAIN).EQ.'L') THEN
                          TOPLOT(1) = .TRUE.
                          IF (ABS(VALUE - ENGMEA(IMAIN)).GT.DGLIML)
     -                        TODO(1) = TODO(1) + 1
                      ELSE
                          TOPLOT(2) = .TRUE.
                          IF (ABS(VALUE - ENGMEA(IMAIN)).GT.DGLIMA)
     -                        TODO(2) = TODO(2) + 1
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF

C---- Loop back for next record in file
      GO TO 200

C---- End of file reached
 500  CONTINUE

C---- Calculate mean values
      DO 800, IMAIN = 1, NALP
          IF (MCHNUM(IMAIN).GT.0) THEN
              MCHMEA(IMAIN) = MCHMEA(IMAIN) / REAL(MCHNUM(IMAIN))
          ENDIF
 800  CONTINUE
      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Unable to open .lan file'
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Premature EOF in .lan file at line:',
     -    LINE + 1
      GO TO 990

 903  CONTINUE
      PRINT*, '*** ERROR in bond length/angle parameters in .lan ',
     -    'file at line:', LINE, '   [', ALP, ']'
      GO TO 990

 904  CONTINUE
      PRINT*, '*** ERROR. Error reading .lan file at line:', LINE + 1
      GO TO 990

 905  CONTINUE
      PRINT*, '*** ERROR in planar group parameters in .lan ',
     -    'file at line:', LINE, '   [', ALP, ']'
      GO TO 990

 906  CONTINUE
      PRINT*, '*** ERROR. Data error in .lan file at line:', LINE + 1
      PRINT*, IREC
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE HPLOTS  -  Initialise variables for histogram plots
C
C----------------------------------------------------------------------+---

      SUBROUTINE HPLOTS

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
      CHARACTER*79  BLNKLN
      DATA BLNKLN( 1:40) / ' |                                      ' /
      DATA BLNKLN(41:79) / '                                      |'  /
CHECK v.3.2<--

C---- Compute bounds for each plot
      CALL HBOUND
      IF (IFAIL) GO TO 999

C---- Count up the numbers of values in each histogram bar
      CALL HCOUNT
      IF (IFAIL) GO TO 999

C---- Plot the graphs for the bond lengths
      IF (PLOTBL .AND. TOPLOT(1)) CALL BARPLT('L')

C---- Plot the graphs for the bond angles
      IF (PLOTBA .AND. TOPLOT(2)) CALL BARPLT('A')

C---- Plot the graphs for the planar groups
      IF (PLOTPL .AND. TOPLOT(3)) CALL BARPLT('P')

CHECK v.3.2-->
C---- Write out blank line to summary file
      IF (TOPLOT(1) .OR. TOPLOT(2) .OR. TOPLOT(3)) THEN
          WRITE(14,100) BLNKLN
 100      FORMAT(A)
      ENDIF
CHECK v.3.2<--

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE HBOUND  -  Compute bounds for each bond length/bond angle
C
C----------------------------------------------------------------------+---

      SUBROUTINE HBOUND

      INCLUDE 'bplot.inc'

      INTEGER       IMAIN, IPOS, NGAP
      REAL          FPOS, SEP, WIDTH

C---- Loop through all the main chain bond lengths and angles
      DO 200, IMAIN = 1, NMAIN

C----     Determine whether this is a bond length or bond angle and
C         use the appropriate histogram-bar width
          IF (AL(IMAIN).EQ.'L') THEN
              FPOS = FPOSL
              NGAP = NGAPL
              SEP = LSEP
              WIDTH = LWIDTH
          ELSE
              FPOS = FPOSA
              NGAP = NGAPA
              SEP = ASEP
              WIDTH = AWIDTH
          ENDIF

C----     Adjust minimum and maximum values so that range is a
C         sensible one and that starts and ends on an integral
C         number of bar-widths
          IPOS = MCHMIN(IMAIN) / FPOS
          MCHMIN(IMAIN) = IPOS * FPOS
          MCHMAX(IMAIN) = MCHMIN(IMAIN) + NGAP * SEP

C----     Calculate the number of bars and ticks this gives
          NBARS(IMAIN) = (MCHMAX(IMAIN) - MCHMIN(IMAIN)) / WIDTH + 0.1
          NTICKS(IMAIN) = (MCHMAX(IMAIN) - MCHMIN(IMAIN)) / SEP + 1.1

C----     If this number exceeds the maximum allowed, then have not
C         allowed a big enough array in the program. Programmer's fault!
          IF (NBARS(IMAIN).GT.MXBARS) THEN
              PRINT*, '*** PROGRAM ERROR! Array parameter MXBARS is ',
     -            'too small:', MXBARS, NBARS(IMAIN), IMAIN
              PRINT*, '    Adjust in bplot.inc and recompile'
              IFAIL = .TRUE.
              RETURN
          ENDIF
 200  CONTINUE

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE HCOUNT  -  Count up the numbers of lengths/angles in each
C                        histogram bar
C
C----------------------------------------------------------------------+---

      SUBROUTINE HCOUNT

      INCLUDE 'bplot.inc'

      CHARACTER*1   INCHN
      CHARACTER*80  IREC
      INTEGER       IBAR, IMAIN, IPLANE, LINE
      REAL          VALUE, WIDTH

C---- Initialise variables
      REWIND(2)
      LINE = 0
      DO 50, IMAIN = 1, NALP
          MAXFRQ(IMAIN) = 0
          DO 30, IBAR = 1, MXBARS + 2
              BCOUNT(IBAR,IMAIN) = 0
 30       CONTINUE
 50   CONTINUE

C---- Read through the header records to skip
      DO 100, IMAIN = 1, NALP
          READ(2,*,END=900)
          LINE = LINE + 1
 100  CONTINUE

C---- Loop through the values in the .lan file
 200  CONTINUE

C----     Read in the next record
          READ(2,220,END=500,ERR=904) IREC
 220      FORMAT(A)

C----     Read in the data from the record
          READ(IREC,240,ERR=906) INCHN, IMAIN, VALUE
 240      FORMAT(6X,A1,8X,I2,F9.4)
          LINE = LINE + 1

C----     Only process this residue if it belongs to the required chain
          IF (CHAIN.EQ.' ' .OR. INCHN.EQ.CHAIN) THEN

C----         Check whether this is a planar group
              IF (IREC(29:33).EQ.'PLANE') THEN
                  IPLANE = IMAIN

C----             Check that this is a valid planaer group
                  IF (IPLANE.GT.0 .AND. IPLANE.LE.NPLANE) THEN
                      IMAIN = NMAIN + IPLANE
                  ELSE
                      IMAIN = 0
                  ENDIF
              ENDIF

C----         Check that the length/angle/plane type is valid
              IF (IMAIN.GT.0 .AND. IMAIN.LE.NALP) THEN

C----             Check whether this is a bond length, angle, or planar
C                 group
                  IF (AL(IMAIN).EQ.'L') THEN
                      WIDTH = LWIDTH
                  ELSE IF (AL(IMAIN).EQ.'A') THEN
                      WIDTH = AWIDTH
                  ELSE
                      WIDTH = PWIDTH
                  ENDIF

C----             Determine in which histogram bar this value falls
                  IBAR = 1 + (VALUE - MCHMIN(IMAIN)) / WIDTH
                  IF (IBAR.LT.1) THEN
                      IBAR = MXBARS + 1
                  ELSE IF (IBAR.GT.NBARS(IMAIN)) THEN
                      IBAR = MXBARS + 2
                  ENDIF

C----             Increment count of values in this bar and update
C                 maximum frequency for this graph
                  BCOUNT(IBAR,IMAIN) = BCOUNT(IBAR,IMAIN) + 1
                  MAXFRQ(IMAIN) = MAX(BCOUNT(IBAR,IMAIN),
     -                MAXFRQ(IMAIN))
              ENDIF
          ENDIF

C---- Loop back for next record in file
      GO TO 200

C---- End of file reached
 500  CONTINUE

      GO TO 999

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Premature EOF in .lan file at line:',
     -    LINE + 1
      GO TO 990

 904  CONTINUE
      PRINT*, '*** ERROR. Error reading .lan file at line:', LINE + 1
      GO TO 990

 906  CONTINUE
      PRINT*, '*** ERROR. Data error in .lan file at line:', LINE + 1
      PRINT*, IREC
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE BARPLT  -  Plot this set of graphs
C
C----------------------------------------------------------------------+---

      SUBROUTINE BARPLT(BTYPE)

      INCLUDE 'bplot.inc'

      INTEGER      NBOUND
      PARAMETER   (NBOUND = 18)

      CHARACTER*1  BTYPE
CHECK v.3.2-->
      CHARACTER*5   CNUMB
      CHARACTER*9   PLHAND
CHECK v.3.2<--
CHECK v.3.1-->
      CHARACTER*30  PLDESC
CHECK v.3.1<--
CHECK v.3.2-->
      CHARACTER*60  PTITLE
      CHARACTER*79  BLNKLN, SUMLIN
CHECK v.3.2<--
      INTEGER      IACROS, IBOUND, IDOWN, IMAIN, MFREQ, IPAGE, NDECPT,
CHECK v.3.2-->
C     -             NTICKX, NTICKY, TBOUND(NBOUND), TICKY(NBOUND)
     -             NHIGHL, NOFFGR, NTICKX, NTICKY, NTOTAL, NWITHN,
     -             TBOUND(NBOUND), TICKY(NBOUND)
CHECK v.3.2<--
CHECK v.3.2-->
C      LOGICAL      DONE, NOEND, NUMBEX, NUMBEY, ZEROS
C      REAL         SCALEX,WIDTH,  XL, XMAX, XR, XSTART,
C     -             YB, YMIN, YT, YTOP
      LOGICAL      DONE, FIRST, LAST, NOEND, NUMBEX, NUMBEY, ZEROS
      REAL         PERCEN, SCALEX, WIDTH,  XL, XMAX, XR, XSTART, YB,
     -             YMIN, YT, YTOP
CHECK v.3.2<--

CHECK v.3.2-->
      DATA BLNKLN( 1:40) / ' |                                      ' /
      DATA BLNKLN(41:79) / '                                      |'  /
CHECK v.3.2<--
      DATA TBOUND / 3, 5, 8, 10, 12, 15, 20, 25, 30, 40, 50, 60, 70,
     -             80, 90, 100, 150, 200 /
      DATA TICKY  / 4, 6, 5,  6,  7,  6,  5,  6,  7,  5,  6,  7,  8,
     -              5,  4,   6,   6,   5 /

C---- Initialise variables according to the type of plot
      IF (BTYPE.EQ.'L') THEN
          HEADIN = 'Main-chain bond lengths'
          HLEN = 23
          NDECPT = 2
          PLTYPE = 1
          WIDTH = LWIDTH
CHECK v.3.1-->
          PLDESC = HEADIN
CHECK v.3.1<--
CHECK v.3.2-->
          PLHAND = 'bondlenth'
          PTITLE = PLDESC
CHECK v.3.2<--
      ELSE IF (BTYPE.EQ.'A') THEN
          HEADIN = 'Main-chain bond angles'
          HLEN = 22
          NDECPT = 0
          PLTYPE = 2
          WIDTH = AWIDTH
CHECK v.3.1-->
          PLDESC = HEADIN
CHECK v.3.1<--
CHECK v.3.2-->
          PLHAND = 'bondangle'
          PTITLE = PLDESC
CHECK v.3.2<--
      ELSE
          HEADIN = 'RMS distances from planarity'
          HLEN = 28
          NDECPT = 2
          PLTYPE = 3
          WIDTH = PWIDTH
CHECK v.3.1-->
          PLDESC = HEADIN
CHECK v.3.1<--
CHECK v.3.2-->
          PLHAND = 'planargps'
          PTITLE = PLDESC
CHECK v.3.2<--
      ENDIF

C---- Calculate maximum frequency
      MFREQ = 0
      DO 100, IMAIN = 1, NALP
          IF (AL(IMAIN).EQ.BTYPE) THEN
              MAXFRQ(IMAIN) = MAXFRQ(IMAIN) + 1
              MFREQ = MAX(MAXFRQ(IMAIN),MFREQ)
          ENDIF
 100  CONTINUE

C---- Initialise variables
      IACROS = NACROS
      IDOWN = NDOWN
      IPAGE = 0
      NFGAPY = 5
      NUMBEX = .TRUE.
      NUMBEY = .TRUE.
      XSTART = BBOXX1 + XFQLMG
      YTOP = BBOXY2 - YFQTMG

CHECK v.3.2-->
C---- Initialise counts of points in the different parts of the graph
      NHIGHL = 0
      NOFFGR = 0
      NWITHN = 0
      FIRST = .TRUE.
      LAST = .FALSE.
CHECK v.3.2<--

C---- Calculate maximum y-value and number of ticks
      NTICKY = 2
      IBOUND = 0
      DONE = .FALSE.
 200  CONTINUE
          IBOUND = IBOUND + 1
          IF (MFREQ.LE.TBOUND(IBOUND)) THEN
              MFREQ = TBOUND(IBOUND)
              NTICKY = TICKY(IBOUND)
              DONE = .TRUE.
          ENDIF
      IF (.NOT.DONE .AND. IBOUND.LT.NBOUND) GO TO 200

C---- Loop through the graphs
      DO 1000, IMAIN = 1, NALP

C----     Check that this is the right graph type
          IF (AL(IMAIN).EQ.BTYPE) THEN

C----         Calculate x-axis scale
              SCALEX = XFQWID / (NBARS(IMAIN) * WIDTH)
              NTICKX = NTICKS(IMAIN)

C----         Increment graph-count
              IACROS = IACROS + 1
              IF (IACROS.GT.NACROS) THEN
                  IDOWN = IDOWN + 1

C----             If off the end of the page, start a new one
                  IF (IDOWN.GT.NDOWN) THEN

C----                 If this is not the first page, then finish off
C                     previous page
                      IF (IPAGE.GT.0) THEN
CHECK v.3.2-->
C                          CALL BAREND(BTYPE)
                          CALL BAREND(BTYPE,LAST)
CHECK v.3.2<--
                      ENDIF

C----                 Open new PostScript file and print headings
CHECK v.3.1-->
C                      CALL BARHED(IPAGE)
CHECK v.3.2-->
C                      CALL BARHED(IPAGE,PLDESC)
                      CALL BARHED(IPAGE,PLDESC,PLHAND,PTITLE,FIRST)
                      FIRST = .FALSE.
CHECK v.3.2<--
                      PLDESC = ' '
CHECK v.3.1<--
                      IDOWN = 1
                      XMAX = XSTART
                      YMIN = YTOP
                  ENDIF
                  IACROS = 1
              ENDIF

C----         Calculate graph position and draw axes
              XL = XSTART + (IACROS - 1) * (XFQWID + XDAYLT)
              XR = XL + XFQWID
              YT = YTOP - (IDOWN - 1) * YFQWID
              YB = YT - YFQWID + YDAYLT
              XMAX = MAX(XR,XMAX)
              YMIN = MIN(YB,YMIN)

C----         Draw in the shading
              CALL PSLWID(0.1)
              IF (BSHADE(PLTYPE)) THEN
                  CALL PSHADE(0.98,COLPLT(PLTYPE,2),RGB,MXCOLR,
     -                INCOLR(PLTYPE))
                  CALL PSBBOX(XL,YB,XL,YT,XR,YT,XR,YB)
              ENDIF

C----         Plot the axes
              CALL AXES(XL,XR,YB,YT,NTICKX - 1,NTICKY - 1,
     -            MCHMIN(IMAIN),MCHMAX(IMAIN),0.0,REAL(MFREQ),
     -            8.0,NDECPT,0,12.0,NUMBEX,NUMBEY,ZEROS,NOEND,.TRUE.)

C----         Plot the Engh & Huber mean and standard deviations
              CALL BARLIN(XL,XR,YB,YT,IMAIN,SCALEX)

C----         Plot the graph title
              CALL BARTXT(XL,XR,YB,YT,IMAIN)

C----         Plot the bar graph
CHECK v.3.2-->
C              CALL BARDRW(XL,YB,YT,SCALEX,IMAIN,WIDTH,MFREQ)
              CALL BARDRW(XL,YB,YT,SCALEX,IMAIN,WIDTH,MFREQ,NHIGHL,
     -            NWITHN)
CHECK v.3.2<--

C----         Plot marker indicating there are data points off the
C             graph
              CALL BAROFF(XL,XR,YB,YT,IMAIN)

CHECK v.3.2-->
C----         Increment counts of points off the graphs
              NOFFGR = NOFFGR + BCOUNT(MXBARS+1,IMAIN)
     -            + BCOUNT(MXBARS+2,IMAIN)
CHECK v.3.2<--
          ENDIF
 1000 CONTINUE

C---- Finish off the last page
CHECK v.3.2-->
C      IF (IPAGE.GT.0) CALL BAREND(BTYPE)
      LAST = .TRUE.
      IF (IPAGE.GT.0) CALL BAREND(BTYPE,LAST)
CHECK v.3.2<--

CHECK v.3.2-->
C---- Write the percentages of data points in good, bad, and terrible
C     regions out

C---- Blank out the output line
      SUMLIN = BLNKLN

C---- Prepare summary line's title according to type of distribution just
C     produced
      IF (BTYPE.EQ.'L') THEN
          SUMLIN(4:20) = 'M/c bond lengths:'
      ELSE IF (BTYPE.EQ.'A') THEN
          SUMLIN(4:20) = 'M/c bond angles: '
      ELSE
          SUMLIN(4:20) = 'Planar groups:   '
      ENDIF

C---- Insert text for remainder of the line
      SUMLIN(26:40) = '% within limits'
      SUMLIN(47:59) = '% highlighted'

C---- Calculate percentages and insert into line
      NTOTAL = NWITHN + NHIGHL + NOFFGR

C---- Percentage within the specified limits
      IF (NTOTAL.GT.0) THEN
          PERCEN = 100.0 * REAL(NWITHN) / REAL(NTOTAL)
      ELSE
          PERCEN = 0.0
      ENDIF
      WRITE(CNUMB,1010) PERCEN
 1010 FORMAT(F5.1)
      SUMLIN(21:25) = CNUMB

C---- Percentage highlighted
      IF (NTOTAL.GT.0) THEN
          PERCEN = 100.0 * REAL(NHIGHL + NOFFGR) / REAL(NTOTAL)
      ELSE
          PERCEN = 0.0
      ENDIF
      WRITE(CNUMB,1010) PERCEN
      SUMLIN(42:46) = CNUMB

C---- Number off the graph
      IF (NOFFGR.GT.0) THEN
          WRITE(CNUMB,1020) NOFFGR
 1020     FORMAT(I5)
          SUMLIN(63:67) = CNUMB
          SUMLIN(69:77) = 'off graph'
      ENDIF

C---- Determine whether to highlight the line with a + or a *
      IF (PERCEN.GT.40.0) THEN
          SUMLIN(1:1) = '+'
      ENDIF
      IF (NOFFGR.GT.0 .OR. PERCEN.GT.50.0) THEN
          SUMLIN(1:1) = '*'
      ENDIF
      IF (BTYPE.EQ.'P') THEN
          IF (PERCEN.GT.0.0) SUMLIN(1:1) = '+'
          IF (PERCEN.GT.10.0) SUMLIN(1:1) = '*'
      ENDIF

C---- Write the line out to the summary file
      WRITE(14,1060) SUMLIN
 1060 FORMAT(A)
CHECK v.3.2<--

      RETURN
      END

C--------------------------------------------------------------------------
C*****************************************************************************
C
C  SUBROUTINE BARLIN  -  Draw the mean and standard deviation lines
C
C----------------------------------------------------------------------+---

      SUBROUTINE BARLIN(XL,XR,YB,YT,IMAIN,SCALEX)

      INCLUDE 'bplot.inc'

      INTEGER       IMAIN, IPLANE
      REAL          CUTOFF, SCALEX, VALUE, X, XL, XR, YB, YT


C---- Initialise plot positions
      CALL PSLWID(0.1)

C---- For a planar group, draw dotted line depending on whether group
C     is a ring or not
      IF (IMAIN.GT.NMAIN) THEN
          IPLANE = IMAIN - NMAIN
          IF (NPATOM(IPLANE).EQ.4) THEN
              CUTOFF = LIMPLN(2)
          ELSE
              CUTOFF = LIMPLN(1)
          ENDIF
          X = XL + SCALEX * (CUTOFF - MCHMIN(IMAIN))
          CALL PSDASH(2)
          CALL PSLINE(X,YB,X,YT)
          CALL PSDASH(0)

C---- Otherwise, use Engh & Huber parameters
      ELSE

C----     Draw in mean
          X = XL + SCALEX * (ENGMEA(IMAIN) - MCHMIN(IMAIN))
          IF (X.GE.XL .AND. X.LE.XR) THEN
              CALL PSLINE(X,YB,X,YT)
          ENDIF

C----     Draw standard deviations either side
          VALUE = ENGMEA(IMAIN) - ENGSTD(IMAIN)
          X = XL + SCALEX * (VALUE - MCHMIN(IMAIN))
          IF (X.GE.XL .AND. X.LE.XR) THEN
              CALL PSDASH(2)
              CALL PSLINE(X,YB,X,YT)
              CALL PSDASH(0)
          ENDIF
          VALUE = ENGMEA(IMAIN) + ENGSTD(IMAIN)
          X = XL + SCALEX * (VALUE - MCHMIN(IMAIN))
          IF (X.GE.XL .AND. X.LE.XR) THEN
              CALL PSDASH(2)
              CALL PSLINE(X,YB,X,YT)
              CALL PSDASH(0)
          ENDIF
      ENDIF

      RETURN
      END

C----------------------------------------------------------------------+---
C*****************************************************************************
C
C  SUBROUTINE BARTXT  -  Print the graph headings and other text items
C
C----------------------------------------------------------------------+---

      SUBROUTINE BARTXT(XL,XR,YB,YT,IMAIN)

      INCLUDE 'bplot.inc'

      INTEGER       ELEN, IMAIN, IPLANE, LLEN
      LOGICAL       PLANE
      REAL          X1, X2, XC, XL, XR, YB, YT


C---- Initialise plot positions
      IF (IMAIN.GT.NMAIN) THEN
          IPLANE = IMAIN - NMAIN
          PLANE = .TRUE.
      ELSE
          PLANE = .FALSE.
      ENDIF
      X1 = XL
      X2 = XR
      XC = (XL + XR) / 2.0

C---- If this is a planar group, then plot appropriate heading
      IF (PLANE) THEN

C----     Plot the graph heading
          CALL PSCTXT(XC,YT + 8.0,8.0,PNAME(IPLANE))

C---- Otherwise, is a bond angle or length
      ELSE

C----     Determine length of heading
          LLEN = INDEX(LENANG(IMAIN),' ') - 1
          IF (LLEN.LE.0) LLEN = 1

C----     Determine length of subheading
          ELEN = 17
 100      CONTINUE
              ELEN = ELEN - 1
          IF (ELEN.GT.1 .AND. ENDESC(IMAIN)(ELEN:ELEN).EQ.' ') GO TO 100

C----     Plot the graph headings
          CALL PSCTXT(XC,YT + 16.0,10.0,LENANG(IMAIN)(1:LLEN))
          CALL PSCTXT(XC,YT + 8.0,8.0,ENDESC(IMAIN)(1:ELEN))
      ENDIF

C---- Plot y-axis heading
      CALL PSRCTX(XL - 20.0,(YB + YT) / 2.0,10.0,'Frequency')

      RETURN
      END

C----------------------------------------------------------------------+---
C*****************************************************************************
C
C  SUBROUTINE BARDRW  -  Plot the histogram bars for this graph
C
C----------------------------------------------------------------------+---

CHECK v.3.2-->
C      SUBROUTINE BARDRW(XL,YB,YT,SCALEX,IMAIN,WIDTH,MFREQ)
      SUBROUTINE BARDRW(XL,YB,YT,SCALEX,IMAIN,WIDTH,MFREQ,NHIGHL,NWITHN)
CHECK v.3.2<--

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
C      INTEGER       COLOUR, IBAR, IFREQ, IMAIN, IPLANE, MFREQ
      INTEGER       COLOUR, IBAR, IFREQ, IMAIN, IPLANE, MFREQ, NHIGHL,
     -              NWITHN
CHECK v.3.2<--
      LOGICAL       PLANE
      REAL          CUTOFF, DX, DIST1, DIST2, SCALEX, SHADE, WIDTH, X1,
     -              X2, XCUT, XL, Y1, Y2, YB, YHT, YT

C---- Initialise plot positions
      CALL PSLWID(0.1)
      IF (IMAIN.GT.NMAIN) THEN
          PLANE = .TRUE.
          IPLANE = IMAIN - NMAIN

C----     Calculate cutoff defining whether bars are to be shaded black.
          IF (NPATOM(IPLANE).EQ.4) THEN
              CUTOFF = LIMPLN(2)
          ELSE
              CUTOFF = LIMPLN(1)
          ENDIF
          XCUT = CUTOFF * SCALEX
      ELSE
          PLANE = .FALSE.
      ENDIF
      DX = WIDTH * SCALEX
      X1 = XL
      Y1 = YB
      YHT = YT - YB

C---- Plot the bars on the graph
      DO 300, IBAR = 1, NBARS(IMAIN)
          X2 = X1 + DX
          IFREQ = BCOUNT(IBAR,IMAIN)
          IF (IFREQ.GT.0) THEN

C----         Determine whether bar is to be shaded or not
              IF (PLANE) THEN
                  IF ((X1 + X2) / 2.0 - XL.GE.XCUT) THEN
                      COLOUR = COLPLT(PLTYPE,4)
                      SHADE = 0.0
CHECK v.3.2-->
CHECK v.3.5-->
C                      NHIGHL = NHIGHL + 1
                      NHIGHL = NHIGHL + IFREQ
CHECK v.3.5<--
CHECK v.3.2<--
                  ELSE
                      COLOUR = COLPLT(PLTYPE,3)
                      SHADE = 0.5
CHECK v.3.2-->
CHECK v.3.5-->
C                      NWITHN = NWITHN + 1
                      NWITHN = NWITHN + IFREQ
CHECK v.3.5<--
CHECK v.3.2<--
                  ENDIF
              ELSE
                  DIST1 = MCHMIN(IMAIN) + (X1 - XL) / SCALEX
                  DIST1 = ABS(ENGMEA(IMAIN) - DIST1) / ENGSTD(IMAIN)
                  DIST2 = MCHMIN(IMAIN) + (X2 - XL) / SCALEX
                  DIST2 = ABS(ENGMEA(IMAIN) - DIST2) / ENGSTD(IMAIN)
                  IF (DIST1.GT.LIMRES(PLTYPE)
     -                .AND. DIST2.GT.LIMRES(PLTYPE)) THEN
                      COLOUR = COLPLT(PLTYPE,4)
                      SHADE = 0.0
CHECK v.3.2-->
CHECK v.3.5-->
C                      NHIGHL = NHIGHL + 1
                      NHIGHL = NHIGHL + IFREQ
CHECK v.3.5<--
CHECK v.3.2<--
                  ELSE
                      COLOUR = COLPLT(PLTYPE,3)
                      SHADE = 0.5
CHECK v.3.2-->
CHECK v.3.5-->
C                      NWITHN = NWITHN + 1
                      NWITHN = NWITHN + IFREQ
CHECK v.3.5<--
CHECK v.3.2<--
                  ENDIF
              ENDIF
              Y2 = Y1 + YHT * REAL(IFREQ) / REAL(MFREQ)
              IF (Y2.GT.YT) Y2 = YT
              CALL PSHADE(SHADE,COLOUR,RGB,MXCOLR,INCOLR(PLTYPE))
              CALL PSBBOX(X1,Y1,X2,Y1,X2,Y2,X1,Y2)
          ENDIF
          X1 = X2
 300  CONTINUE

      RETURN
      END

C----------------------------------------------------------------------+---
C*****************************************************************************
C
C  SUBROUTINE BAROFF  -  Plot markers showing that there are data
C                        points off the scales of the graph
C
C----------------------------------------------------------------------+---

      SUBROUTINE BAROFF(XL,XR,YB,YT,IMAIN)

      INCLUDE 'bplot.inc'

      CHARACTER*5   LABEL
      INTEGER       IFROM, IMAIN
      REAL          XL, XR, XT1, XT2, YB, YMID, YT, YT1, YT2

C---- Initialise
      CALL PSLWID(0.1)
      YT1 = YB + 0.90 * (YT - YB)
      YT2 = YB + 0.95 * (YT - YB)
      YMID = (YT1 + YT2) / 2.0

C---- If there are points to the left of the graph, plot the marker
      IF (BCOUNT(MXBARS+1,IMAIN).NE.0) THEN
          GOTOFF = .TRUE.
          XT1 = XL + 0.03 * (XR - XL)
          XT2 = XL + 0.06 * (XR - XL)
          CALL PSHADE(0.0,COLPLT(PLTYPE,4),RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSTRIA(XT1,YMID,XT2,YT1,XT2,YT2)

C----     Write out the number off the scale
          WRITE(LABEL,10) BCOUNT(MXBARS+1,IMAIN)
 10       FORMAT(I5)
          IFROM = 1
          IF (LABEL(1:1).EQ.' ') IFROM = 2
          IF (LABEL(2:2).EQ.' ') IFROM = 3
          IF (LABEL(3:3).EQ.' ') IFROM = 4
          IF (LABEL(4:4).EQ.' ') IFROM = 5
          CALL PSCTXT(XT2+5.0,YMID,8.0,LABEL(IFROM:5))
      ENDIF

C---- If there are points to the right of the graph, plot the marker
      IF (BCOUNT(MXBARS+2,IMAIN).NE.0) THEN
          GOTOFF = .TRUE.
          XT1 = XL + 0.95 * (XR - XL)
          XT2 = XL + 0.92 * (XR - XL)
          CALL PSHADE(0.0,COLPLT(PLTYPE,4),RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSTRIA(XT1,YMID,XT2,YT1,XT2,YT2)

C----     Write out the number off the scale
          WRITE(LABEL,10) BCOUNT(MXBARS+2,IMAIN)
          IFROM = 1
          IF (LABEL(1:1).EQ.' ') IFROM = 2
          IF (LABEL(2:2).EQ.' ') IFROM = 3
          IF (LABEL(3:3).EQ.' ') IFROM = 4
          IF (LABEL(4:4).EQ.' ') IFROM = 5
          CALL PSCTXT(XT2-5.0,YMID,8.0,LABEL(IFROM:5))
      ENDIF

      RETURN
      END

C----------------------------------------------------------------------+---
C**************************************************************************
C
C  SUBROUTINE BARHED  -  Start new page for frequency distribution plot
C
C----------------------------------------------------------------------+---

CHECK v.3.1-->
C      SUBROUTINE BARHED(IPAGE)
CHECK v.3.2-->
C      SUBROUTINE BARHED(IPAGE,PLDESC)
      SUBROUTINE BARHED(IPAGE,PLDESC,PLHAND,PTITLE,FIRST)
CHECK v.3.2<--
CHECK v.3.1<--

      INCLUDE 'bplot.inc'

      CHARACTER*2   PAGENO
      CHARACTER*7   PAGE
CHECK v.3.2-->
      CHARACTER*9   PLHAND
CHECK v.3.2<--
CHECK v.3.1-->
      CHARACTER*30  PLDESC
CHECK v.3.1<--
CHECK v.3.2-->
      CHARACTER*60  PTITLE
CHECK v.3.2<--
      INTEGER       IPAGE
CHECK v.3.2-->
      LOGICAL       FIRST
CHECK v.3.2<--
      REAL          DX, DY, GTGPOS, GTGSIZ, XCENTR, XSTART, YTOP

      PARAMETER    (DX = 3.0, DY = 2.0, GTGPOS = 5.0, GTGSIZ = 8.0)

C---- Open new PostScript file
CHECK v.3.1-->
C      CALL PSNAME(FILPS,PSLEN,IPLOT)
CHECK v.3.2-->
C      CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC)
CHECK v.3.2<--
CHECK v.3.1<--
CHECK v.3.2-->
C      CALL PSOPEN(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
C     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1))
      IF (.NOT.COMBPS .OR. FIRST) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,PLHAND,WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(PLTYPE),PTITLE,
C     -        IPAGE + 1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,
     -        IPAGE + 1)
CHECK v.3.4<--
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
CHECK v.3.4-->
C     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1),IPAGE + 1,PLABEL)
     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1),IPAGE + 1,PLABEL,.FALSE.)
CHECK v.3.4<--
CHECK v.3.2<--

C---- Initialise variables
      GOTOFF = .FALSE.
      XSTART = BBOXX1 + XFQLMG
      XCENTR = (BBOXX1 + BBOXX2) / 2.0
      YTOP = BBOXY2 - YFQTMG
      CALL PSLWID(0.1)

C---- Main graph heading
      CALL PSCTXT(XCENTR,YTOP + 66.0,30.0, HEADIN(1:HLEN))
      CALL PSCTXT(XCENTR,YTOP + 36.0,25.0,BRCODE(1:BLEN))

CHECK v.3.2-->
C---- Print program name in top left-hand corner
      CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK')
CHECK v.3.2<--

C---- Print page number
      IPAGE = IPAGE + 1
      WRITE(PAGENO,'(I2)') IPAGE
      PAGE = 'Page ' // PAGENO
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE BAREND  -  Finish current page
C
C----------------------------------------------------------------------+---

CHECK v.3.2-->
C      SUBROUTINE BAREND(BTYPE)
      SUBROUTINE BAREND(BTYPE,LAST)
CHECK v.3.2<--

      INCLUDE 'bplot.inc'

      CHARACTER*1   BTYPE
      CHARACTER*5   RINGDV, OTHDV
      CHARACTER*38  IREC
CHECK v.3.2-->
      LOGICAL       LAST
CHECK v.3.2<--
      REAL          XCENT, X1, X2, YMID, Y1, Y2

C---- Print explanatory note about highlighted residues
      XCENT = (BBOXX1 + BBOXX2) / 2.0
      X1 = BBOXX1 + 30.0
      Y1 = BBOXY1 + 30.0
      Y2 = Y1 + 0.05 * YFQWID
      YMID = (Y1 + Y2) / 2.0
      IF (BTYPE.EQ.'P') THEN
          CALL PSCTXT(XCENT,Y1 + 40.0,10.0,'Histograms showing RMS' //
     -        ' distances of planar atoms from best-fit plane.')
      ELSE
          WRITE(IREC,20) LIMRES(PLTYPE)
 20       FORMAT('Black bars > ',F4.1,' st. devs. from mean.')
          CALL PSTEXT(X1,YMID,10.0,IREC)
      ENDIF

C---- Print explanatory note about arrows at bottom of page
      IF (GOTOFF) THEN
          X1 = BBOXX1 + 235.0
          X2 = X1 + 0.03 * XFQWID
          IF (BTYPE.NE.'P') THEN
              CALL PSHADE(0.0,COLPLT(PLTYPE,4),RGB,MXCOLR,
     -            INCOLR(PLTYPE))
              CALL PSTRIA(X1,YMID,X2,Y1,X2,Y2)
              CALL PSCTXT(X1+12.0,YMID,10.0,'or')
          ENDIF
          X2 = X1 + 19.0
          X1 = X2 + 0.03 * XFQWID
          CALL PSHADE(0.0,COLPLT(PLTYPE,4),RGB,MXCOLR,INCOLR(PLTYPE))
          CALL PSTRIA(X1,YMID,X2,Y1,X2,Y2)
          CALL PSTEXT(X1+7.0,YMID,10.0,'signifies data points' //
     -        ' off the graph in the direction shown.')
      ENDIF

C---- Print explanatory note about lines at bottom of page
      X1 = BBOXX1 + 30.0
      Y1 = BBOXY1 + 20.0
      IF (BTYPE.EQ.'P') THEN
          WRITE(RINGDV,120) LIMPLN(1)
 120      FORMAT(F5.2)
          WRITE(OTHDV,120) LIMPLN(2)
          CALL PSCTXT(XCENT,Y1 + 40.0,10.0,'Black bars indicate lar' //
     -        'ge deviations from planarity: RMS dist >' // RINGDV //
     -        ' for rings, and >' // OTHDV // ' otherwise.')
      ELSE
          CALL PSTEXT(X1,Y1,10.0,'Solid and dashed lines represent' //
     -        ' the mean and standard deviation values as per Engh ' //
     -        '& Huber small-molecule data.')
      ENDIF

C---- Close the current PostScript file
CHECK v.3.2-->
C      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      CALL PSENDP
      IF (.NOT.COMBPS .OR. LAST) THEN
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF
CHECK v.3.2<--

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DISTGM  -  Plot distorted geometries: bond lengths, bond
C                        angles and planar groups
C
C----------------------------------------------------------------------+---

      SUBROUTINE DISTGM

      INCLUDE 'bplot.inc'

      INTEGER       IPAGE, NDONEA, NDONEL, NDONEP
CHECK v.3.2-->
      LOGICAL       LAST
CHECK v.3.2<--

C---- Initialise values
      IPAGE = 0
      NDONEA = 0
      NDONEL = 0
      NDONEP = 0
      PLTYPE = 4

C---- Plot distorted bond lengths
      CALL DGPLOT('L',IPAGE,NDONEA,NDONEL,NDONEP)
      IF (IFAIL) GO TO 999

C---- Plot distorted bond angles
      CALL DGPLOT('A',IPAGE,NDONEA,NDONEL,NDONEP)
      IF (IFAIL) GO TO 999

C---- Plot distorted planes
      CALL DGPLOT('P',IPAGE,NDONEA,NDONEL,NDONEP)
      IF (IFAIL) GO TO 999

C---- Finish off the last page
CHECK v.3.2-->
C      IF (IPAGE.GT.0) CALL DISEND
      LAST = .TRUE.
      IF (IPAGE.GT.0) CALL DISEND(LAST)
CHECK v.3.2<--

C---- Show total numbers of distorted bonds, etc
      PRINT*, '   * Distorted main-chain bonds: ', NDONEL
      PRINT*, '   * Distorted main-chain angles:', NDONEA
      PRINT*, '   * Distorted planar groups:    ', NDONEP

 999  CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DGPLOT  -  Plot this set of distorted geometries
C
C----------------------------------------------------------------------+---

      SUBROUTINE DGPLOT(BTYPE,IPAGE,NDONEA,NDONEL,NDONEP)

      SAVE

      INCLUDE 'bplot.inc'

      INTEGER       NAMINO
      PARAMETER    (NAMINO = 20)

CHECK v.3.2-->
C      CHARACTER*1   BTYPE, INCHN
C      CHARACTER*3   ANAME(NPLATM)
C      CHARACTER*3   LNAME(NAMINO), RESNAM, RNAME(NAMINO)
C      CHARACTER*5   SEQNO
      CHARACTER*1   BTYPE, INCHN, OTHCHN
      CHARACTER*3   ANAME(NPLATM), LNAME(NAMINO), OTHNAM, RESNAM,
     -              RNAME(NAMINO)
      CHARACTER*5   OTHSEQ, SEQNO
CHECK v.3.2<--
      CHARACTER*8   CONTD
CHECK v.3.1-->
      CHARACTER*30  PLDESC
CHECK v.3.1<--
      CHARACTER*120 IREC
      INTEGER       IACROS, IAMINO, IMAIN, IPAGE, LINE, NATOM, NDGACR,
     -              NDONE, NDONEA, NDONEL, NDONEP, NLEFT, RLEN
CHECK v.3.2-->
C      LOGICAL       ENDFIL, FOUND, PRHEAD
      LOGICAL       ENDFIL, FIRST, FOUND, LAST, PRHEAD
CHECK v.3.2<--
      REAL          COORD(3,NPLATM), DGLIM, DGX, DGY, DIFF, EVALUE,
     -              VALUE, XWIDTH, YHIGHT, YPOS, YTEST

      DATA LNAME  / 'Ala', 'Arg', 'Asn', 'Asp', 'Cys', 'Gln', 'Glu',
     -              'Gly', 'His', 'Ile', 'Leu', 'Lys', 'Met', 'Phe',
     -              'Pro', 'Ser', 'Thr', 'Trp', 'Tyr', 'Val' /

      DATA RNAME  / 'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU',
     -              'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE',
     -              'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL' /

CHECK v.3.1-->
      DATA PLDESC / 'Distorted geometry' /
CHECK v.3.1<--

CHECK v.3.2-->
      DATA FIRST  / .TRUE. /
CHECK v.3.2<--


C---- Initialise variables according to the type of plot
      IF (BTYPE.EQ.'L') THEN
          DGLIM = DGLIML
          HEADIN = 'Main-chain bond lengths'
          HLEN = 23
          NDGACR = NDGACL
          XWIDTH = DGWIDX / NDGACL
          YHIGHT = XWIDTH / DGASPL
          NLEFT = TODO(1)
      ELSE IF (BTYPE.EQ.'A') THEN
          DGLIM = DGLIMA
          HEADIN = 'Main-chain bond angles'
          HLEN = 22
          NDGACR = NDGACA
          XWIDTH = DGWIDX / NDGACA
          YHIGHT = XWIDTH / DGASPA
          NLEFT = TODO(2)
      ELSE
          HEADIN = 'Planar groups'
          HLEN = 13
          NDGACR = NDGACP
          XWIDTH = DGWIDX / NDGACP
          YHIGHT = XWIDTH / DGASPP
          NLEFT = TODO(3)
      ENDIF
CHECK v.3.2-->
      LAST = .FALSE.
CHECK v.3.2<--

C---- If plotting distorted planes, then open planes file
      IF (BTYPE.EQ.'P') THEN
          OPEN(UNIT=3, FILE=FILPLN, STATUS='OLD', FORM='FORMATTED',
     -        ACCESS='SEQUENTIAL',
CVAX     -        READONLY,
     -        ERR=900)
          LINE = 0

C---- Otherwise rewind the bond lengths/angles files, and skip the
C     header records
      ELSE
          REWIND(2)
          LINE = 0
          DO 100, IMAIN = 1, NALP
              READ(2,*,END=902)
              LINE = LINE + 1
 100      CONTINUE
      ENDIF

C---- Initialise variables
      CONTD = ' '
      DGX = 0.0
      ENDFIL = .FALSE.
      FOUND = .FALSE.
      IACROS = NDGACR
      NDONE = 0
      PRHEAD = .TRUE.

C---- Loop until end of appropriate file reached
 200  CONTINUE

C----     If plotting planar groups get the next group to be plotted
          IF (BTYPE.EQ.'P') THEN
              CALL REAPLN(LINE,VALUE,IMAIN,INCHN,RESNAM,SEQNO,FOUND,
     -            COORD,ANAME,NATOM,ENDFIL)
              IF (IFAIL) GO TO 999

C----     Otherwise, get the next bond length/angle to be plotted
          ELSE
              CALL REALAN(BTYPE,LINE,DGLIM,VALUE,EVALUE,IMAIN,INCHN,
CHECK v.3.2-->
C     -            RESNAM,SEQNO,ENDFIL)
     -            RESNAM,SEQNO,ENDFIL,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--
              IF (IFAIL) GO TO 999
              DIFF = ABS(VALUE - EVALUE)
              IF (.NOT.ENDFIL) THEN
                  FOUND = .TRUE.
              ELSE
                  FOUND = .FALSE.
              ENDIF
          ENDIF

C----     Skip this one if it doesn't belong to the required chain
          IF (CHAIN.NE.' ' .AND. INCHN.NE.CHAIN) FOUND = .FALSE.

C----     If have a valid value, then plot this distorted bond/angle
          IF (FOUND) THEN

C----         Increment x- and y-values for next box
              IACROS = IACROS + 1

C----         If at end of line, start new line
              IF (IACROS.GT.NDGACR) THEN

C----             Calculate y-position of bottom of box
                  YTEST = DGY - YHIGHT

C----             If printing a heading, add the size of that
                  IF (PRHEAD) YTEST = YTEST - DGTEX * DGWIDY

C----             If this is the last row of the current set of plots,
C                 then allow for size of explanatory note at bottom, too
                  IF (NLEFT.LE.NDGACR) THEN
                      YTEST = YTEST - DGNOTE * DGWIDY
                  ENDIF

C----             If this will fall off the bottom of the page, then
C                 start a new one
                  IF (YTEST.LT.DGMRGY) THEN

C----                 If this is not the first page, then finish off
C                     previous page
                      IF (IPAGE.GT.0) THEN
CHECK v.3.2-->
C                          CALL DISEND
                          CALL DISEND(LAST)
CHECK v.3.2<--
                      ENDIF

C----                 Open new PostScript file and set flag to print
C                     heading
CHECK v.3.1-->
C                      CALL DISHED(IPAGE)
                      CALL DISHED(IPAGE,PLDESC,FIRST)
                      FIRST = .FALSE.
                      PLDESC = ' '
CHECK v.3.1<--
                      DGY = DGMRGY + DGWIDY
                      PRHEAD = .TRUE.
                  ENDIF

C----             Print the heading if required
                  IF (PRHEAD) THEN
                      DGX = DGMRGX
                      DGY = DGY - DGTEX * DGWIDY
                      YPOS = DGY + DGTEX * DGWIDY * DGHDOF
                      CALL PSTEXT(DGX,YPOS,DGHDSZ,HEADIN(1:HLEN) //
     -                    CONTD)
                      CONTD = ' (contd)'
                      PRHEAD = .FALSE.
                  ENDIF

C----             Prepare for new row of boxes
                  DGY = DGY - YHIGHT
                  IACROS = 1
              ENDIF

C----         Calculate graph position and draw axes
              NDONE = NDONE + 1
              NLEFT = NLEFT - 1
              DGX = DGMRGX + (IACROS - 1) * XWIDTH
              CALL PSLWID(0.1)

C----         Change residue name to caps and lower case
              DO 300, IAMINO = 1, NAMINO
                  IF (RESNAM.EQ.RNAME(IAMINO)) RESNAM = LNAME(IAMINO)
CHECK v.3.2-->
                  IF (OTHNAM.EQ.RNAME(IAMINO)) OTHNAM = LNAME(IAMINO)
CHECK v.3.2<--
 300          CONTINUE

C----         Draw appropriate bond/angle/plane
              IF (BTYPE.EQ.'L') THEN
                  CALL DRWLIN(DGX,DGY,XWIDTH,YHIGHT,IMAIN,INCHN,RESNAM,
CHECK v.3.2-->
C     -                SEQNO,EVALUE,VALUE)
     -                SEQNO,EVALUE,VALUE,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--

              ELSE IF (BTYPE.EQ.'A') THEN
                  CALL DRWANG(DGX,DGY,XWIDTH,YHIGHT,IMAIN,INCHN,RESNAM,
CHECK v.3.2-->
C     -                SEQNO,EVALUE,VALUE)
     -                SEQNO,EVALUE,VALUE,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--
              ELSE
                  CALL DRWPLN(DGX,DGY,XWIDTH,YHIGHT,INCHN,RESNAM,SEQNO,
     -                VALUE,COORD,ANAME,NATOM)
              ENDIF
          ENDIF
      IF (.NOT.ENDFIL) GO TO 200

C---- Store how many distortions plotted, and print explanatory text, if
C     necessary
      IF (NDONE.GT.0) THEN
          IF (BTYPE.EQ.'L') THEN
              NDONEL = NDONE
              WRITE(IREC,420) DGLIML
 420          FORMAT('Bonds differing by > ',F4.2,'A from small-mole',
     -            'cule values. Values shown: "ideal", difference, a',
     -            'ctual')
              RLEN = 96
          ELSE IF (BTYPE.EQ.'A') THEN
              NDONEA = NDONE
              WRITE(IREC,440) DGLIMA
 440          FORMAT('Bond angles differing by >',F5.1,' degrees fro',
     -            'm small-molec values. Values shown: "ideal", actu',
     -            'al, diff.')
              RLEN = 101
          ELSE
              NDONEP = NDONE
              WRITE(IREC,460) DGLIMR, DGLIMP
 460          FORMAT('Sidechains with RMS dist. from planarity > ',
     -            F4.2,'A for rings, or > ',F4.2,'A otherwise. Value',
     -            ' shown is RMS dist.')
              RLEN = 106
          ENDIF

C----     Write the basis on which the plotted bonds have been selected
          DGX = DGMRGX
          DGY = DGY - DGNOTE * DGWIDY
          CALL PSTEXT(DGX,DGY,10.0,IREC(1:RLEN))
      ENDIF

      GO TO 999


C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR. Unable to open .pln file'
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Premature EOF in .lan file at line:',
     -    LINE + 1, '   [2]'
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DGINIT  -  Initialise parameters for plots of distorted
C                        geometry
C
C----------------------------------------------------------------------+---

      SUBROUTINE DGINIT

      INCLUDE 'bplot.inc'

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DISHED  -  Start new page for distorted geometry plot
C
C----------------------------------------------------------------------+---

CHECK v.3.1-->
C      SUBROUTINE DISHED(IPAGE)
CHECK v.3.2-->
C      SUBROUTINE DISHED(IPAGE,PLDESC)
      SUBROUTINE DISHED(IPAGE,PLDESC,FIRST)
CHECK v.3.2<--
CHECK v.3.1<--

      INCLUDE 'bplot.inc'

      CHARACTER*2   PAGENO
      CHARACTER*7   PAGE
CHECK v.3.1-->
      CHARACTER*30  PLDESC
CHECK v.3.1<--
CHECK v.3.2-->
      CHARACTER*60  PTITLE
CHECK v.3.2<--
      INTEGER       IPAGE
CHECK v.3.2-->
      LOGICAL       FIRST
CHECK v.3.2<--
      REAL          XCENTR, XSTART, YTOP

C---- Open new PostScript file
CHECK v.3.1-->
C      CALL PSNAME(FILPS,PSLEN,IPLOT)
CHECK v.3.2-->
C      CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC)
CHECK v.3.2<--
CHECK v.3.1<--
CHECK v.3.2-->
C      CALL PSOPEN(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
C     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1))
      PTITLE = 'Distorted geometry'
      IF (.NOT.COMBPS .OR. FIRST) THEN
          CALL PSNAME(FILPS,PSLEN,IPLOT,PLDESC,'distortgm',WITHAN)
CHECK v.3.4-->
C          CALL PSOPEN(FILPS,MXCOLR,RGB,INCOLR(PLTYPE),PTITLE,
C     -        IPAGE + 1)
          CALL PSOPEN(FILPS,MXCOLR,RGB,NCOLOR,INCOLR(PLTYPE),PTITLE,
     -        IPAGE + 1)
CHECK v.3.4<--
      ENDIF
      CALL PSPAGE(FILPS,BBOXX1,BBOXX2,BBOXY1,BBOXY2,MXCOLR,RGB,
CHECK v.3.4-->
C     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1),IPAGE + 1,PLABEL)
     -    INCOLR(PLTYPE),COLPLT(PLTYPE,1),IPAGE + 1,PLABEL,.FALSE.)
CHECK v.3.4<--
CHECK v.3.2<--

C---- Initialise variables
      XSTART = DGMRGX
      XCENTR = XSTART + DGWIDX / 2.0
      YTOP = DGMRGY + DGWIDY
      CALL PSLWID(0.1)

C---- Main graph heading
      CALL PSCTXT(XCENTR,YTOP + 36.0,30.0,'Distorted geometry')
      CALL PSCTXT(XCENTR,YTOP + 6.0,25.0,BRCODE(1:BLEN))

CHECK v.3.2-->
C---- Print program name in top left-hand corner
      CALL PSTEXT(BBOXX1 + 15.0,BBOXY2 - 10.0,10.0,'PROCHECK')
CHECK v.3.2<--

C---- Print page number
      IPAGE = IPAGE + 1
      WRITE(PAGENO,'(I2)') IPAGE
      PAGE = 'Page ' // PAGENO
      CALL PSCTXT(BBOXX2 - 40.0,BBOXY2 - 20.0,12.0,PAGE)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DISEND  -  Finish current page of distorted geometries
C
C----------------------------------------------------------------------+---

CHECK v.3.2-->
C      SUBROUTINE DISEND
      SUBROUTINE DISEND(LAST)
CHECK v.3.2<--

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
      LOGICAL       LAST
CHECK v.3.2<--

C---- Close the current PostScript file
CHECK v.3.2-->
C      CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      CALL PSENDP
      IF (.NOT.COMBPS .OR. LAST) THEN
          CALL PSCLOS(BBOXX1,BBOXX2,BBOXY1,BBOXY2)
      ENDIF
CHECK v.3.2<--

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE REALAN  -  Read through the .lan file until find the next
C                        bond length/angle with geometry that is
C                        sufficiently distorted to be plotted
C
C----------------------------------------------------------------------+---

      SUBROUTINE REALAN(BTYPE,LINE,DGLIM,VALUE,EVALUE,IMAIN,INCHN,
CHECK v.3.2-->
C     -            RESNAM,SEQNO,ENDFIL)
     -            RESNAM,SEQNO,ENDFIL,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--

      SAVE

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
C      CHARACTER*1   BTYPE, INCHN
C      CHARACTER*3   RESNAM
C      CHARACTER*5   SEQNO
      CHARACTER*1   BTYPE, INCHN, OTHCHN
      CHARACTER*3   OTHNAM, RESNAM
      CHARACTER*5   OTHSEQ, SEQNO
      CHARACTER*20  SPANDT
CHECK v.3.2<--
      CHARACTER*80  IREC
      INTEGER       IMAIN, IRESID, LINE
      LOGICAL       ENDFIL
      REAL          DGLIM, DIFF, EVALUE, VALUE

C---- Initialise variables
      VALUE = 0.0

C---- Loop while reading in records
 100  CONTINUE
          READ(2,120,END=500,ERR=900) IREC
 120      FORMAT(A)
          LINE = LINE + 1

C----     Check that this is not a planar group record
          IF (IREC(29:33).NE.'PLANE') THEN

C----         Read in the data from the record
              READ(IREC,140,ERR=902) IRESID, INCHN, SEQNO, RESNAM,
CHECK v.3.2-->
C     -            IMAIN, VALUE
C 140          FORMAT(I6,A1,A5,A3,I2,F9.4)
     -            IMAIN, VALUE, SPANDT
 140          FORMAT(I6,A1,A5,A3,I2,F9.4,A20)

C----         If this bond length/angle spans two residues, then
C             extract the appropriate residue names
              IF (SPANDT.NE.' ') THEN
                  READ(SPANDT,200) INCHN, SEQNO, RESNAM, OTHCHN,
     -                OTHSEQ, OTHNAM
 200              FORMAT(2(1X,A1,A5,A3))
              ELSE
                  OTHCHN = ' '
                  OTHSEQ = ' '
                  OTHNAM = ' '
              ENDIF
CHECK v.3.2<--

C----         Check that this is a valid length/angle
              IF (IMAIN.GT.0 .AND. IMAIN.LE.NMAIN) THEN

C----             Check that this is the required type (ie length/angle)
                  IF (AL(IMAIN).EQ.BTYPE) THEN

C----                 Calculate difference between value and Engh & Huber
C                     mean
                      EVALUE = ENGMEA(IMAIN)
                      DIFF = ABS(VALUE - EVALUE)
                      IF (DIFF.GT.DGLIM) GO TO 999
                  ENDIF
              ENDIF
          ENDIF

C---- Loop back for next record in file
      GO TO 100

C---- End of file reached
 500  CONTINUE
      ENDFIL = .TRUE.

      GO TO 999


C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR reading record from .lan file at line',
     -    LINE + 1
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Data error in .lan file at line:', LINE
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE REAPLN  -  Read through the .pln file until find the next
C                        distorted planar group
C
C----------------------------------------------------------------------+---

      SUBROUTINE REAPLN(LINE,RMS,LMAIN,LSTCHN,LSTRES,LSTSEQ,FOUND,
     -    COORD,ANAME,NATOM,ENDFIL)

      SAVE

      INCLUDE 'bplot.inc'

      CHARACTER*1   INCHN, LSTCHN
      CHARACTER*3   ANAME(NPLATM), ATNAM, RESNAM, LSTRES
      CHARACTER*5   LSTSEQ, SEQNO
      CHARACTER*80  IREC
CHECK v.3.2-->
C      INTEGER       IATOM, IMAIN, IRESID, LINE, LMAIN, LRESID, NATOM
      INTEGER       IATOM, IMAIN, LINE, LMAIN, NATOM
CHECK v.3.2<--
      LOGICAL       ENDFIL, FOUND
      REAL          COORD(3,NPLATM), DGLIM, RMS, RMSDIF, X, Y, Z

C---- Initialise variables
      FOUND = .FALSE.

C---- If first time, then read in first record
      IF (LINE.EQ.0) THEN
          READ(3,20,END=500,ERR=900) IREC
 20       FORMAT(A)
          LINE = LINE + 1
          IATOM = 0
          LSTSEQ = ' '
      ENDIF

C---- Loop while reading in records
 100  CONTINUE

C----     Read in data from the record
          READ(IREC,140,ERR=902) IMAIN, ATNAM, RESNAM, INCHN, SEQNO,
     -        X, Y, Z, RMSDIF
 140      FORMAT(9X,I2,2X,A3,1X,A3,1X,A1,A5,3X,3F8.3,6X,F8.4)

C----     Check whether this is a new residue
          IF (SEQNO.NE.LSTSEQ .OR. LINE.EQ.1 .OR. ENDFIL) THEN

C----         Check whether have a previous residue stored
              IF (IATOM.GT.0) THEN
                  NATOM = IATOM
                  IATOM = 0

C----             Check whether the previous residue warrants plotting
                  IF (LMAIN.GT.0 .AND. LMAIN.LE.NPLANE) THEN
                      IF (NPATOM(LMAIN).EQ.4) THEN
                          DGLIM = DGLIMP
                      ELSE
                          DGLIM = DGLIMR
                      ENDIF
                      IF (RMS.GT.DGLIM) THEN
                          FOUND = .TRUE.
                          GO TO 999
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF

C----     Store this atom
          IF (.NOT.ENDFIL) THEN
              IATOM = IATOM + 1
              IF (IATOM.LE.NPLATM) THEN
                  ANAME(IATOM) = ATNAM
                  COORD(1,IATOM) = X
                  COORD(2,IATOM) = Y
                  COORD(3,IATOM) = Z
                  LMAIN = IMAIN
CHECK v.3.2-->
C                  LRESID = IRESID
CHECK v.3.2<--
                  LSTCHN = INCHN
                  LSTRES = RESNAM
                  LSTSEQ = SEQNO
                  RMS = RMSDIF
              ENDIF

C----         Read the next record
              READ(3,20,END=500,ERR=900) IREC
              LINE = LINE + 1
          ELSE
              GO TO 999
          ENDIF

C---- Loop back to process this record
      GO TO 100

C---- End of file reached
 500  CONTINUE
      ENDFIL = .TRUE.
      GO TO 100

C---- Fatal errors
 900  CONTINUE
      PRINT*, '*** ERROR reading record from .pln file at line',
     -    LINE + 1
      GO TO 990

 902  CONTINUE
      PRINT*, '*** ERROR. Data error in .pln file at line:', LINE
      GO TO 990

990   CONTINUE
      IFAIL = .TRUE.

999   CONTINUE
      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DRWLIN  -  Draw distorted bond lengths
C
C----------------------------------------------------------------------+---

      SUBROUTINE DRWLIN(DGX,DGY,XWIDTH,YHIGHT,IMAIN,INCHN,RESNAM,
CHECK v.3.2-->
C     -    SEQNO,EVALUE,VALUE)
     -    SEQNO,EVALUE,VALUE,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
C      CHARACTER*1   INCHN
C      CHARACTER*3   RESNAM
C      CHARACTER*5   NUMBER, SEQNO
C      CHARACTER*10  RESID
C      INTEGER       DPOS, IMAIN, I1, I2, SPOS
      CHARACTER*1   INCHN, OTHCHN
      CHARACTER*3   OTHNAM, RESNAM
      CHARACTER*5   NUMBER, OTHSEQ, SEQNO
      CHARACTER*10  OTHID, RESID
      INTEGER       DPOS, IMAIN, I1, I2, OI1, OI2, SPOS
CHECK v.3.2<--
      REAL          BLUE, DGX, DGY, DY, EVALUE, GREEN, RED, VALUE,
     -              XHALF, XSTART, XWIDTH, X1, X2, YHIGHT, YSTART, Y1,
     -              Y2

C---- Initialise variables
      XSTART = DGX + (XWIDTH / DGLENL) * (DGLENL - EVALUE) / 2.0
      YSTART = DGY + 0.6 * YHIGHT

C---- Format the residue ID for printing
      RESID = INCHN // ' ' // RESNAM // SEQNO
      IF (INCHN.EQ.' ') THEN
          I1 = 3
      ELSE
          I1 = 1
      ENDIF
      IF (RESID(9:10).EQ.'  ') THEN
          I2 = 8
      ELSE IF (RESID(10:10).EQ.' ') THEN
          I2 = 9
      ELSE
          I2 = 10
      ENDIF

CHECK v.3.2-->
CC---- Print the residue name(s)
C      CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.275 * YHIGHT,10.0,
C     -    RESID(I1:I2))

C---- If this bond spans two residues, then form name of other residue
      IF (OTHNAM.NE.' ') THEN
          OTHID = OTHCHN // ' ' // OTHNAM // OTHSEQ
          IF (OTHCHN.EQ.' ') THEN
              OI1 = 3
          ELSE
              OI1 = 1
          ENDIF
          IF (OTHID(9:10).EQ.'  ') THEN
              OI2 = 8
          ELSE IF (OTHID(10:10).EQ.' ') THEN
              OI2 = 9
          ELSE
              OI2 = 10
          ENDIF
          CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.275 * YHIGHT,8.0,
     -        RESID(I1:I2) // ' - ' // OTHID(OI1:OI2))

C---- Otherwise print the single residue name
      ELSE
          CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.275 * YHIGHT,10.0,
     -        RESID(I1:I2))
      ENDIF
CHECK v.3.2<--

C---- Calculate the "ideal" bond
      CALL PSLWID(0.1)
      X1 = XSTART
      X2 = XSTART + (EVALUE / DGLENL) * XWIDTH
      XHALF = (X1 + X2) / 2.0
      DY = 0.1 * YHIGHT
      Y1 = YSTART - DY
      Y2 = YSTART + DY

C---- Plot the bond type
      DPOS = INDEX(LENANG(IMAIN),'-')
      SPOS = INDEX(LENANG(IMAIN),' ')
      DY = 0.25 * YHIGHT
      CALL PSCTXT(X1,YSTART + DY,8.0,LENANG(IMAIN)(1:DPOS-1))
      CALL PSCTXT(X2,YSTART + DY,8.0,LENANG(IMAIN)(DPOS+1:SPOS-1))

C---- Plot the "ideal bond
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,2))
          GREEN = RGB(2,COLPLT(PLTYPE,2))
          BLUE = RGB(3,COLPLT(PLTYPE,2))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSLINE(X1,YSTART,X2,YSTART)
      CALL PSLINE(X1,Y1,X1,Y2)
      CALL PSLINE(X2,Y1,X2,Y2)

C---- Plot the "ideal" length
      WRITE(NUMBER,110) EVALUE
 110  FORMAT(F5.3)
      CALL PSCTXT(XHALF,YSTART + DY,7.0,NUMBER)

C---- Plot the actual bond - end markers
      CALL PSLWID(0.2)
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,3))
          GREEN = RGB(2,COLPLT(PLTYPE,3))
          BLUE = RGB(3,COLPLT(PLTYPE,3))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      X1 = XSTART
      X2 = XSTART + (VALUE / DGLENL) * XWIDTH
      IF (X2.GT.DGX + XWIDTH) X2 = DGX + XWIDTH
      XHALF = (X1 + X2) / 2.0
      DY = 0.1 * YHIGHT / 2.0
      Y1 = YSTART - DY
      Y2 = YSTART + DY
      IF (INCOLR(PLTYPE)) CALL PSLINE(X1,Y1,X1,Y2)
      CALL PSLINE(X2,Y1,X2,Y2)

C---- Plot the actual bond
      CALL PSLWID(0.1)
      DY = DY / 2.0
      Y1 = YSTART - DY
      Y2 = YSTART + DY
      CALL PSHADE(0.0,COLPLT(PLTYPE,3),RGB,MXCOLR,INCOLR(PLTYPE))
      CALL PSBBOX(X1,Y1,X1,Y2,X2,Y2,X2,Y1)

C---- Plot the actual length
      DY = 0.12 * YHIGHT
      IF (INCOLR(PLTYPE)) THEN
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      WRITE(NUMBER,110) VALUE
      CALL PSCTXT(XHALF,YSTART - DY,8.0,NUMBER)

C---- Plot the difference between the ideal and the actual
      DY = 0.12 * YHIGHT
      WRITE(NUMBER,110) ABS(EVALUE - VALUE)
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,4))
          GREEN = RGB(2,COLPLT(PLTYPE,4))
          BLUE = RGB(3,COLPLT(PLTYPE,4))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSCTXT(XHALF,YSTART + DY,6.0,NUMBER)
      IF (INCOLR(PLTYPE)) CALL PSCOLB(0.0,0.0,0.0)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DRWANG  -  Draw distorted bond angles
C
C----------------------------------------------------------------------+---

      SUBROUTINE DRWANG(DGX,DGY,XWIDTH,YHIGHT,IMAIN,INCHN,RESNAM,
CHECK v.3.2-->
C     -    SEQNO,EVALUE,VALUE)
     -    SEQNO,EVALUE,VALUE,OTHCHN,OTHNAM,OTHSEQ)
CHECK v.3.2<--

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
C      CHARACTER*1   INCHN
C      CHARACTER*3   RESNAM
C      CHARACTER*5   NUMBER, SEQNO
      CHARACTER*1   INCHN, OTHCHN
      CHARACTER*3   OTHNAM, RESNAM
      CHARACTER*5   NUMBER, OTHSEQ, SEQNO
CHECK v.3.2<--
      CHARACTER*8   LANG
CHECK v.3.2-->
C      CHARACTER*10  RESID
C      INTEGER       DPOS1, DPOS2, IMAIN, I1, I2, SPOS
      CHARACTER*10  OTHID, RESID
      INTEGER       DPOS1, DPOS2, IMAIN, I1, I2, OI1, OI2, SPOS
CHECK v.3.2<--
      REAL          ANGLE, BLUE, DGX, DGY, DX, DY, EANGLE, EVALUE,
     -              EXTEND, GREEN, RED, VALUE, SCALE, XSTART, XWIDTH,
     -              X1, X2, YHIGHT, YSTART, Y1, Y2

      DATA EXTEND / 0.25 /

C---- Initialise variables
      ANGLE = VALUE * RADDEG
      EANGLE = EVALUE * RADDEG
      XSTART = DGX + XWIDTH / 2.0
      YSTART = DGY + 0.4 * YHIGHT
      SCALE = XWIDTH / DGLENA

CTESTING
C---- Draw a box around the region
C      CALL PSHADE(1.0)
C      CALL PSBBOX(DGX,DGY,DGX,DGY+YHIGHT,DGX+XWIDTH,DGY+YHIGHT,
C     -    DGX+XWIDTH,DGY)
CTESTING

C---- Print the residue ID
      RESID = INCHN // ' ' // RESNAM // SEQNO
      IF (INCHN.EQ.' ') THEN
          I1 = 3
      ELSE
          I1 = 1
      ENDIF
      IF (RESID(9:10).EQ.'  ') THEN
          I2 = 8
      ELSE IF (RESID(10:10).EQ.' ') THEN
          I2 = 9
      ELSE
          I2 = 10
      ENDIF

CHECK v.3.2-->
CC---- Print the residue name(s)
C      CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.2 * YHIGHT,10.0,
C     -    RESID(I1:I2))

C---- If this bond spans two residues, then form name of other residue
      IF (OTHNAM.NE.' ') THEN
          OTHID = OTHCHN // ' ' // OTHNAM // OTHSEQ
          IF (OTHCHN.EQ.' ') THEN
              OI1 = 3
          ELSE
              OI1 = 1
          ENDIF
          IF (OTHID(9:10).EQ.'  ') THEN
              OI2 = 8
          ELSE IF (OTHID(10:10).EQ.' ') THEN
              OI2 = 9
          ELSE
              OI2 = 10
          ENDIF
          CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.2 * YHIGHT,8.0,
     -        RESID(I1:I2) // ' - ' // OTHID(OI1:OI2))

C---- Otherwise print the single residue name
      ELSE
          CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.2 * YHIGHT,10.0,
     -        RESID(I1:I2))
      ENDIF
CHECK v.3.2<--

C---- Plot the bonds making up the "ideal" bond angle
      CALL PSLWID(0.1)
      X1 = (1.0 + EXTEND) * DGSTDL * SIN(EANGLE / 2.0)
      X2 = XSTART + X1 * SCALE
      X1 = XSTART - X1 * SCALE
      Y1 = (1.0 + EXTEND) * DGSTDL * COS(EANGLE / 2.0)
      Y1 = YSTART + Y1 * SCALE

C---- Plot the bond angle type, atoms 1 & 3
      LANG = LENANG(IMAIN)
      DPOS1 = INDEX(LANG,'-')
      LANG(DPOS1:DPOS1) = '*'
      DPOS2 = INDEX(LANG,'-')
      SPOS = INDEX(LANG,' ')
      DY = 0.08 * YHIGHT
      CALL PSCTXT(X1,Y1 + DY,8.0,LENANG(IMAIN)(1:DPOS1-1))
      CALL PSCTXT(X2,Y1 + DY,8.0,LENANG(IMAIN)(DPOS2+1:SPOS-1))

C---- Plot name of atom 2
      DY = 0.06 * YHIGHT
      CALL PSCTXT(XSTART,YSTART - DY,8.0,LENANG(IMAIN)(DPOS1+1:DPOS2-1))

C---- Plot the bonds making up the "ideal" bond angle
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,2))
          GREEN = RGB(2,COLPLT(PLTYPE,2))
          BLUE = RGB(3,COLPLT(PLTYPE,2))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSLINE(XSTART,YSTART,X1,Y1)
      CALL PSLINE(XSTART,YSTART,X2,Y1)

C---- Plot the "ideal" value
      DY = 0.1 * YHIGHT
      WRITE(NUMBER,110) EVALUE
 110  FORMAT(F5.1)
      CALL PSCTXT(XSTART,Y1 + DY,7.0,NUMBER)

C---- Plot the difference between the ideal and the actual
      DX = 0.05 * XWIDTH
      DY = 0.1 * YHIGHT
      WRITE(NUMBER,110) ABS(EVALUE - VALUE)
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,4))
          GREEN = RGB(2,COLPLT(PLTYPE,4))
          BLUE = RGB(3,COLPLT(PLTYPE,4))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSCTXT(X2 + DX,Y1 - DY,6.0,NUMBER)

C---- Plot the bonds of the actual bond angle
      CALL PSLWID(2.0)
      X1 = DGSTDL * SIN(EANGLE / 2.0)
      X1 = XSTART - X1 * SCALE
      X2 = DGSTDL * SIN(ANGLE - EANGLE / 2.0)
      X2 = XSTART + X2 * SCALE
      Y1 = DGSTDL * COS(EANGLE / 2.0)
      Y1 = YSTART + Y1 * SCALE
      Y2 = DGSTDL * COS(ANGLE - EANGLE / 2.0)
      Y2 = YSTART + Y2 * SCALE
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,3))
          GREEN = RGB(2,COLPLT(PLTYPE,3))
          BLUE = RGB(3,COLPLT(PLTYPE,3))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSLINE(XSTART,YSTART,X1,Y1)
      CALL PSLINE(XSTART,YSTART,X2,Y2)

C---- Plot the actual value
      DY = 0.20 * YHIGHT
      WRITE(NUMBER,110) VALUE
      CALL PSCTXT(XSTART,YSTART + DY,8.0,NUMBER)
      IF (INCOLR(PLTYPE)) CALL PSCOLB(0.0,0.0,0.0)

      RETURN
      END

C--------------------------------------------------------------------------
C**************************************************************************
C
C  SUBROUTINE DRWPLN  -  Draw distorted planar groups
C
C----------------------------------------------------------------------+---

      SUBROUTINE DRWPLN(DGX,DGY,XWIDTH,YHIGHT,INCHN,RESNAM,SEQNO,RMS,
     -    COORD,ANAME,NATOM)

      INCLUDE 'bplot.inc'

CHECK v.3.2-->
      INTEGER       NATOM
CHECK v.3.2<--
      CHARACTER*1   INCHN
      CHARACTER*3   ANAME(NATOM),RESNAM
      CHARACTER*5   NUMBER, SEQNO
      CHARACTER*10  RESID
CHECK v.3.2-->
C      INTEGER       ICOORD, IATOM, I1, I2, JATOM, NATOM
      INTEGER       ICOORD, IATOM, I1, I2, JATOM
CHECK v.3.2<--
      REAL          BLUE, CALC, COORD(3,NATOM), COV2, DGX, DGY, DIST2,
     -              DX, GREEN, RED, RMS, SCALE, XOFF, XSTART, XWIDTH,
     -              X1, X2, YHIGHT, YOFF, YSTART, Y1, Y2

      PARAMETER    (COV2 = 1.7 * 1.7)

C---- Initialise variables
      CALL PSLWID(0.1)
      SCALE = XWIDTH / DGLENP
      XOFF = 0.33 * XWIDTH
      YOFF = 0.35 * YHIGHT
      XSTART = DGX + (XWIDTH / 2.0)
      YSTART = DGY + 0.65 * YHIGHT

C---- Draw a box around the region
C      CALL PSHADE(1.0)
C      CALL PSBBOX(DGX,DGY,DGX,DGY+YHIGHT,DGX+XWIDTH,DGY+YHIGHT,
C     -    DGX+XWIDTH,DGY)

C---- Print the residue ID
      RESID = INCHN // ' ' // RESNAM // SEQNO
      IF (INCHN.EQ.' ') THEN
          I1 = 3
      ELSE
          I1 = 1
      ENDIF
      IF (RESID(9:10).EQ.'  ') THEN
          I2 = 8
      ELSE IF (RESID(10:10).EQ.' ') THEN
          I2 = 9
      ELSE
          I2 = 10
      ENDIF
      CALL PSCTXT(DGX + XWIDTH / 2.0,DGY + 0.1 * YHIGHT,10.0,
     -    RESID(I1:I2))

C---- Plot the RMS distance of the atoms from the best-fit plane
      WRITE(NUMBER,110) RMS
 110  FORMAT(F5.3)
      IF (INCOLR(PLTYPE)) THEN
          RED = RGB(1,COLPLT(PLTYPE,3))
          GREEN = RGB(2,COLPLT(PLTYPE,3))
          BLUE = RGB(3,COLPLT(PLTYPE,3))
          CALL PSCOLB(RED,GREEN,BLUE)
      ENDIF
      CALL PSCTXT(XSTART,DGY + 0.2 * YHIGHT,8.0,NUMBER)

C---- If necessary, flip entire residue upside down
      IF (COORD(2,1).GT.0.0) THEN
          DO 300, IATOM = 1, NATOM
              COORD(2,IATOM) = - COORD(2,IATOM)
 300      CONTINUE
      ENDIF

C---- Loop through all atom-pairs in the planar group
      DO 800, IATOM = 1, NATOM
          DO 600, JATOM = IATOM + 1, NATOM

C----         Calculate the distance between this atom-pair
              DIST2 = 0.0
              DO 500, ICOORD = 1, 3
                  CALC = COORD(ICOORD,IATOM) - COORD(ICOORD,JATOM)
                  DIST2 = DIST2 + CALC * CALC
 500          CONTINUE

C----         If this is less than the covalent bonding distance, join
C             the two atoms by a bond
              IF (DIST2.LE.COV2) THEN

C----             Plot face-on projection
                  X1 = XSTART + COORD(3,IATOM) * SCALE
                  X2 = XSTART + COORD(3,JATOM) * SCALE
                  Y1 = YSTART + COORD(2,IATOM) * SCALE
                  Y2 = YSTART + COORD(2,JATOM) * SCALE
                  CALL PSLWID(1.0)
                  CALL PSLINE(X1,Y1,X2,Y2)

C----             Plot projection shown on right-hand side
                  X1 = XSTART + XOFF + COORD(1,IATOM) * SCALE
                  X2 = XSTART + XOFF + COORD(1,JATOM) * SCALE
                  Y1 = YSTART + COORD(2,IATOM) * SCALE
                  Y2 = YSTART + COORD(2,JATOM) * SCALE
                  CALL PSLWID(0.3)
                  CALL PSLINE(X1,Y1,X2,Y2)

C----             Plot projection shown at bottom
                  X1 = XSTART + COORD(3,IATOM) * SCALE
                  X2 = XSTART + COORD(3,JATOM) * SCALE
                  Y1 = YSTART - YOFF + COORD(1,IATOM) * SCALE
                  Y2 = YSTART - YOFF + COORD(1,JATOM) * SCALE
                  CALL PSLWID(0.3)
                  CALL PSLINE(X1,Y1,X2,Y2)
              ENDIF
 600      CONTINUE
 800  CONTINUE

C---- Label the first atom
      DX = 0.03 * XWIDTH
      X1 = XSTART + COORD(3,1) * SCALE + DX
      Y1 = YSTART + COORD(2,1) * SCALE
      CALL PSTEXT(X1,Y1,6.0,ANAME(1))
      IF (INCOLR(PLTYPE)) CALL PSCOLB(0.0,0.0,0.0)

      RETURN
      END

C--------------------------------------------------------------------------
